/* App.c generated by valac 0.30.1, the Vala compiler
 * generated from App.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/
/**/
/*  Copyright (C) 2011-2012 Giulio Collura*/
/*                2013-2014 Akshay Shekher*/
/**/
/*  This program is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  This program is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <gio/gio.h>
#include <gtk/gtk.h>
#include <gmenu-tree.h>
#include <gio/gdesktopappinfo.h>
#include <glib/gi18n-lib.h>
#include <gobject/gvaluecollector.h>


#define PANTHER_BACKEND_TYPE_APP (panther_backend_app_get_type ())
#define PANTHER_BACKEND_APP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANTHER_BACKEND_TYPE_APP, PantherBackendApp))
#define PANTHER_BACKEND_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANTHER_BACKEND_TYPE_APP, PantherBackendAppClass))
#define PANTHER_BACKEND_IS_APP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANTHER_BACKEND_TYPE_APP))
#define PANTHER_BACKEND_IS_APP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANTHER_BACKEND_TYPE_APP))
#define PANTHER_BACKEND_APP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANTHER_BACKEND_TYPE_APP, PantherBackendAppClass))

typedef struct _PantherBackendApp PantherBackendApp;
typedef struct _PantherBackendAppClass PantherBackendAppClass;
typedef struct _PantherBackendAppPrivate PantherBackendAppPrivate;

#define PANTHER_BACKEND_APP_TYPE_APP_TYPE (panther_backend_app_app_type_get_type ())

#define SYNAPSE_TYPE_MATCH (synapse_match_get_type ())
#define SYNAPSE_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_MATCH, SynapseMatch))
#define SYNAPSE_IS_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_MATCH))
#define SYNAPSE_MATCH_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_MATCH, SynapseMatchIface))

typedef struct _SynapseMatch SynapseMatch;
typedef struct _SynapseMatchIface SynapseMatchIface;

#define SYNAPSE_TYPE_QUERY_FLAGS (synapse_query_flags_get_type ())

#define SYNAPSE_TYPE_MATCH_TYPE (synapse_match_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define PANTHER_TYPE_SETTINGS (panther_settings_get_type ())
#define PANTHER_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANTHER_TYPE_SETTINGS, PantherSettings))
#define PANTHER_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANTHER_TYPE_SETTINGS, PantherSettingsClass))
#define PANTHER_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANTHER_TYPE_SETTINGS))
#define PANTHER_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANTHER_TYPE_SETTINGS))
#define PANTHER_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANTHER_TYPE_SETTINGS, PantherSettingsClass))

typedef struct _PantherSettings PantherSettings;
typedef struct _PantherSettingsClass PantherSettingsClass;
typedef struct _Block1Data Block1Data;
#define _gtk_icon_info_free0(var) ((var == NULL) ? NULL : (var = (gtk_icon_info_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD (panther_backend_app_icon_load_fallback_method_get_type ())
#define PANTHER_BACKEND_APP_ICON_LOAD_FALLBACK_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD, PantherBackendAppIconLoadFallbackMethod))
#define PANTHER_BACKEND_APP_ICON_LOAD_FALLBACK_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD, PantherBackendAppIconLoadFallbackMethodClass))
#define PANTHER_BACKEND_APP_IS_ICON_LOAD_FALLBACK_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD))
#define PANTHER_BACKEND_APP_IS_ICON_LOAD_FALLBACK_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD))
#define PANTHER_BACKEND_APP_ICON_LOAD_FALLBACK_METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD, PantherBackendAppIconLoadFallbackMethodClass))

typedef struct _PantherBackendAppIconLoadFallbackMethod PantherBackendAppIconLoadFallbackMethod;
typedef struct _PantherBackendAppIconLoadFallbackMethodClass PantherBackendAppIconLoadFallbackMethodClass;
typedef struct _PantherBackendAppIconLoadFallbackMethodPrivate PantherBackendAppIconLoadFallbackMethodPrivate;
#define _panther_backend_app_icon_load_fallback_method_unref0(var) ((var == NULL) ? NULL : (var = (panther_backend_app_icon_load_fallback_method_unref (var), NULL)))

#define SYNAPSE_TYPE_SEARCH_PROVIDER (synapse_search_provider_get_type ())
#define SYNAPSE_SEARCH_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_SEARCH_PROVIDER, SynapseSearchProvider))
#define SYNAPSE_IS_SEARCH_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_SEARCH_PROVIDER))
#define SYNAPSE_SEARCH_PROVIDER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_SEARCH_PROVIDER, SynapseSearchProviderIface))

typedef struct _SynapseSearchProvider SynapseSearchProvider;
typedef struct _SynapseSearchProviderIface SynapseSearchProviderIface;

#define SYNAPSE_TYPE_RESULT_SET (synapse_result_set_get_type ())
#define SYNAPSE_RESULT_SET(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_RESULT_SET, SynapseResultSet))
#define SYNAPSE_RESULT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_TYPE_RESULT_SET, SynapseResultSetClass))
#define SYNAPSE_IS_RESULT_SET(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_RESULT_SET))
#define SYNAPSE_IS_RESULT_SET_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_TYPE_RESULT_SET))
#define SYNAPSE_RESULT_SET_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_TYPE_RESULT_SET, SynapseResultSetClass))

typedef struct _SynapseResultSet SynapseResultSet;
typedef struct _SynapseResultSetClass SynapseResultSetClass;

#define SYNAPSE_TYPE_SEARCH_MATCH (synapse_search_match_get_type ())
#define SYNAPSE_SEARCH_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_SEARCH_MATCH, SynapseSearchMatch))
#define SYNAPSE_IS_SEARCH_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_SEARCH_MATCH))
#define SYNAPSE_SEARCH_MATCH_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_SEARCH_MATCH, SynapseSearchMatchIface))

typedef struct _SynapseSearchMatch SynapseSearchMatch;
typedef struct _SynapseSearchMatchIface SynapseSearchMatchIface;
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
typedef struct _PantherBackendAppParamSpecIconLoadFallbackMethod PantherBackendAppParamSpecIconLoadFallbackMethod;

typedef enum  {
	ICON_ERROR_NOT_FOUND
} IconError;
#define ICON_ERROR icon_error_quark ()
struct _PantherBackendApp {
	GObject parent_instance;
	PantherBackendAppPrivate * priv;
};

struct _PantherBackendAppClass {
	GObjectClass parent_class;
};

typedef enum  {
	PANTHER_BACKEND_APP_APP_TYPE_APP,
	PANTHER_BACKEND_APP_APP_TYPE_COMMAND,
	PANTHER_BACKEND_APP_APP_TYPE_SYNAPSE
} PantherBackendAppAppType;

typedef enum  {
	SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE = 1 << 0,
	SYNAPSE_QUERY_FLAGS_UNCATEGORIZED = 1 << 1,
	SYNAPSE_QUERY_FLAGS_APPLICATIONS = 1 << 2,
	SYNAPSE_QUERY_FLAGS_ACTIONS = 1 << 3,
	SYNAPSE_QUERY_FLAGS_AUDIO = 1 << 4,
	SYNAPSE_QUERY_FLAGS_VIDEO = 1 << 5,
	SYNAPSE_QUERY_FLAGS_DOCUMENTS = 1 << 6,
	SYNAPSE_QUERY_FLAGS_IMAGES = 1 << 7,
	SYNAPSE_QUERY_FLAGS_FILES = ((SYNAPSE_QUERY_FLAGS_AUDIO | SYNAPSE_QUERY_FLAGS_VIDEO) | SYNAPSE_QUERY_FLAGS_DOCUMENTS) | SYNAPSE_QUERY_FLAGS_IMAGES,
	SYNAPSE_QUERY_FLAGS_PLACES = 1 << 8,
	SYNAPSE_QUERY_FLAGS_INTERNET = 1 << 9,
	SYNAPSE_QUERY_FLAGS_TEXT = 1 << 10,
	SYNAPSE_QUERY_FLAGS_CONTACTS = 1 << 11,
	SYNAPSE_QUERY_FLAGS_ALL = 0xFFFFFFFFLL,
	SYNAPSE_QUERY_FLAGS_LOCAL_CONTENT = SYNAPSE_QUERY_FLAGS_ALL ^ SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE
} SynapseQueryFlags;

typedef enum  {
	SYNAPSE_MATCH_TYPE_UNKNOWN = 0,
	SYNAPSE_MATCH_TYPE_TEXT,
	SYNAPSE_MATCH_TYPE_APPLICATION,
	SYNAPSE_MATCH_TYPE_GENERIC_URI,
	SYNAPSE_MATCH_TYPE_ACTION,
	SYNAPSE_MATCH_TYPE_SEARCH,
	SYNAPSE_MATCH_TYPE_CONTACT
} SynapseMatchType;

struct _SynapseMatchIface {
	GTypeInterface parent_iface;
	void (*execute) (SynapseMatch* self, SynapseMatch* match);
	void (*execute_with_target) (SynapseMatch* self, SynapseMatch* source, SynapseMatch* target);
	gboolean (*needs_target) (SynapseMatch* self);
	SynapseQueryFlags (*target_flags) (SynapseMatch* self);
	const gchar* (*get_title) (SynapseMatch* self);
	void (*set_title) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_description) (SynapseMatch* self);
	void (*set_description) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_icon_name) (SynapseMatch* self);
	void (*set_icon_name) (SynapseMatch* self, const gchar* value);
	gboolean (*get_has_thumbnail) (SynapseMatch* self);
	void (*set_has_thumbnail) (SynapseMatch* self, gboolean value);
	const gchar* (*get_thumbnail_path) (SynapseMatch* self);
	void (*set_thumbnail_path) (SynapseMatch* self, const gchar* value);
	SynapseMatchType (*get_match_type) (SynapseMatch* self);
	void (*set_match_type) (SynapseMatch* self, SynapseMatchType value);
};

struct _PantherBackendAppPrivate {
	gchar* _name;
	gchar* _description;
	gchar* _desktop_id;
	gchar* _exec;
	gchar* _icon_name;
	gchar** _keywords;
	gint _keywords_length1;
	gint __keywords_size_;
	GdkPixbuf* _icon;
	gdouble _popularity;
	gdouble _relevancy;
	gchar* _desktop_path;
	gchar* _categories;
	gchar* _generic_name;
	PantherBackendAppAppType _app_type;
	SynapseMatch* _match;
	SynapseMatch* _target;
	GeeArrayList* _actions;
	GeeHashMap* _actions_map;
	gboolean check_icon_again;
	gint firstres;
	gint secondres;
	gint res;
	GLoadableIcon* loadable_icon;
};

struct _Block1Data {
	int _ref_count_;
	PantherBackendApp* self;
	GdkPixbuf* icon;
	GtkIconLookupFlags flags;
	gint size;
};

typedef void (*PantherBackendAppIconLoadFallback) (void* user_data);
struct _PantherBackendAppIconLoadFallbackMethod {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PantherBackendAppIconLoadFallbackMethodPrivate * priv;
	PantherBackendAppIconLoadFallback load_icon;
	gpointer load_icon_target;
};

struct _PantherBackendAppIconLoadFallbackMethodClass {
	GTypeClass parent_class;
	void (*finalize) (PantherBackendAppIconLoadFallbackMethod *self);
};

typedef enum  {
	SYNAPSE_SEARCH_ERROR_SEARCH_CANCELLED,
	SYNAPSE_SEARCH_ERROR_UNKNOWN_ERROR
} SynapseSearchError;
#define SYNAPSE_SEARCH_ERROR synapse_search_error_quark ()
struct _SynapseSearchProviderIface {
	GTypeInterface parent_iface;
	void (*search) (SynapseSearchProvider* self, const gchar* query, SynapseQueryFlags flags, SynapseResultSet* dest_result_set, GCancellable* cancellable, GAsyncReadyCallback _callback_, gpointer _user_data_);
	GeeList* (*search_finish) (SynapseSearchProvider* self, GAsyncResult* _res_, GError** error);
};

struct _SynapseSearchMatchIface {
	GTypeInterface parent_iface;
	SynapseMatch* (*get_search_source) (SynapseSearchMatch* self);
	void (*set_search_source) (SynapseSearchMatch* self, SynapseMatch* value);
};

struct _PantherBackendAppParamSpecIconLoadFallbackMethod {
	GParamSpec parent_instance;
};


static gpointer panther_backend_app_parent_class = NULL;
static gpointer panther_backend_app_icon_load_fallback_method_parent_class = NULL;

GQuark icon_error_quark (void);
GType panther_backend_app_get_type (void) G_GNUC_CONST;
GType panther_backend_app_app_type_get_type (void) G_GNUC_CONST;
GType synapse_query_flags_get_type (void) G_GNUC_CONST;
GType synapse_match_type_get_type (void) G_GNUC_CONST;
GType synapse_match_get_type (void) G_GNUC_CONST;
#define PANTHER_BACKEND_APP_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PANTHER_BACKEND_TYPE_APP, PantherBackendAppPrivate))
enum  {
	PANTHER_BACKEND_APP_DUMMY_PROPERTY,
	PANTHER_BACKEND_APP_NAME,
	PANTHER_BACKEND_APP_DESCRIPTION,
	PANTHER_BACKEND_APP_DESKTOP_ID,
	PANTHER_BACKEND_APP_EXEC,
	PANTHER_BACKEND_APP_ICON_NAME,
	PANTHER_BACKEND_APP_KEYWORDS,
	PANTHER_BACKEND_APP_ICON,
	PANTHER_BACKEND_APP_POPULARITY,
	PANTHER_BACKEND_APP_RELEVANCY,
	PANTHER_BACKEND_APP_DESKTOP_PATH,
	PANTHER_BACKEND_APP_CATEGORIES,
	PANTHER_BACKEND_APP_GENERIC_NAME,
	PANTHER_BACKEND_APP_APP_TYPE,
	PANTHER_BACKEND_APP_MATCH,
	PANTHER_BACKEND_APP_TARGET,
	PANTHER_BACKEND_APP_ACTIONS,
	PANTHER_BACKEND_APP_ACTIONS_MAP
};
GtkIconTheme* panther_panther_get_icon_theme (void);
void panther_backend_app_update_icon (PantherBackendApp* self);
static void _panther_backend_app_update_icon_gtk_icon_theme_changed (GtkIconTheme* _sender, gpointer self);
#define PANTHER_BACKEND_APP_RECHECK_TIMEOUT 2
#define PANTHER_BACKEND_APP_DESKTOP_ACTION_KEY "Actions"
#define PANTHER_BACKEND_APP_DESKTOP_ACTION_GROUP_NAME "Desktop Action %s"
PantherBackendApp* panther_backend_app_new (GMenuTreeEntry* entry);
PantherBackendApp* panther_backend_app_construct (GType object_type, GMenuTreeEntry* entry);
static void panther_backend_app_set_app_type (PantherBackendApp* self, PantherBackendAppAppType value);
void panther_backend_app_set_name (PantherBackendApp* self, const gchar* value);
const gchar* panther_backend_app_get_name (PantherBackendApp* self);
static void panther_backend_app_set_description (PantherBackendApp* self, const gchar* value);
static void panther_backend_app_set_exec (PantherBackendApp* self, const gchar* value);
void panther_backend_app_set_desktop_id (PantherBackendApp* self, const gchar* value);
static void panther_backend_app_set_desktop_path (PantherBackendApp* self, const gchar* value);
static void panther_backend_app_set_categories (PantherBackendApp* self, const gchar* value);
static void panther_backend_app_set_generic_name (PantherBackendApp* self, const gchar* value);
static void panther_backend_app_set_icon_name (PantherBackendApp* self, const gchar* value);
GdkPixbuf* panther_backend_app_get_loadable_icon (PantherBackendApp* self);
static void panther_backend_app_set_icon (PantherBackendApp* self, GdkPixbuf* value);
GdkPixbuf* panther_backend_app_get_icon (PantherBackendApp* self);
PantherBackendApp* panther_backend_app_new_from_command (const gchar* command);
PantherBackendApp* panther_backend_app_construct_from_command (GType object_type, const gchar* command);
PantherBackendApp* panther_backend_app_new_from_synapse_match (SynapseMatch* match, SynapseMatch* target);
PantherBackendApp* panther_backend_app_construct_from_synapse_match (GType object_type, SynapseMatch* match, SynapseMatch* target);
const gchar* synapse_match_get_title (SynapseMatch* self);
const gchar* synapse_match_get_description (SynapseMatch* self);
const gchar* synapse_match_get_icon_name (SynapseMatch* self);
static void panther_backend_app_set_match (PantherBackendApp* self, SynapseMatch* value);
static void panther_backend_app_set_target (PantherBackendApp* self, SynapseMatch* value);
GType panther_settings_get_type (void) G_GNUC_CONST;
PantherSettings* panther_panther_get_settings (void);
gint panther_settings_get_icon_size (PantherSettings* self);
GdkPixbuf* panther_backend_app_load_icon (PantherBackendApp* self, gint size);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
PantherBackendAppAppType panther_backend_app_get_app_type (PantherBackendApp* self);
SynapseMatch* panther_backend_app_get_match (PantherBackendApp* self);
SynapseMatchType synapse_match_get_match_type (SynapseMatch* self);
gboolean synapse_match_get_has_thumbnail (SynapseMatch* self);
const gchar* synapse_match_get_thumbnail_path (SynapseMatch* self);
const gchar* panther_backend_app_get_icon_name (PantherBackendApp* self);
static gpointer panther_backend_app_icon_load_fallback_method_ref (gpointer instance);
static void panther_backend_app_icon_load_fallback_method_unref (gpointer instance);
static GParamSpec* panther_backend_app_param_spec_icon_load_fallback_method (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) G_GNUC_UNUSED;
static void panther_backend_app_value_set_icon_load_fallback_method (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static void panther_backend_app_value_take_icon_load_fallback_method (GValue* value, gpointer v_object) G_GNUC_UNUSED;
static gpointer panther_backend_app_value_get_icon_load_fallback_method (const GValue* value) G_GNUC_UNUSED;
static GType panther_backend_app_icon_load_fallback_method_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static void __lambda31_ (Block1Data* _data1_);
static void ___lambda31__panther_backend_app_icon_load_fallback (gpointer self);
static PantherBackendAppIconLoadFallbackMethod* panther_backend_app_icon_load_fallback_method_new (PantherBackendAppIconLoadFallback fallback, void* fallback_target);
static PantherBackendAppIconLoadFallbackMethod* panther_backend_app_icon_load_fallback_method_construct (GType object_type, PantherBackendAppIconLoadFallback fallback, void* fallback_target);
static void __lambda32_ (PantherBackendApp* self);
static gboolean ___lambda33_ (PantherBackendApp* self);
static gboolean ____lambda33__gsource_func (gpointer self);
static void ___lambda32__panther_backend_app_icon_load_fallback (gpointer self);
static void __lambda34_ (Block1Data* _data1_);
static void ___lambda34__panther_backend_app_icon_load_fallback (gpointer self);
static void __lambda35_ (Block1Data* _data1_);
static void ___lambda35__panther_backend_app_icon_load_fallback (gpointer self);
static void __lambda36_ (Block1Data* _data1_);
static void ___lambda36__panther_backend_app_icon_load_fallback (gpointer self);
static void __lambda37_ (Block1Data* _data1_);
static void ___lambda37__panther_backend_app_icon_load_fallback (gpointer self);
gboolean panther_backend_app_launch (PantherBackendApp* self);
const gchar* panther_backend_app_get_exec (PantherBackendApp* self);
const gchar* panther_backend_app_get_desktop_id (PantherBackendApp* self);
GType synapse_result_set_get_type (void) G_GNUC_CONST;
GQuark synapse_search_error_quark (void);
GType synapse_search_provider_get_type (void) G_GNUC_CONST;
GType synapse_search_match_get_type (void) G_GNUC_CONST;
SynapseMatch* panther_backend_app_get_target (PantherBackendApp* self);
GeeList* panther_backend_synapse_search_find_actions_for_match (SynapseMatch* match);
void synapse_match_execute_with_target (SynapseMatch* self, SynapseMatch* source, SynapseMatch* target);
void panther_backend_app_init_actions (PantherBackendApp* self, GError** error);
static void panther_backend_app_set_actions (PantherBackendApp* self, GeeArrayList* value);
static void panther_backend_app_set_actions_map (PantherBackendApp* self, GeeHashMap* value);
const gchar* panther_backend_app_get_desktop_path (PantherBackendApp* self);
GeeArrayList* panther_backend_app_get_actions (PantherBackendApp* self);
GeeHashMap* panther_backend_app_get_actions_map (PantherBackendApp* self);
const gchar* panther_backend_app_get_description (PantherBackendApp* self);
gchar** panther_backend_app_get_keywords (PantherBackendApp* self, int* result_length1);
static void panther_backend_app_set_keywords (PantherBackendApp* self, gchar** value, int value_length1);
static gchar** _vala_array_dup1 (gchar** self, int length);
gdouble panther_backend_app_get_popularity (PantherBackendApp* self);
void panther_backend_app_set_popularity (PantherBackendApp* self, gdouble value);
gdouble panther_backend_app_get_relevancy (PantherBackendApp* self);
void panther_backend_app_set_relevancy (PantherBackendApp* self, gdouble value);
const gchar* panther_backend_app_get_categories (PantherBackendApp* self);
const gchar* panther_backend_app_get_generic_name (PantherBackendApp* self);
static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data);
enum  {
	PANTHER_BACKEND_APP_ICON_LOAD_FALLBACK_METHOD_DUMMY_PROPERTY
};
static void panther_backend_app_icon_load_fallback_method_finalize (PantherBackendAppIconLoadFallbackMethod* obj);
static void panther_backend_app_finalize (GObject* obj);
static void _vala_panther_backend_app_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_panther_backend_app_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const gchar* PANTHER_BACKEND_APP_SUPPORTED_GETTEXT_DOMAINS_KEYS[2] = {"X-Ubuntu-Gettext-Domain", "X-GNOME-Gettext-Domain"};

GQuark icon_error_quark (void) {
	return g_quark_from_static_string ("icon_error-quark");
}


static void _panther_backend_app_update_icon_gtk_icon_theme_changed (GtkIconTheme* _sender, gpointer self) {
	panther_backend_app_update_icon ((PantherBackendApp*) self);
}


GType panther_backend_app_app_type_get_type (void) {
	static volatile gsize panther_backend_app_app_type_type_id__volatile = 0;
	if (g_once_init_enter (&panther_backend_app_app_type_type_id__volatile)) {
		static const GEnumValue values[] = {{PANTHER_BACKEND_APP_APP_TYPE_APP, "PANTHER_BACKEND_APP_APP_TYPE_APP", "app"}, {PANTHER_BACKEND_APP_APP_TYPE_COMMAND, "PANTHER_BACKEND_APP_APP_TYPE_COMMAND", "command"}, {PANTHER_BACKEND_APP_APP_TYPE_SYNAPSE, "PANTHER_BACKEND_APP_APP_TYPE_SYNAPSE", "synapse"}, {0, NULL, NULL}};
		GType panther_backend_app_app_type_type_id;
		panther_backend_app_app_type_type_id = g_enum_register_static ("PantherBackendAppAppType", values);
		g_once_init_leave (&panther_backend_app_app_type_type_id__volatile, panther_backend_app_app_type_type_id);
	}
	return panther_backend_app_app_type_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


PantherBackendApp* panther_backend_app_construct (GType object_type, GMenuTreeEntry* entry) {
	PantherBackendApp * self = NULL;
	GDesktopAppInfo* info = NULL;
	GMenuTreeEntry* _tmp0_ = NULL;
	GDesktopAppInfo* _tmp1_ = NULL;
	GDesktopAppInfo* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	GDesktopAppInfo* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	GDesktopAppInfo* _tmp12_ = NULL;
	const gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_ = NULL;
	GMenuTreeEntry* _tmp16_ = NULL;
	const gchar* _tmp17_ = NULL;
	GMenuTreeEntry* _tmp18_ = NULL;
	const gchar* _tmp19_ = NULL;
	GDesktopAppInfo* _tmp20_ = NULL;
	const gchar* _tmp21_ = NULL;
	GDesktopAppInfo* _tmp22_ = NULL;
	const gchar* _tmp23_ = NULL;
	GDesktopAppInfo* _tmp24_ = NULL;
	GIcon* _tmp25_ = NULL;
	GdkPixbuf* _tmp40_ = NULL;
	g_return_val_if_fail (entry != NULL, NULL);
	self = (PantherBackendApp*) g_object_new (object_type, NULL);
	panther_backend_app_set_app_type (self, PANTHER_BACKEND_APP_APP_TYPE_APP);
	_tmp0_ = entry;
	_tmp1_ = gmenu_tree_entry_get_app_info (_tmp0_);
	info = _tmp1_;
	_tmp2_ = info;
	_tmp3_ = g_app_info_get_display_name ((GAppInfo*) _tmp2_);
	_tmp4_ = g_strdup (_tmp3_);
	_tmp5_ = _tmp4_;
	panther_backend_app_set_name (self, _tmp5_);
	_g_free0 (_tmp5_);
	_tmp7_ = info;
	_tmp8_ = g_app_info_get_description ((GAppInfo*) _tmp7_);
	_tmp9_ = g_strdup (_tmp8_);
	_tmp6_ = _tmp9_;
	if (_tmp6_ == NULL) {
		const gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		_tmp10_ = self->priv->_name;
		_tmp11_ = g_strdup (_tmp10_);
		_g_free0 (_tmp6_);
		_tmp6_ = _tmp11_;
	}
	panther_backend_app_set_description (self, _tmp6_);
	_tmp12_ = info;
	_tmp13_ = g_app_info_get_commandline ((GAppInfo*) _tmp12_);
	_tmp14_ = g_strdup (_tmp13_);
	_tmp15_ = _tmp14_;
	panther_backend_app_set_exec (self, _tmp15_);
	_g_free0 (_tmp15_);
	_tmp16_ = entry;
	_tmp17_ = gmenu_tree_entry_get_desktop_file_id (_tmp16_);
	panther_backend_app_set_desktop_id (self, _tmp17_);
	_tmp18_ = entry;
	_tmp19_ = gmenu_tree_entry_get_desktop_file_path (_tmp18_);
	panther_backend_app_set_desktop_path (self, _tmp19_);
	_tmp20_ = info;
	_tmp21_ = g_desktop_app_info_get_categories (_tmp20_);
	panther_backend_app_set_categories (self, _tmp21_);
	_tmp22_ = info;
	_tmp23_ = g_desktop_app_info_get_generic_name (_tmp22_);
	panther_backend_app_set_generic_name (self, _tmp23_);
	_tmp24_ = info;
	_tmp25_ = g_app_info_get_icon ((GAppInfo*) _tmp24_);
	if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp25_, g_themed_icon_get_type ())) {
		GDesktopAppInfo* _tmp26_ = NULL;
		GIcon* _tmp27_ = NULL;
		gchar** _tmp28_ = NULL;
		gchar** _tmp29_ = NULL;
		const gchar* _tmp30_ = NULL;
		gchar* _tmp31_ = NULL;
		gchar* _tmp32_ = NULL;
		_tmp26_ = info;
		_tmp27_ = g_app_info_get_icon ((GAppInfo*) _tmp26_);
		_tmp29_ = _tmp28_ = g_themed_icon_get_names (G_TYPE_CHECK_INSTANCE_TYPE (_tmp27_, g_themed_icon_get_type ()) ? ((GThemedIcon*) _tmp27_) : NULL);
		_tmp30_ = _tmp29_[0];
		_tmp31_ = g_strdup (_tmp30_);
		_tmp32_ = _tmp31_;
		panther_backend_app_set_icon_name (self, _tmp32_);
		_g_free0 (_tmp32_);
	} else {
		GDesktopAppInfo* _tmp33_ = NULL;
		GIcon* _tmp34_ = NULL;
		_tmp33_ = info;
		_tmp34_ = g_app_info_get_icon ((GAppInfo*) _tmp33_);
		if (G_TYPE_CHECK_INSTANCE_TYPE (_tmp34_, g_loadable_icon_get_type ())) {
			GDesktopAppInfo* _tmp35_ = NULL;
			GIcon* _tmp36_ = NULL;
			GLoadableIcon* _tmp37_ = NULL;
			GdkPixbuf* _tmp38_ = NULL;
			GdkPixbuf* _tmp39_ = NULL;
			_tmp35_ = info;
			_tmp36_ = g_app_info_get_icon ((GAppInfo*) _tmp35_);
			_tmp37_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp36_, g_loadable_icon_get_type ()) ? ((GLoadableIcon*) _tmp36_) : NULL);
			_g_object_unref0 (self->priv->loadable_icon);
			self->priv->loadable_icon = _tmp37_;
			_tmp38_ = panther_backend_app_get_loadable_icon (self);
			_tmp39_ = _tmp38_;
			panther_backend_app_set_icon (self, _tmp39_);
			_g_object_unref0 (_tmp39_);
		} else {
			panther_backend_app_set_icon_name (self, "application-default-icon");
		}
	}
	_tmp40_ = self->priv->_icon;
	if (_tmp40_ == NULL) {
		GtkIconTheme* _tmp41_ = NULL;
		GtkIconTheme* _tmp42_ = NULL;
		panther_backend_app_update_icon (self);
		_tmp41_ = panther_panther_get_icon_theme ();
		_tmp42_ = _tmp41_;
		g_signal_connect_object (_tmp42_, "changed", (GCallback) _panther_backend_app_update_icon_gtk_icon_theme_changed, self, 0);
	}
	_g_free0 (_tmp6_);
	return self;
}


PantherBackendApp* panther_backend_app_new (GMenuTreeEntry* entry) {
	return panther_backend_app_construct (PANTHER_BACKEND_TYPE_APP, entry);
}


PantherBackendApp* panther_backend_app_construct_from_command (GType object_type, const gchar* command) {
	PantherBackendApp * self = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_val_if_fail (command != NULL, NULL);
	self = (PantherBackendApp*) g_object_new (object_type, NULL);
	panther_backend_app_set_app_type (self, PANTHER_BACKEND_APP_APP_TYPE_COMMAND);
	_tmp0_ = command;
	panther_backend_app_set_name (self, _tmp0_);
	_tmp1_ = _ ("Run this command…");
	panther_backend_app_set_description (self, _tmp1_);
	_tmp2_ = command;
	panther_backend_app_set_exec (self, _tmp2_);
	_tmp3_ = command;
	panther_backend_app_set_desktop_id (self, _tmp3_);
	panther_backend_app_set_icon_name (self, "system-run");
	panther_backend_app_update_icon (self);
	return self;
}


PantherBackendApp* panther_backend_app_new_from_command (const gchar* command) {
	return panther_backend_app_construct_from_command (PANTHER_BACKEND_TYPE_APP, command);
}


PantherBackendApp* panther_backend_app_construct_from_synapse_match (GType object_type, SynapseMatch* match, SynapseMatch* target) {
	PantherBackendApp * self = NULL;
	SynapseMatch* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	SynapseMatch* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	SynapseMatch* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	SynapseMatch* _tmp9_ = NULL;
	SynapseMatch* _tmp10_ = NULL;
	g_return_val_if_fail (match != NULL, NULL);
	self = (PantherBackendApp*) g_object_new (object_type, NULL);
	panther_backend_app_set_app_type (self, PANTHER_BACKEND_APP_APP_TYPE_SYNAPSE);
	_tmp0_ = match;
	_tmp1_ = synapse_match_get_title (_tmp0_);
	_tmp2_ = _tmp1_;
	panther_backend_app_set_name (self, _tmp2_);
	_tmp3_ = match;
	_tmp4_ = synapse_match_get_description (_tmp3_);
	_tmp5_ = _tmp4_;
	panther_backend_app_set_description (self, _tmp5_);
	_tmp6_ = match;
	_tmp7_ = synapse_match_get_icon_name (_tmp6_);
	_tmp8_ = _tmp7_;
	panther_backend_app_set_icon_name (self, _tmp8_);
	_tmp9_ = match;
	panther_backend_app_set_match (self, _tmp9_);
	_tmp10_ = target;
	panther_backend_app_set_target (self, _tmp10_);
	panther_backend_app_update_icon (self);
	return self;
}


PantherBackendApp* panther_backend_app_new_from_synapse_match (SynapseMatch* match, SynapseMatch* target) {
	return panther_backend_app_construct_from_synapse_match (PANTHER_BACKEND_TYPE_APP, match, target);
}


void panther_backend_app_update_icon (PantherBackendApp* self) {
	PantherSettings* _tmp0_ = NULL;
	PantherSettings* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = panther_panther_get_settings ();
	_tmp1_ = _tmp0_;
	_tmp2_ = panther_settings_get_icon_size (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ == 0) {
		GdkPixbuf* _tmp4_ = NULL;
		GdkPixbuf* _tmp5_ = NULL;
		_tmp4_ = panther_backend_app_load_icon (self, 64);
		_tmp5_ = _tmp4_;
		panther_backend_app_set_icon (self, _tmp5_);
		_g_object_unref0 (_tmp5_);
	} else {
		PantherSettings* _tmp6_ = NULL;
		PantherSettings* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		GdkPixbuf* _tmp10_ = NULL;
		GdkPixbuf* _tmp11_ = NULL;
		_tmp6_ = panther_panther_get_settings ();
		_tmp7_ = _tmp6_;
		_tmp8_ = panther_settings_get_icon_size (_tmp7_);
		_tmp9_ = _tmp8_;
		_tmp10_ = panther_backend_app_load_icon (self, _tmp9_);
		_tmp11_ = _tmp10_;
		panther_backend_app_set_icon (self, _tmp11_);
		_g_object_unref0 (_tmp11_);
	}
	g_signal_emit_by_name (self, "icon-changed");
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		PantherBackendApp* self;
		self = _data1_->self;
		_g_object_unref0 (_data1_->icon);
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda31_ (Block1Data* _data1_) {
	PantherBackendApp* self;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	{
		GdkPixbuf* _tmp0_ = NULL;
		GtkIconTheme* _tmp1_ = NULL;
		GtkIconTheme* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		GtkIconLookupFlags _tmp5_ = 0;
		GdkPixbuf* _tmp6_ = NULL;
		GdkPixbuf* _tmp7_ = NULL;
		_tmp1_ = panther_panther_get_icon_theme ();
		_tmp2_ = _tmp1_;
		_tmp3_ = self->priv->_icon_name;
		_tmp4_ = _data1_->size;
		_tmp5_ = _data1_->flags;
		_tmp6_ = gtk_icon_theme_load_icon (_tmp2_, _tmp3_, _tmp4_, _tmp5_, &_inner_error_);
		_tmp0_ = _tmp6_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch2_g_error;
		}
		_tmp7_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (_data1_->icon);
		_data1_->icon = _tmp7_;
		_g_object_unref0 (_tmp0_);
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("App.vala:207: Could not load icon. Falling back to method 2");
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda31__panther_backend_app_icon_load_fallback (gpointer self) {
	__lambda31_ (self);
}


static gboolean ___lambda33_ (PantherBackendApp* self) {
	gboolean result = FALSE;
	GtkIconTheme* _tmp0_ = NULL;
	GtkIconTheme* _tmp1_ = NULL;
	_tmp0_ = panther_panther_get_icon_theme ();
	_tmp1_ = _tmp0_;
	gtk_icon_theme_rescan_if_needed (_tmp1_);
	panther_backend_app_update_icon (self);
	result = FALSE;
	return result;
}


static gboolean ____lambda33__gsource_func (gpointer self) {
	gboolean result;
	result = ___lambda33_ ((PantherBackendApp*) self);
	return result;
}


static void __lambda32_ (PantherBackendApp* self) {
	gboolean _tmp0_ = FALSE;
	_tmp0_ = self->priv->check_icon_again;
	if (_tmp0_) {
		self->priv->check_icon_again = FALSE;
		g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) PANTHER_BACKEND_APP_RECHECK_TIMEOUT, ____lambda33__gsource_func, g_object_ref (self), g_object_unref);
	}
}


static void ___lambda32__panther_backend_app_icon_load_fallback (gpointer self) {
	__lambda32_ ((PantherBackendApp*) self);
}


static gint string_last_index_of (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_ = 0;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_ = NULL;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	glong string_length = 0L;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	glong _tmp2_ = 0L;
	glong _tmp5_ = 0L;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_ = 0L;
	gboolean _tmp12_ = FALSE;
	glong _tmp13_ = 0L;
	glong _tmp16_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	gchar* _tmp21_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_ = 0L;
		glong _tmp7_ = 0L;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	g_return_val_if_fail (_tmp8_, NULL);
	_tmp13_ = end;
	if (_tmp13_ >= ((glong) 0)) {
		glong _tmp14_ = 0L;
		glong _tmp15_ = 0L;
		_tmp14_ = end;
		_tmp15_ = string_length;
		_tmp12_ = _tmp14_ <= _tmp15_;
	} else {
		_tmp12_ = FALSE;
	}
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp16_ = start;
	_tmp17_ = end;
	g_return_val_if_fail (_tmp16_ <= _tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	_tmp20_ = start;
	_tmp21_ = g_strndup (((gchar*) self) + _tmp18_, (gsize) (_tmp19_ - _tmp20_));
	result = _tmp21_;
	return result;
}


static void __lambda34_ (Block1Data* _data1_) {
	PantherBackendApp* self;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	{
		const gchar* _tmp0_ = NULL;
		gint _tmp1_ = 0;
		_tmp0_ = self->priv->_icon_name;
		_tmp1_ = string_last_index_of (_tmp0_, ".", 0);
		if (_tmp1_ > 0) {
			gchar* name = NULL;
			const gchar* _tmp2_ = NULL;
			const gchar* _tmp3_ = NULL;
			gint _tmp4_ = 0;
			gchar* _tmp5_ = NULL;
			GdkPixbuf* _tmp6_ = NULL;
			GtkIconTheme* _tmp7_ = NULL;
			GtkIconTheme* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			gint _tmp10_ = 0;
			GtkIconLookupFlags _tmp11_ = 0;
			GdkPixbuf* _tmp12_ = NULL;
			GdkPixbuf* _tmp13_ = NULL;
			_tmp2_ = self->priv->_icon_name;
			_tmp3_ = self->priv->_icon_name;
			_tmp4_ = string_last_index_of (_tmp3_, ".", 0);
			_tmp5_ = string_slice (_tmp2_, (glong) 0, (glong) _tmp4_);
			name = _tmp5_;
			_tmp7_ = panther_panther_get_icon_theme ();
			_tmp8_ = _tmp7_;
			_tmp9_ = name;
			_tmp10_ = _data1_->size;
			_tmp11_ = _data1_->flags;
			_tmp12_ = gtk_icon_theme_load_icon (_tmp8_, _tmp9_, _tmp10_, _tmp11_, &_inner_error_);
			_tmp6_ = _tmp12_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (name);
				goto __catch3_g_error;
			}
			_tmp13_ = _tmp6_;
			_tmp6_ = NULL;
			_g_object_unref0 (_data1_->icon);
			_data1_->icon = _tmp13_;
			_g_object_unref0 (_tmp6_);
			_g_free0 (name);
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("App.vala:232: Could not load icon. Falling back to method 3");
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda34__panther_backend_app_icon_load_fallback (gpointer self) {
	__lambda34_ (self);
}


static void __lambda35_ (Block1Data* _data1_) {
	PantherBackendApp* self;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	{
		GdkPixbuf* _tmp0_ = NULL;
		const gchar* _tmp1_ = NULL;
		gint _tmp2_ = 0;
		gint _tmp3_ = 0;
		GdkPixbuf* _tmp4_ = NULL;
		GdkPixbuf* _tmp5_ = NULL;
		_tmp1_ = self->priv->_icon_name;
		_tmp2_ = _data1_->size;
		_tmp3_ = _data1_->size;
		_tmp4_ = gdk_pixbuf_new_from_file_at_scale (_tmp1_, _tmp2_, _tmp3_, FALSE, &_inner_error_);
		_tmp0_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch4_g_error;
		}
		_tmp5_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (_data1_->icon);
		_data1_->icon = _tmp5_;
		_g_object_unref0 (_tmp0_);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("App.vala:240: Could not load icon. Falling back to method 4");
		_g_error_free0 (e);
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda35__panther_backend_app_icon_load_fallback (gpointer self) {
	__lambda35_ (self);
}


static void __lambda36_ (Block1Data* _data1_) {
	PantherBackendApp* self;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	{
		GdkPixbuf* _tmp0_ = NULL;
		GtkIconTheme* _tmp1_ = NULL;
		GtkIconTheme* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		GtkIconLookupFlags _tmp4_ = 0;
		GdkPixbuf* _tmp5_ = NULL;
		GdkPixbuf* _tmp6_ = NULL;
		_tmp1_ = panther_panther_get_icon_theme ();
		_tmp2_ = _tmp1_;
		_tmp3_ = _data1_->size;
		_tmp4_ = _data1_->flags;
		_tmp5_ = gtk_icon_theme_load_icon (_tmp2_, "application-default-icon", _tmp3_, _tmp4_, &_inner_error_);
		_tmp0_ = _tmp5_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch5_g_error;
		}
		_tmp6_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (_data1_->icon);
		_data1_->icon = _tmp6_;
		_g_object_unref0 (_tmp0_);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_warning ("App.vala:248: Could not load icon. Falling back to method 5");
		_g_error_free0 (e);
	}
	__finally5:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda36__panther_backend_app_icon_load_fallback (gpointer self) {
	__lambda36_ (self);
}


static void __lambda37_ (Block1Data* _data1_) {
	PantherBackendApp* self;
	GError * _inner_error_ = NULL;
	self = _data1_->self;
	{
		GdkPixbuf* _tmp0_ = NULL;
		GtkIconTheme* _tmp1_ = NULL;
		GtkIconTheme* _tmp2_ = NULL;
		gint _tmp3_ = 0;
		GtkIconLookupFlags _tmp4_ = 0;
		GdkPixbuf* _tmp5_ = NULL;
		GdkPixbuf* _tmp6_ = NULL;
		_tmp1_ = panther_panther_get_icon_theme ();
		_tmp2_ = _tmp1_;
		_tmp3_ = _data1_->size;
		_tmp4_ = _data1_->flags;
		_tmp5_ = gtk_icon_theme_load_icon (_tmp2_, "image-missing", _tmp3_, _tmp4_, &_inner_error_);
		_tmp0_ = _tmp5_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch6_g_error;
		}
		_tmp6_ = _tmp0_;
		_tmp0_ = NULL;
		_g_object_unref0 (_data1_->icon);
		_data1_->icon = _tmp6_;
		_g_object_unref0 (_tmp0_);
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_error ("App.vala:256: Could not find a fallback icon to load");
		_g_error_free0 (e);
	}
	__finally6:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


static void ___lambda37__panther_backend_app_icon_load_fallback (gpointer self) {
	__lambda37_ (self);
}


static gpointer _panther_backend_app_icon_load_fallback_method_ref0 (gpointer self) {
	return self ? panther_backend_app_icon_load_fallback_method_ref (self) : NULL;
}


GdkPixbuf* panther_backend_app_load_icon (PantherBackendApp* self, gint size) {
	GdkPixbuf* result = NULL;
	Block1Data* _data1_;
	gint _tmp0_ = 0;
	PantherBackendAppAppType _tmp1_ = 0;
	GLoadableIcon* _tmp39_ = NULL;
	PantherBackendAppIconLoadFallbackMethod** fallbacks = NULL;
	PantherBackendAppIconLoadFallbackMethod* _tmp41_ = NULL;
	PantherBackendAppIconLoadFallbackMethod* _tmp42_ = NULL;
	PantherBackendAppIconLoadFallbackMethod* _tmp43_ = NULL;
	PantherBackendAppIconLoadFallbackMethod* _tmp44_ = NULL;
	PantherBackendAppIconLoadFallbackMethod* _tmp45_ = NULL;
	PantherBackendAppIconLoadFallbackMethod* _tmp46_ = NULL;
	PantherBackendAppIconLoadFallbackMethod** _tmp47_ = NULL;
	gint fallbacks_length1 = 0;
	gint _fallbacks_size_ = 0;
	PantherBackendAppIconLoadFallbackMethod** _tmp48_ = NULL;
	gint _tmp48__length1 = 0;
	GdkPixbuf* _tmp53_ = NULL;
	GdkPixbuf* _tmp54_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = size;
	_data1_->size = _tmp0_;
	_tmp1_ = self->priv->_app_type;
	if (_tmp1_ == PANTHER_BACKEND_APP_APP_TYPE_SYNAPSE) {
		{
			gboolean _tmp2_ = FALSE;
			SynapseMatch* _tmp3_ = NULL;
			SynapseMatchType _tmp4_ = 0;
			SynapseMatchType _tmp5_ = 0;
			GIcon* icon = NULL;
			const gchar* _tmp17_ = NULL;
			GIcon* _tmp18_ = NULL;
			GtkIconInfo* info = NULL;
			GtkIconTheme* _tmp19_ = NULL;
			GIcon* _tmp20_ = NULL;
			gint _tmp21_ = 0;
			GtkIconInfo* _tmp22_ = NULL;
			GtkIconInfo* _tmp23_ = NULL;
			GdkPixbuf* _tmp25_ = NULL;
			GtkIconInfo* _tmp26_ = NULL;
			GdkPixbuf* _tmp27_ = NULL;
			GdkPixbuf* _tmp28_ = NULL;
			_tmp3_ = self->priv->_match;
			_tmp4_ = synapse_match_get_match_type (_tmp3_);
			_tmp5_ = _tmp4_;
			if (_tmp5_ == SYNAPSE_MATCH_TYPE_CONTACT) {
				SynapseMatch* _tmp6_ = NULL;
				gboolean _tmp7_ = FALSE;
				gboolean _tmp8_ = FALSE;
				_tmp6_ = self->priv->_match;
				_tmp7_ = synapse_match_get_has_thumbnail (_tmp6_);
				_tmp8_ = _tmp7_;
				_tmp2_ = _tmp8_;
			} else {
				_tmp2_ = FALSE;
			}
			if (_tmp2_) {
				GdkPixbuf* _tmp9_ = NULL;
				SynapseMatch* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				gint _tmp13_ = 0;
				gint _tmp14_ = 0;
				GdkPixbuf* _tmp15_ = NULL;
				GdkPixbuf* _tmp16_ = NULL;
				_tmp10_ = self->priv->_match;
				_tmp11_ = synapse_match_get_thumbnail_path (_tmp10_);
				_tmp12_ = _tmp11_;
				_tmp13_ = _data1_->size;
				_tmp14_ = _data1_->size;
				_tmp15_ = gdk_pixbuf_new_from_file_at_scale (_tmp12_, _tmp13_, _tmp14_, TRUE, &_inner_error_);
				_tmp9_ = _tmp15_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch0_g_error;
				}
				_tmp16_ = _tmp9_;
				_tmp9_ = NULL;
				result = _tmp16_;
				_g_object_unref0 (_tmp9_);
				block1_data_unref (_data1_);
				_data1_ = NULL;
				return result;
			}
			_tmp17_ = self->priv->_icon_name;
			_tmp18_ = g_icon_new_for_string (_tmp17_, &_inner_error_);
			icon = _tmp18_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch0_g_error;
			}
			_tmp19_ = gtk_icon_theme_get_default ();
			_tmp20_ = icon;
			_tmp21_ = _data1_->size;
			_tmp22_ = gtk_icon_theme_lookup_by_gicon (_tmp19_, _tmp20_, _tmp21_, GTK_ICON_LOOKUP_FORCE_SIZE);
			info = _tmp22_;
			_tmp23_ = info;
			if (_tmp23_ == NULL) {
				GError* _tmp24_ = NULL;
				_tmp24_ = g_error_new_literal (ICON_ERROR, ICON_ERROR_NOT_FOUND, "Not found");
				_inner_error_ = _tmp24_;
				_gtk_icon_info_free0 (info);
				_g_object_unref0 (icon);
				goto __catch0_g_error;
			}
			_tmp26_ = info;
			_tmp27_ = gtk_icon_info_load_icon (_tmp26_, &_inner_error_);
			_tmp25_ = _tmp27_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_gtk_icon_info_free0 (info);
				_g_object_unref0 (icon);
				goto __catch0_g_error;
			}
			_tmp28_ = _tmp25_;
			_tmp25_ = NULL;
			result = _tmp28_;
			_g_object_unref0 (_tmp25_);
			_gtk_icon_info_free0 (info);
			_g_object_unref0 (icon);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return result;
		}
		goto __finally0;
		__catch0_g_error:
		{
			GError* e = NULL;
			GError* _tmp29_ = NULL;
			const gchar* _tmp30_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp29_ = e;
			_tmp30_ = _tmp29_->message;
			g_warning ("App.vala:185: Failed to load icon: %s\n", _tmp30_);
			_g_error_free0 (e);
		}
		__finally0:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			block1_data_unref (_data1_);
			_data1_ = NULL;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		{
			GdkPixbuf* _tmp31_ = NULL;
			GtkIconTheme* _tmp32_ = NULL;
			GtkIconTheme* _tmp33_ = NULL;
			gint _tmp34_ = 0;
			GdkPixbuf* _tmp35_ = NULL;
			GdkPixbuf* _tmp36_ = NULL;
			_tmp32_ = panther_panther_get_icon_theme ();
			_tmp33_ = _tmp32_;
			_tmp34_ = _data1_->size;
			_tmp35_ = gtk_icon_theme_load_icon (_tmp33_, "application-default-icon", _tmp34_, GTK_ICON_LOOKUP_FORCE_SIZE, &_inner_error_);
			_tmp31_ = _tmp35_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch1_g_error;
			}
			_tmp36_ = _tmp31_;
			_tmp31_ = NULL;
			result = _tmp36_;
			_g_object_unref0 (_tmp31_);
			block1_data_unref (_data1_);
			_data1_ = NULL;
			return result;
		}
		goto __finally1;
		__catch1_g_error:
		{
			GError* e = NULL;
			GError* _tmp37_ = NULL;
			const gchar* _tmp38_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp37_ = e;
			_tmp38_ = _tmp37_->message;
			g_critical ("App.vala:192: %s", _tmp38_);
			_g_error_free0 (e);
		}
		__finally1:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			block1_data_unref (_data1_);
			_data1_ = NULL;
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_data1_->icon = NULL;
	_data1_->flags = GTK_ICON_LOOKUP_FORCE_SIZE;
	_tmp39_ = self->priv->loadable_icon;
	if (_tmp39_ != NULL) {
		GdkPixbuf* _tmp40_ = NULL;
		_tmp40_ = panther_backend_app_get_loadable_icon (self);
		result = _tmp40_;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	}
	_tmp41_ = panther_backend_app_icon_load_fallback_method_new (___lambda31__panther_backend_app_icon_load_fallback, _data1_);
	_tmp42_ = panther_backend_app_icon_load_fallback_method_new (___lambda32__panther_backend_app_icon_load_fallback, self);
	_tmp43_ = panther_backend_app_icon_load_fallback_method_new (___lambda34__panther_backend_app_icon_load_fallback, _data1_);
	_tmp44_ = panther_backend_app_icon_load_fallback_method_new (___lambda35__panther_backend_app_icon_load_fallback, _data1_);
	_tmp45_ = panther_backend_app_icon_load_fallback_method_new (___lambda36__panther_backend_app_icon_load_fallback, _data1_);
	_tmp46_ = panther_backend_app_icon_load_fallback_method_new (___lambda37__panther_backend_app_icon_load_fallback, _data1_);
	_tmp47_ = g_new0 (PantherBackendAppIconLoadFallbackMethod*, 6 + 1);
	_tmp47_[0] = _tmp41_;
	_tmp47_[1] = _tmp42_;
	_tmp47_[2] = _tmp43_;
	_tmp47_[3] = _tmp44_;
	_tmp47_[4] = _tmp45_;
	_tmp47_[5] = _tmp46_;
	fallbacks = _tmp47_;
	fallbacks_length1 = 6;
	_fallbacks_size_ = fallbacks_length1;
	_tmp48_ = fallbacks;
	_tmp48__length1 = fallbacks_length1;
	{
		PantherBackendAppIconLoadFallbackMethod** fallback_collection = NULL;
		gint fallback_collection_length1 = 0;
		gint _fallback_collection_size_ = 0;
		gint fallback_it = 0;
		fallback_collection = _tmp48_;
		fallback_collection_length1 = _tmp48__length1;
		for (fallback_it = 0; fallback_it < _tmp48__length1; fallback_it = fallback_it + 1) {
			PantherBackendAppIconLoadFallbackMethod* _tmp49_ = NULL;
			PantherBackendAppIconLoadFallbackMethod* fallback = NULL;
			_tmp49_ = _panther_backend_app_icon_load_fallback_method_ref0 (fallback_collection[fallback_it]);
			fallback = _tmp49_;
			{
				PantherBackendAppIconLoadFallbackMethod* _tmp50_ = NULL;
				PantherBackendAppIconLoadFallback _tmp51_ = NULL;
				void* _tmp51__target = NULL;
				GdkPixbuf* _tmp52_ = NULL;
				_tmp50_ = fallback;
				_tmp51_ = _tmp50_->load_icon;
				_tmp51__target = _tmp50_->load_icon_target;
				_tmp51_ (_tmp51__target);
				_tmp52_ = _data1_->icon;
				if (_tmp52_ != NULL) {
					_panther_backend_app_icon_load_fallback_method_unref0 (fallback);
					break;
				}
				_panther_backend_app_icon_load_fallback_method_unref0 (fallback);
			}
		}
	}
	_tmp53_ = _data1_->icon;
	_tmp54_ = _g_object_ref0 (_tmp53_);
	result = _tmp54_;
	fallbacks = (_vala_array_free (fallbacks, fallbacks_length1, (GDestroyNotify) panther_backend_app_icon_load_fallback_method_unref), NULL);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


GdkPixbuf* panther_backend_app_get_loadable_icon (PantherBackendApp* self) {
	GdkPixbuf* result = NULL;
	GdkPixbuf* tmp_loadable_icon = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	{
		GInputStream* icon_stream = NULL;
		GLoadableIcon* _tmp0_ = NULL;
		GInputStream* _tmp1_ = NULL;
		GdkPixbuf* _tmp2_ = NULL;
		GInputStream* _tmp3_ = NULL;
		PantherSettings* _tmp4_ = NULL;
		PantherSettings* _tmp5_ = NULL;
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		PantherSettings* _tmp8_ = NULL;
		PantherSettings* _tmp9_ = NULL;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		GdkPixbuf* _tmp12_ = NULL;
		GdkPixbuf* _tmp13_ = NULL;
		_tmp0_ = self->priv->loadable_icon;
		_tmp1_ = g_loadable_icon_load (_tmp0_, 0, NULL, NULL, &_inner_error_);
		icon_stream = _tmp1_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch7_g_error;
		}
		_tmp3_ = icon_stream;
		_tmp4_ = panther_panther_get_settings ();
		_tmp5_ = _tmp4_;
		_tmp6_ = panther_settings_get_icon_size (_tmp5_);
		_tmp7_ = _tmp6_;
		_tmp8_ = panther_panther_get_settings ();
		_tmp9_ = _tmp8_;
		_tmp10_ = panther_settings_get_icon_size (_tmp9_);
		_tmp11_ = _tmp10_;
		_tmp12_ = gdk_pixbuf_new_from_stream_at_scale (_tmp3_, _tmp7_, _tmp11_, TRUE, NULL, &_inner_error_);
		_tmp2_ = _tmp12_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (icon_stream);
			goto __catch7_g_error;
		}
		_tmp13_ = _tmp2_;
		_tmp2_ = NULL;
		_g_object_unref0 (tmp_loadable_icon);
		tmp_loadable_icon = _tmp13_;
		_g_object_unref0 (_tmp2_);
		_g_object_unref0 (icon_stream);
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_object_unref0 (tmp_loadable_icon);
		tmp_loadable_icon = NULL;
		_g_error_free0 (e);
	}
	__finally7:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (tmp_loadable_icon);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = tmp_loadable_icon;
	return result;
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


gboolean panther_backend_app_launch (PantherBackendApp* self) {
	gboolean result = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		PantherBackendAppAppType _tmp0_ = 0;
		_tmp0_ = self->priv->_app_type;
		switch (_tmp0_) {
			case PANTHER_BACKEND_APP_APP_TYPE_COMMAND:
			{
				const gchar* _tmp1_ = NULL;
				const gchar* _tmp2_ = NULL;
				gchar* _tmp3_ = NULL;
				gchar* _tmp4_ = NULL;
				const gchar* _tmp5_ = NULL;
				_tmp1_ = self->priv->_name;
				_tmp2_ = string_to_string (_tmp1_);
				_tmp3_ = g_strconcat ("Launching command: ", _tmp2_, NULL);
				_tmp4_ = _tmp3_;
				g_debug ("App.vala:285: %s", _tmp4_);
				_g_free0 (_tmp4_);
				_tmp5_ = self->priv->_exec;
				g_spawn_command_line_async (_tmp5_, &_inner_error_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch8_g_error;
				}
				break;
			}
			case PANTHER_BACKEND_APP_APP_TYPE_APP:
			{
				const gchar* _tmp6_ = NULL;
				GDesktopAppInfo* _tmp7_ = NULL;
				GDesktopAppInfo* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				const gchar* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				gchar* _tmp12_ = NULL;
				g_signal_emit_by_name (self, "launched", self);
				_tmp6_ = self->priv->_desktop_id;
				_tmp7_ = g_desktop_app_info_new (_tmp6_);
				_tmp8_ = _tmp7_;
				g_app_info_launch ((GAppInfo*) _tmp8_, NULL, NULL, &_inner_error_);
				_g_object_unref0 (_tmp8_);
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch8_g_error;
				}
				_tmp9_ = self->priv->_name;
				_tmp10_ = string_to_string (_tmp9_);
				_tmp11_ = g_strconcat ("Launching application: ", _tmp10_, NULL);
				_tmp12_ = _tmp11_;
				g_debug ("App.vala:291: %s", _tmp12_);
				_g_free0 (_tmp12_);
				break;
			}
			case PANTHER_BACKEND_APP_APP_TYPE_SYNAPSE:
			{
				SynapseMatch* _tmp13_ = NULL;
				SynapseMatchType _tmp14_ = 0;
				SynapseMatchType _tmp15_ = 0;
				_tmp13_ = self->priv->_match;
				_tmp14_ = synapse_match_get_match_type (_tmp13_);
				_tmp15_ = _tmp14_;
				if (_tmp15_ == SYNAPSE_MATCH_TYPE_SEARCH) {
					SynapseMatch* _tmp16_ = NULL;
					SynapseMatch* _tmp17_ = NULL;
					_tmp16_ = self->priv->_match;
					_tmp17_ = self->priv->_target;
					g_signal_emit_by_name (self, "start-search", G_TYPE_CHECK_INSTANCE_TYPE (_tmp16_, SYNAPSE_TYPE_SEARCH_MATCH) ? ((SynapseSearchMatch*) _tmp16_) : NULL, _tmp17_);
					result = FALSE;
					return result;
				} else {
					SynapseMatch* _tmp18_ = NULL;
					_tmp18_ = self->priv->_target;
					if (_tmp18_ == NULL) {
						SynapseMatch* _tmp19_ = NULL;
						GeeList* _tmp20_ = NULL;
						GeeList* _tmp21_ = NULL;
						gpointer _tmp22_ = NULL;
						SynapseMatch* _tmp23_ = NULL;
						SynapseMatch* _tmp24_ = NULL;
						_tmp19_ = self->priv->_match;
						_tmp20_ = panther_backend_synapse_search_find_actions_for_match (_tmp19_);
						_tmp21_ = _tmp20_;
						_tmp22_ = gee_list_get (_tmp21_, 0);
						_tmp23_ = (SynapseMatch*) _tmp22_;
						_tmp24_ = self->priv->_match;
						synapse_match_execute_with_target (_tmp23_, _tmp24_, NULL);
						_g_object_unref0 (_tmp23_);
						_g_object_unref0 (_tmp21_);
					} else {
						SynapseMatch* _tmp25_ = NULL;
						SynapseMatch* _tmp26_ = NULL;
						_tmp25_ = self->priv->_match;
						_tmp26_ = self->priv->_target;
						synapse_match_execute_with_target (_tmp25_, _tmp26_, NULL);
					}
				}
				break;
			}
			default:
			break;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp27_ = NULL;
		const gchar* _tmp28_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp27_ = self->priv->_name;
		_tmp28_ = self->priv->_exec;
		g_warning ("App.vala:306: Failed to launch %s: %s", _tmp27_, _tmp28_);
		_g_error_free0 (e);
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return FALSE;
	}
	result = TRUE;
	return result;
}


void panther_backend_app_init_actions (PantherBackendApp* self, GError** error) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	GeeHashMap* _tmp3_ = NULL;
	GKeyFile* file = NULL;
	gchar* textdomain = NULL;
	gboolean _tmp19_ = FALSE;
	GeeArrayList* _tmp20_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL);
	_tmp1_ = _tmp0_;
	panther_backend_app_set_actions (self, _tmp1_);
	_g_object_unref0 (_tmp1_);
	_tmp2_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_tmp3_ = _tmp2_;
	panther_backend_app_set_actions_map (self, _tmp3_);
	_g_object_unref0 (_tmp3_);
	{
		GKeyFile* _tmp4_ = NULL;
		GKeyFile* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		_tmp4_ = g_key_file_new ();
		_g_key_file_free0 (file);
		file = _tmp4_;
		_tmp5_ = file;
		_tmp6_ = self->priv->_desktop_path;
		g_key_file_load_from_file (_tmp5_, _tmp6_, 0, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch9_g_error;
		}
	}
	goto __finally9;
	__catch9_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp7_ = NULL;
		GError* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp7_ = self->priv->_desktop_path;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		g_critical ("App.vala:324: %s: %s", _tmp7_, _tmp9_);
		_g_error_free0 (e);
	}
	__finally9:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		if (_inner_error_->domain == G_KEY_FILE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_key_file_free0 (file);
			return;
		} else {
			_g_key_file_free0 (file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	textdomain = NULL;
	{
		const gchar** domain_key_collection = NULL;
		gint domain_key_collection_length1 = 0;
		gint _domain_key_collection_size_ = 0;
		gint domain_key_it = 0;
		domain_key_collection = PANTHER_BACKEND_APP_SUPPORTED_GETTEXT_DOMAINS_KEYS;
		domain_key_collection_length1 = G_N_ELEMENTS (PANTHER_BACKEND_APP_SUPPORTED_GETTEXT_DOMAINS_KEYS);
		for (domain_key_it = 0; domain_key_it < G_N_ELEMENTS (PANTHER_BACKEND_APP_SUPPORTED_GETTEXT_DOMAINS_KEYS); domain_key_it = domain_key_it + 1) {
			const gchar* domain_key = NULL;
			domain_key = domain_key_collection[domain_key_it];
			{
				gboolean _tmp10_ = FALSE;
				GKeyFile* _tmp11_ = NULL;
				const gchar* _tmp12_ = NULL;
				gboolean _tmp13_ = FALSE;
				_tmp11_ = file;
				_tmp12_ = domain_key;
				_tmp13_ = g_key_file_has_key (_tmp11_, G_KEY_FILE_DESKTOP_GROUP, _tmp12_, &_inner_error_);
				_tmp10_ = _tmp13_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					if (_inner_error_->domain == G_KEY_FILE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (textdomain);
						_g_key_file_free0 (file);
						return;
					} else {
						_g_free0 (textdomain);
						_g_key_file_free0 (file);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				if (_tmp10_) {
					gchar* _tmp14_ = NULL;
					GKeyFile* _tmp15_ = NULL;
					const gchar* _tmp16_ = NULL;
					gchar* _tmp17_ = NULL;
					gchar* _tmp18_ = NULL;
					_tmp15_ = file;
					_tmp16_ = domain_key;
					_tmp17_ = g_key_file_get_string (_tmp15_, G_KEY_FILE_DESKTOP_GROUP, _tmp16_, &_inner_error_);
					_tmp14_ = _tmp17_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (textdomain);
							_g_key_file_free0 (file);
							return;
						} else {
							_g_free0 (textdomain);
							_g_key_file_free0 (file);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					_tmp18_ = _tmp14_;
					_tmp14_ = NULL;
					_g_free0 (textdomain);
					textdomain = _tmp18_;
					_g_free0 (_tmp14_);
					break;
				}
			}
		}
	}
	_tmp20_ = self->priv->_actions;
	if (_tmp20_ != NULL) {
		GeeHashMap* _tmp21_ = NULL;
		_tmp21_ = self->priv->_actions_map;
		_tmp19_ = _tmp21_ != NULL;
	} else {
		_tmp19_ = FALSE;
	}
	if (_tmp19_) {
		GeeArrayList* _tmp22_ = NULL;
		GeeHashMap* _tmp23_ = NULL;
		gchar** keys = NULL;
		gchar* _tmp24_ = NULL;
		gchar** _tmp25_ = NULL;
		gint keys_length1 = 0;
		gint _keys_size_ = 0;
		gchar** _tmp26_ = NULL;
		gint _tmp26__length1 = 0;
		_tmp22_ = self->priv->_actions;
		gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp22_);
		_tmp23_ = self->priv->_actions_map;
		gee_abstract_map_clear ((GeeAbstractMap*) _tmp23_);
		_tmp24_ = g_strdup (PANTHER_BACKEND_APP_DESKTOP_ACTION_KEY);
		_tmp25_ = g_new0 (gchar*, 1 + 1);
		_tmp25_[0] = _tmp24_;
		keys = _tmp25_;
		keys_length1 = 1;
		_keys_size_ = keys_length1;
		_tmp26_ = keys;
		_tmp26__length1 = keys_length1;
		{
			gchar** key_collection = NULL;
			gint key_collection_length1 = 0;
			gint _key_collection_size_ = 0;
			gint key_it = 0;
			key_collection = _tmp26_;
			key_collection_length1 = _tmp26__length1;
			for (key_it = 0; key_it < _tmp26__length1; key_it = key_it + 1) {
				gchar* _tmp27_ = NULL;
				gchar* key = NULL;
				_tmp27_ = g_strdup (key_collection[key_it]);
				key = _tmp27_;
				{
					gboolean _tmp28_ = FALSE;
					GKeyFile* _tmp29_ = NULL;
					const gchar* _tmp30_ = NULL;
					gboolean _tmp31_ = FALSE;
					gchar** _tmp32_ = NULL;
					GKeyFile* _tmp33_ = NULL;
					const gchar* _tmp34_ = NULL;
					gsize _tmp35_;
					gchar** _tmp36_ = NULL;
					gint _tmp32__length1 = 0;
					gint __tmp32__size_ = 0;
					gchar** _tmp37_ = NULL;
					gint _tmp37__length1 = 0;
					_tmp29_ = file;
					_tmp30_ = key;
					_tmp31_ = g_key_file_has_key (_tmp29_, G_KEY_FILE_DESKTOP_GROUP, _tmp30_, &_inner_error_);
					_tmp28_ = _tmp31_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (key);
							keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
							_g_free0 (textdomain);
							_g_key_file_free0 (file);
							return;
						} else {
							_g_free0 (key);
							keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
							_g_free0 (textdomain);
							_g_key_file_free0 (file);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					if (!_tmp28_) {
						_g_free0 (key);
						continue;
					}
					_tmp33_ = file;
					_tmp34_ = key;
					_tmp36_ = g_key_file_get_string_list (_tmp33_, G_KEY_FILE_DESKTOP_GROUP, _tmp34_, &_tmp35_, &_inner_error_);
					_tmp32_ = _tmp36_;
					_tmp32__length1 = _tmp35_;
					__tmp32__size_ = _tmp32__length1;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						if (_inner_error_->domain == G_KEY_FILE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_g_free0 (key);
							keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
							_g_free0 (textdomain);
							_g_key_file_free0 (file);
							return;
						} else {
							_g_free0 (key);
							keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
							_g_free0 (textdomain);
							_g_key_file_free0 (file);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					_tmp37_ = _tmp32_;
					_tmp37__length1 = _tmp32__length1;
					_tmp32_ = NULL;
					_tmp32__length1 = 0;
					{
						gchar** action_collection = NULL;
						gint action_collection_length1 = 0;
						gint _action_collection_size_ = 0;
						gint action_it = 0;
						action_collection = _tmp37_;
						action_collection_length1 = _tmp37__length1;
						for (action_it = 0; action_it < _tmp37__length1; action_it = action_it + 1) {
							gchar* _tmp38_ = NULL;
							gchar* action = NULL;
							_tmp38_ = g_strdup (action_collection[action_it]);
							action = _tmp38_;
							{
								gchar* group = NULL;
								const gchar* _tmp39_ = NULL;
								gchar* _tmp40_ = NULL;
								GKeyFile* _tmp41_ = NULL;
								const gchar* _tmp42_ = NULL;
								gboolean _tmp43_ = FALSE;
								gboolean _tmp44_ = FALSE;
								GKeyFile* _tmp45_ = NULL;
								const gchar* _tmp46_ = NULL;
								gboolean _tmp47_ = FALSE;
								gchar* action_name = NULL;
								GKeyFile* _tmp48_ = NULL;
								const gchar* _tmp49_ = NULL;
								gchar* _tmp50_ = NULL;
								gchar* action_icon = NULL;
								gchar* _tmp51_ = NULL;
								gboolean _tmp52_ = FALSE;
								GKeyFile* _tmp53_ = NULL;
								const gchar* _tmp54_ = NULL;
								gboolean _tmp55_ = FALSE;
								gchar* action_exec = NULL;
								gchar* _tmp61_ = NULL;
								gboolean _tmp62_ = FALSE;
								GKeyFile* _tmp63_ = NULL;
								const gchar* _tmp64_ = NULL;
								gboolean _tmp65_ = FALSE;
								const gchar* _tmp71_ = NULL;
								GeeArrayList* _tmp76_ = NULL;
								const gchar* _tmp77_ = NULL;
								GeeHashMap* _tmp78_ = NULL;
								const gchar* _tmp79_ = NULL;
								const gchar* _tmp80_ = NULL;
								const gchar* _tmp81_ = NULL;
								gchar* _tmp82_ = NULL;
								gchar* _tmp83_ = NULL;
								_tmp39_ = action;
								_tmp40_ = g_strdup_printf (PANTHER_BACKEND_APP_DESKTOP_ACTION_GROUP_NAME, _tmp39_);
								group = _tmp40_;
								_tmp41_ = file;
								_tmp42_ = group;
								_tmp43_ = g_key_file_has_group (_tmp41_, _tmp42_);
								if (!_tmp43_) {
									_g_free0 (group);
									_g_free0 (action);
									continue;
								}
								_tmp45_ = file;
								_tmp46_ = group;
								_tmp47_ = g_key_file_has_key (_tmp45_, _tmp46_, G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN, &_inner_error_);
								_tmp44_ = _tmp47_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										return;
									} else {
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return;
									}
								}
								if (_tmp44_) {
									_g_free0 (group);
									_g_free0 (action);
									continue;
								}
								_tmp48_ = file;
								_tmp49_ = group;
								_tmp50_ = g_key_file_get_locale_string (_tmp48_, _tmp49_, G_KEY_FILE_DESKTOP_KEY_NAME, NULL, &_inner_error_);
								action_name = _tmp50_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										return;
									} else {
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return;
									}
								}
								_tmp51_ = g_strdup ("");
								action_icon = _tmp51_;
								_tmp53_ = file;
								_tmp54_ = group;
								_tmp55_ = g_key_file_has_key (_tmp53_, _tmp54_, G_KEY_FILE_DESKTOP_KEY_ICON, &_inner_error_);
								_tmp52_ = _tmp55_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_g_free0 (action_icon);
										_g_free0 (action_name);
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										return;
									} else {
										_g_free0 (action_icon);
										_g_free0 (action_name);
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return;
									}
								}
								if (_tmp52_) {
									gchar* _tmp56_ = NULL;
									GKeyFile* _tmp57_ = NULL;
									const gchar* _tmp58_ = NULL;
									gchar* _tmp59_ = NULL;
									gchar* _tmp60_ = NULL;
									_tmp57_ = file;
									_tmp58_ = group;
									_tmp59_ = g_key_file_get_locale_string (_tmp57_, _tmp58_, G_KEY_FILE_DESKTOP_KEY_ICON, NULL, &_inner_error_);
									_tmp56_ = _tmp59_;
									if (G_UNLIKELY (_inner_error_ != NULL)) {
										if (_inner_error_->domain == G_KEY_FILE_ERROR) {
											g_propagate_error (error, _inner_error_);
											_g_free0 (action_icon);
											_g_free0 (action_name);
											_g_free0 (group);
											_g_free0 (action);
											action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
											_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (key);
											keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (textdomain);
											_g_key_file_free0 (file);
											return;
										} else {
											_g_free0 (action_icon);
											_g_free0 (action_name);
											_g_free0 (group);
											_g_free0 (action);
											action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
											_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (key);
											keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (textdomain);
											_g_key_file_free0 (file);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return;
										}
									}
									_tmp60_ = _tmp56_;
									_tmp56_ = NULL;
									_g_free0 (action_icon);
									action_icon = _tmp60_;
									_g_free0 (_tmp56_);
								}
								_tmp61_ = g_strdup ("");
								action_exec = _tmp61_;
								_tmp63_ = file;
								_tmp64_ = group;
								_tmp65_ = g_key_file_has_key (_tmp63_, _tmp64_, G_KEY_FILE_DESKTOP_KEY_EXEC, &_inner_error_);
								_tmp62_ = _tmp65_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									if (_inner_error_->domain == G_KEY_FILE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_g_free0 (action_exec);
										_g_free0 (action_icon);
										_g_free0 (action_name);
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										return;
									} else {
										_g_free0 (action_exec);
										_g_free0 (action_icon);
										_g_free0 (action_name);
										_g_free0 (group);
										_g_free0 (action);
										action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
										_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (key);
										keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
										_g_free0 (textdomain);
										_g_key_file_free0 (file);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return;
									}
								}
								if (_tmp62_) {
									gchar* _tmp66_ = NULL;
									GKeyFile* _tmp67_ = NULL;
									const gchar* _tmp68_ = NULL;
									gchar* _tmp69_ = NULL;
									gchar* _tmp70_ = NULL;
									_tmp67_ = file;
									_tmp68_ = group;
									_tmp69_ = g_key_file_get_string (_tmp67_, _tmp68_, G_KEY_FILE_DESKTOP_KEY_EXEC, &_inner_error_);
									_tmp66_ = _tmp69_;
									if (G_UNLIKELY (_inner_error_ != NULL)) {
										if (_inner_error_->domain == G_KEY_FILE_ERROR) {
											g_propagate_error (error, _inner_error_);
											_g_free0 (action_exec);
											_g_free0 (action_icon);
											_g_free0 (action_name);
											_g_free0 (group);
											_g_free0 (action);
											action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
											_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (key);
											keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (textdomain);
											_g_key_file_free0 (file);
											return;
										} else {
											_g_free0 (action_exec);
											_g_free0 (action_icon);
											_g_free0 (action_name);
											_g_free0 (group);
											_g_free0 (action);
											action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
											_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (key);
											keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
											_g_free0 (textdomain);
											_g_key_file_free0 (file);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return;
										}
									}
									_tmp70_ = _tmp66_;
									_tmp66_ = NULL;
									_g_free0 (action_exec);
									action_exec = _tmp70_;
									_g_free0 (_tmp66_);
								}
								_tmp71_ = textdomain;
								if (_tmp71_ != NULL) {
									const gchar* _tmp72_ = NULL;
									const gchar* _tmp73_ = NULL;
									const gchar* _tmp74_ = NULL;
									gchar* _tmp75_ = NULL;
									_tmp72_ = textdomain;
									_tmp73_ = action_name;
									_tmp74_ = g_dgettext (_tmp72_, _tmp73_);
									_tmp75_ = g_strdup (_tmp74_);
									_g_free0 (action_name);
									action_name = _tmp75_;
								}
								_tmp76_ = self->priv->_actions;
								_tmp77_ = action_name;
								gee_abstract_collection_add ((GeeAbstractCollection*) _tmp76_, _tmp77_);
								_tmp78_ = self->priv->_actions_map;
								_tmp79_ = action_name;
								_tmp80_ = action_exec;
								_tmp81_ = action_icon;
								_tmp82_ = g_strdup_printf ("%s;;%s", _tmp80_, _tmp81_);
								_tmp83_ = _tmp82_;
								gee_abstract_map_set ((GeeAbstractMap*) _tmp78_, _tmp79_, _tmp83_);
								_g_free0 (_tmp83_);
								_g_free0 (action_exec);
								_g_free0 (action_icon);
								_g_free0 (action_name);
								_g_free0 (group);
								_g_free0 (action);
							}
						}
						action_collection = (_vala_array_free (action_collection, action_collection_length1, (GDestroyNotify) g_free), NULL);
					}
					_tmp32_ = (_vala_array_free (_tmp32_, _tmp32__length1, (GDestroyNotify) g_free), NULL);
					_g_free0 (key);
				}
			}
		}
		keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
	}
	_g_free0 (textdomain);
	_g_key_file_free0 (file);
}


const gchar* panther_backend_app_get_name (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}


void panther_backend_app_set_name (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp1_;
	g_object_notify ((GObject *) self, "name");
}


const gchar* panther_backend_app_get_description (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_description;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_description (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_description);
	self->priv->_description = _tmp1_;
	g_object_notify ((GObject *) self, "description");
}


const gchar* panther_backend_app_get_desktop_id (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_desktop_id;
	result = _tmp0_;
	return result;
}


void panther_backend_app_set_desktop_id (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_desktop_id);
	self->priv->_desktop_id = _tmp1_;
	g_object_notify ((GObject *) self, "desktop-id");
}


const gchar* panther_backend_app_get_exec (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_exec;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_exec (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_exec);
	self->priv->_exec = _tmp1_;
	g_object_notify ((GObject *) self, "exec");
}


const gchar* panther_backend_app_get_icon_name (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_icon_name;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_icon_name (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_icon_name);
	self->priv->_icon_name = _tmp1_;
	g_object_notify ((GObject *) self, "icon-name");
}


gchar** panther_backend_app_get_keywords (PantherBackendApp* self, int* result_length1) {
	gchar** result;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_keywords;
	_tmp0__length1 = self->priv->_keywords_length1;
	_tmp1_ = _tmp0_;
	_tmp1__length1 = _tmp0__length1;
	if (result_length1) {
		*result_length1 = _tmp1__length1;
	}
	result = _tmp1_;
	return result;
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void panther_backend_app_set_keywords (PantherBackendApp* self, gchar** value, int value_length1) {
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	gchar** _tmp1_ = NULL;
	gint _tmp1__length1 = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp0__length1 = value_length1;
	_tmp1_ = (_tmp0_ != NULL) ? _vala_array_dup1 (_tmp0_, _tmp0__length1) : ((gpointer) _tmp0_);
	_tmp1__length1 = _tmp0__length1;
	self->priv->_keywords = (_vala_array_free (self->priv->_keywords, self->priv->_keywords_length1, (GDestroyNotify) g_free), NULL);
	self->priv->_keywords = _tmp1_;
	self->priv->_keywords_length1 = _tmp1__length1;
	self->priv->__keywords_size_ = self->priv->_keywords_length1;
	g_object_notify ((GObject *) self, "keywords");
}


GdkPixbuf* panther_backend_app_get_icon (PantherBackendApp* self) {
	GdkPixbuf* result;
	GdkPixbuf* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_icon;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_icon (PantherBackendApp* self, GdkPixbuf* value) {
	GdkPixbuf* _tmp0_ = NULL;
	GdkPixbuf* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_icon);
	self->priv->_icon = _tmp1_;
	g_object_notify ((GObject *) self, "icon");
}


gdouble panther_backend_app_get_popularity (PantherBackendApp* self) {
	gdouble result;
	gdouble _tmp0_ = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = self->priv->_popularity;
	result = _tmp0_;
	return result;
}


void panther_backend_app_set_popularity (PantherBackendApp* self, gdouble value) {
	gdouble _tmp0_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_popularity = _tmp0_;
	g_object_notify ((GObject *) self, "popularity");
}


gdouble panther_backend_app_get_relevancy (PantherBackendApp* self) {
	gdouble result;
	gdouble _tmp0_ = 0.0;
	g_return_val_if_fail (self != NULL, 0.0);
	_tmp0_ = self->priv->_relevancy;
	result = _tmp0_;
	return result;
}


void panther_backend_app_set_relevancy (PantherBackendApp* self, gdouble value) {
	gdouble _tmp0_ = 0.0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_relevancy = _tmp0_;
	g_object_notify ((GObject *) self, "relevancy");
}


const gchar* panther_backend_app_get_desktop_path (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_desktop_path;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_desktop_path (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_desktop_path);
	self->priv->_desktop_path = _tmp1_;
	g_object_notify ((GObject *) self, "desktop-path");
}


const gchar* panther_backend_app_get_categories (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_categories;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_categories (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_categories);
	self->priv->_categories = _tmp1_;
	g_object_notify ((GObject *) self, "categories");
}


const gchar* panther_backend_app_get_generic_name (PantherBackendApp* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_generic_name;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_generic_name (PantherBackendApp* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_generic_name);
	self->priv->_generic_name = _tmp1_;
	g_object_notify ((GObject *) self, "generic-name");
}


PantherBackendAppAppType panther_backend_app_get_app_type (PantherBackendApp* self) {
	PantherBackendAppAppType result;
	PantherBackendAppAppType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_app_type;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_app_type (PantherBackendApp* self, PantherBackendAppAppType value) {
	PantherBackendAppAppType _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_app_type = _tmp0_;
	g_object_notify ((GObject *) self, "app-type");
}


SynapseMatch* panther_backend_app_get_match (PantherBackendApp* self) {
	SynapseMatch* result;
	SynapseMatch* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_match;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_match (PantherBackendApp* self, SynapseMatch* value) {
	SynapseMatch* _tmp0_ = NULL;
	SynapseMatch* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_match);
	self->priv->_match = _tmp1_;
	g_object_notify ((GObject *) self, "match");
}


SynapseMatch* panther_backend_app_get_target (PantherBackendApp* self) {
	SynapseMatch* result;
	SynapseMatch* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_target;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_target (PantherBackendApp* self, SynapseMatch* value) {
	SynapseMatch* _tmp0_ = NULL;
	SynapseMatch* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_target);
	self->priv->_target = _tmp1_;
	g_object_notify ((GObject *) self, "target");
}


GeeArrayList* panther_backend_app_get_actions (PantherBackendApp* self) {
	GeeArrayList* result;
	GeeArrayList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_actions;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_actions (PantherBackendApp* self, GeeArrayList* value) {
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_actions);
	self->priv->_actions = _tmp1_;
	g_object_notify ((GObject *) self, "actions");
}


GeeHashMap* panther_backend_app_get_actions_map (PantherBackendApp* self) {
	GeeHashMap* result;
	GeeHashMap* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_actions_map;
	result = _tmp0_;
	return result;
}


static void panther_backend_app_set_actions_map (PantherBackendApp* self, GeeHashMap* value) {
	GeeHashMap* _tmp0_ = NULL;
	GeeHashMap* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_actions_map);
	self->priv->_actions_map = _tmp1_;
	g_object_notify ((GObject *) self, "actions-map");
}


static void g_cclosure_user_marshal_VOID__OBJECT_OBJECT (GClosure * closure, GValue * return_value, guint n_param_values, const GValue * param_values, gpointer invocation_hint, gpointer marshal_data) {
	typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT) (gpointer data1, gpointer arg_1, gpointer arg_2, gpointer data2);
	register GMarshalFunc_VOID__OBJECT_OBJECT callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 3);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__OBJECT_OBJECT) (marshal_data ? marshal_data : cc->callback);
	callback (data1, g_value_get_object (param_values + 1), g_value_get_object (param_values + 2), data2);
}


static PantherBackendAppIconLoadFallbackMethod* panther_backend_app_icon_load_fallback_method_construct (GType object_type, PantherBackendAppIconLoadFallback fallback, void* fallback_target) {
	PantherBackendAppIconLoadFallbackMethod* self = NULL;
	PantherBackendAppIconLoadFallback _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	self = (PantherBackendAppIconLoadFallbackMethod*) g_type_create_instance (object_type);
	_tmp0_ = fallback;
	_tmp0__target = fallback_target;
	self->load_icon = _tmp0_;
	self->load_icon_target = _tmp0__target;
	return self;
}


static PantherBackendAppIconLoadFallbackMethod* panther_backend_app_icon_load_fallback_method_new (PantherBackendAppIconLoadFallback fallback, void* fallback_target) {
	return panther_backend_app_icon_load_fallback_method_construct (PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD, fallback, fallback_target);
}


static void panther_backend_app_value_icon_load_fallback_method_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void panther_backend_app_value_icon_load_fallback_method_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		panther_backend_app_icon_load_fallback_method_unref (value->data[0].v_pointer);
	}
}


static void panther_backend_app_value_icon_load_fallback_method_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = panther_backend_app_icon_load_fallback_method_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer panther_backend_app_value_icon_load_fallback_method_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* panther_backend_app_value_icon_load_fallback_method_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		PantherBackendAppIconLoadFallbackMethod* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = panther_backend_app_icon_load_fallback_method_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* panther_backend_app_value_icon_load_fallback_method_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	PantherBackendAppIconLoadFallbackMethod** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = panther_backend_app_icon_load_fallback_method_ref (value->data[0].v_pointer);
	}
	return NULL;
}


static GParamSpec* panther_backend_app_param_spec_icon_load_fallback_method (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	PantherBackendAppParamSpecIconLoadFallbackMethod* spec;
	g_return_val_if_fail (g_type_is_a (object_type, PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


static gpointer panther_backend_app_value_get_icon_load_fallback_method (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD), NULL);
	return value->data[0].v_pointer;
}


static void panther_backend_app_value_set_icon_load_fallback_method (GValue* value, gpointer v_object) {
	PantherBackendAppIconLoadFallbackMethod* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		panther_backend_app_icon_load_fallback_method_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panther_backend_app_icon_load_fallback_method_unref (old);
	}
}


static void panther_backend_app_value_take_icon_load_fallback_method (GValue* value, gpointer v_object) {
	PantherBackendAppIconLoadFallbackMethod* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		panther_backend_app_icon_load_fallback_method_unref (old);
	}
}


static void panther_backend_app_icon_load_fallback_method_class_init (PantherBackendAppIconLoadFallbackMethodClass * klass) {
	panther_backend_app_icon_load_fallback_method_parent_class = g_type_class_peek_parent (klass);
	((PantherBackendAppIconLoadFallbackMethodClass *) klass)->finalize = panther_backend_app_icon_load_fallback_method_finalize;
}


static void panther_backend_app_icon_load_fallback_method_instance_init (PantherBackendAppIconLoadFallbackMethod * self) {
	self->ref_count = 1;
}


static void panther_backend_app_icon_load_fallback_method_finalize (PantherBackendAppIconLoadFallbackMethod* obj) {
	PantherBackendAppIconLoadFallbackMethod * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PANTHER_BACKEND_APP_TYPE_ICON_LOAD_FALLBACK_METHOD, PantherBackendAppIconLoadFallbackMethod);
	g_signal_handlers_destroy (self);
}


static GType panther_backend_app_icon_load_fallback_method_get_type (void) {
	static volatile gsize panther_backend_app_icon_load_fallback_method_type_id__volatile = 0;
	if (g_once_init_enter (&panther_backend_app_icon_load_fallback_method_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { panther_backend_app_value_icon_load_fallback_method_init, panther_backend_app_value_icon_load_fallback_method_free_value, panther_backend_app_value_icon_load_fallback_method_copy_value, panther_backend_app_value_icon_load_fallback_method_peek_pointer, "p", panther_backend_app_value_icon_load_fallback_method_collect_value, "p", panther_backend_app_value_icon_load_fallback_method_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (PantherBackendAppIconLoadFallbackMethodClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panther_backend_app_icon_load_fallback_method_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PantherBackendAppIconLoadFallbackMethod), 0, (GInstanceInitFunc) panther_backend_app_icon_load_fallback_method_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType panther_backend_app_icon_load_fallback_method_type_id;
		panther_backend_app_icon_load_fallback_method_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PantherBackendAppIconLoadFallbackMethod", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&panther_backend_app_icon_load_fallback_method_type_id__volatile, panther_backend_app_icon_load_fallback_method_type_id);
	}
	return panther_backend_app_icon_load_fallback_method_type_id__volatile;
}


static gpointer panther_backend_app_icon_load_fallback_method_ref (gpointer instance) {
	PantherBackendAppIconLoadFallbackMethod* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


static void panther_backend_app_icon_load_fallback_method_unref (gpointer instance) {
	PantherBackendAppIconLoadFallbackMethod* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PANTHER_BACKEND_APP_ICON_LOAD_FALLBACK_METHOD_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void panther_backend_app_class_init (PantherBackendAppClass * klass) {
	panther_backend_app_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PantherBackendAppPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_panther_backend_app_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_panther_backend_app_set_property;
	G_OBJECT_CLASS (klass)->finalize = panther_backend_app_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_DESCRIPTION, g_param_spec_string ("description", "description", "description", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_DESKTOP_ID, g_param_spec_string ("desktop-id", "desktop-id", "desktop-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_EXEC, g_param_spec_string ("exec", "exec", "exec", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_ICON_NAME, g_param_spec_string ("icon-name", "icon-name", "icon-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_KEYWORDS, g_param_spec_boxed ("keywords", "keywords", "keywords", G_TYPE_STRV, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_ICON, g_param_spec_object ("icon", "icon", "icon", GDK_TYPE_PIXBUF, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_POPULARITY, g_param_spec_double ("popularity", "popularity", "popularity", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_RELEVANCY, g_param_spec_double ("relevancy", "relevancy", "relevancy", -G_MAXDOUBLE, G_MAXDOUBLE, 0.0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_DESKTOP_PATH, g_param_spec_string ("desktop-path", "desktop-path", "desktop-path", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_CATEGORIES, g_param_spec_string ("categories", "categories", "categories", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_GENERIC_NAME, g_param_spec_string ("generic-name", "generic-name", "generic-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_APP_TYPE, g_param_spec_enum ("app-type", "app-type", "app-type", PANTHER_BACKEND_APP_TYPE_APP_TYPE, PANTHER_BACKEND_APP_APP_TYPE_APP, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_MATCH, g_param_spec_object ("match", "match", "match", SYNAPSE_TYPE_MATCH, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_TARGET, g_param_spec_object ("target", "target", "target", SYNAPSE_TYPE_MATCH, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_ACTIONS, g_param_spec_object ("actions", "actions", "actions", GEE_TYPE_ARRAY_LIST, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), PANTHER_BACKEND_APP_ACTIONS_MAP, g_param_spec_object ("actions-map", "actions-map", "actions-map", GEE_TYPE_HASH_MAP, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("start_search", PANTHER_BACKEND_TYPE_APP, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__OBJECT_OBJECT, G_TYPE_NONE, 2, SYNAPSE_TYPE_SEARCH_MATCH, SYNAPSE_TYPE_MATCH);
	g_signal_new ("icon_changed", PANTHER_BACKEND_TYPE_APP, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("launched", PANTHER_BACKEND_TYPE_APP, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, PANTHER_BACKEND_TYPE_APP);
}


static void panther_backend_app_instance_init (PantherBackendApp * self) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	self->priv = PANTHER_BACKEND_APP_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("");
	self->priv->_description = _tmp0_;
	_tmp1_ = g_strdup ("");
	self->priv->_icon_name = _tmp1_;
	self->priv->_icon = NULL;
	_tmp2_ = g_strdup ("");
	self->priv->_generic_name = _tmp2_;
	self->priv->_app_type = PANTHER_BACKEND_APP_APP_TYPE_APP;
	self->priv->_match = NULL;
	self->priv->_target = NULL;
	self->priv->_actions = NULL;
	self->priv->_actions_map = NULL;
	self->priv->check_icon_again = TRUE;
	self->priv->firstres = 0;
	self->priv->secondres = 0;
	self->priv->res = 0;
	self->priv->loadable_icon = NULL;
}


static void panther_backend_app_finalize (GObject* obj) {
	PantherBackendApp * self;
	GtkIconTheme* _tmp0_ = NULL;
	GtkIconTheme* _tmp1_ = NULL;
	guint _tmp2_ = 0U;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PANTHER_BACKEND_TYPE_APP, PantherBackendApp);
	_tmp0_ = panther_panther_get_icon_theme ();
	_tmp1_ = _tmp0_;
	g_signal_parse_name ("changed", gtk_icon_theme_get_type (), &_tmp2_, NULL, FALSE);
	g_signal_handlers_disconnect_matched (_tmp1_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _panther_backend_app_update_icon_gtk_icon_theme_changed, self);
	_g_free0 (self->priv->_name);
	_g_free0 (self->priv->_description);
	_g_free0 (self->priv->_desktop_id);
	_g_free0 (self->priv->_exec);
	_g_free0 (self->priv->_icon_name);
	self->priv->_keywords = (_vala_array_free (self->priv->_keywords, self->priv->_keywords_length1, (GDestroyNotify) g_free), NULL);
	_g_object_unref0 (self->priv->_icon);
	_g_free0 (self->priv->_desktop_path);
	_g_free0 (self->priv->_categories);
	_g_free0 (self->priv->_generic_name);
	_g_object_unref0 (self->priv->_match);
	_g_object_unref0 (self->priv->_target);
	_g_object_unref0 (self->priv->_actions);
	_g_object_unref0 (self->priv->_actions_map);
	_g_object_unref0 (self->priv->loadable_icon);
	G_OBJECT_CLASS (panther_backend_app_parent_class)->finalize (obj);
}


GType panther_backend_app_get_type (void) {
	static volatile gsize panther_backend_app_type_id__volatile = 0;
	if (g_once_init_enter (&panther_backend_app_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PantherBackendAppClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panther_backend_app_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PantherBackendApp), 0, (GInstanceInitFunc) panther_backend_app_instance_init, NULL };
		GType panther_backend_app_type_id;
		panther_backend_app_type_id = g_type_register_static (G_TYPE_OBJECT, "PantherBackendApp", &g_define_type_info, 0);
		g_once_init_leave (&panther_backend_app_type_id__volatile, panther_backend_app_type_id);
	}
	return panther_backend_app_type_id__volatile;
}


static void _vala_panther_backend_app_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	PantherBackendApp * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PANTHER_BACKEND_TYPE_APP, PantherBackendApp);
	switch (property_id) {
		case PANTHER_BACKEND_APP_NAME:
		g_value_set_string (value, panther_backend_app_get_name (self));
		break;
		case PANTHER_BACKEND_APP_DESCRIPTION:
		g_value_set_string (value, panther_backend_app_get_description (self));
		break;
		case PANTHER_BACKEND_APP_DESKTOP_ID:
		g_value_set_string (value, panther_backend_app_get_desktop_id (self));
		break;
		case PANTHER_BACKEND_APP_EXEC:
		g_value_set_string (value, panther_backend_app_get_exec (self));
		break;
		case PANTHER_BACKEND_APP_ICON_NAME:
		g_value_set_string (value, panther_backend_app_get_icon_name (self));
		break;
		case PANTHER_BACKEND_APP_KEYWORDS:
		{
			int length;
			g_value_set_boxed (value, panther_backend_app_get_keywords (self, &length));
		}
		break;
		case PANTHER_BACKEND_APP_ICON:
		g_value_set_object (value, panther_backend_app_get_icon (self));
		break;
		case PANTHER_BACKEND_APP_POPULARITY:
		g_value_set_double (value, panther_backend_app_get_popularity (self));
		break;
		case PANTHER_BACKEND_APP_RELEVANCY:
		g_value_set_double (value, panther_backend_app_get_relevancy (self));
		break;
		case PANTHER_BACKEND_APP_DESKTOP_PATH:
		g_value_set_string (value, panther_backend_app_get_desktop_path (self));
		break;
		case PANTHER_BACKEND_APP_CATEGORIES:
		g_value_set_string (value, panther_backend_app_get_categories (self));
		break;
		case PANTHER_BACKEND_APP_GENERIC_NAME:
		g_value_set_string (value, panther_backend_app_get_generic_name (self));
		break;
		case PANTHER_BACKEND_APP_APP_TYPE:
		g_value_set_enum (value, panther_backend_app_get_app_type (self));
		break;
		case PANTHER_BACKEND_APP_MATCH:
		g_value_set_object (value, panther_backend_app_get_match (self));
		break;
		case PANTHER_BACKEND_APP_TARGET:
		g_value_set_object (value, panther_backend_app_get_target (self));
		break;
		case PANTHER_BACKEND_APP_ACTIONS:
		g_value_set_object (value, panther_backend_app_get_actions (self));
		break;
		case PANTHER_BACKEND_APP_ACTIONS_MAP:
		g_value_set_object (value, panther_backend_app_get_actions_map (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_panther_backend_app_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	PantherBackendApp * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PANTHER_BACKEND_TYPE_APP, PantherBackendApp);
	switch (property_id) {
		case PANTHER_BACKEND_APP_NAME:
		panther_backend_app_set_name (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_DESCRIPTION:
		panther_backend_app_set_description (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_DESKTOP_ID:
		panther_backend_app_set_desktop_id (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_EXEC:
		panther_backend_app_set_exec (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_ICON_NAME:
		panther_backend_app_set_icon_name (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_KEYWORDS:
		{
			gpointer boxed;
			boxed = g_value_get_boxed (value);
			panther_backend_app_set_keywords (self, boxed, (boxed == NULL) ? 0 : g_strv_length (boxed));
		}
		break;
		case PANTHER_BACKEND_APP_ICON:
		panther_backend_app_set_icon (self, g_value_get_object (value));
		break;
		case PANTHER_BACKEND_APP_POPULARITY:
		panther_backend_app_set_popularity (self, g_value_get_double (value));
		break;
		case PANTHER_BACKEND_APP_RELEVANCY:
		panther_backend_app_set_relevancy (self, g_value_get_double (value));
		break;
		case PANTHER_BACKEND_APP_DESKTOP_PATH:
		panther_backend_app_set_desktop_path (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_CATEGORIES:
		panther_backend_app_set_categories (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_GENERIC_NAME:
		panther_backend_app_set_generic_name (self, g_value_get_string (value));
		break;
		case PANTHER_BACKEND_APP_APP_TYPE:
		panther_backend_app_set_app_type (self, g_value_get_enum (value));
		break;
		case PANTHER_BACKEND_APP_MATCH:
		panther_backend_app_set_match (self, g_value_get_object (value));
		break;
		case PANTHER_BACKEND_APP_TARGET:
		panther_backend_app_set_target (self, g_value_get_object (value));
		break;
		case PANTHER_BACKEND_APP_ACTIONS:
		panther_backend_app_set_actions (self, g_value_get_object (value));
		break;
		case PANTHER_BACKEND_APP_ACTIONS_MAP:
		panther_backend_app_set_actions_map (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



