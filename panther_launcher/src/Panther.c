/* Panther.c generated by valac 0.30.1, the Vala compiler
 * generated from Panther.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/
/**/
/*  Copyright (C) 2011-2012 Giulio Collura*/
/*  Copyright (C) 2015 Raster Software Vigo*/
/*  This program is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  This program is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <cairo.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>
#include <gio/gio.h>
#include <stdio.h>


#define PANTHER_TYPE_PANTHER (panther_panther_get_type ())
#define PANTHER_PANTHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANTHER_TYPE_PANTHER, PantherPanther))
#define PANTHER_PANTHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANTHER_TYPE_PANTHER, PantherPantherClass))
#define PANTHER_IS_PANTHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANTHER_TYPE_PANTHER))
#define PANTHER_IS_PANTHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANTHER_TYPE_PANTHER))
#define PANTHER_PANTHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANTHER_TYPE_PANTHER, PantherPantherClass))

typedef struct _PantherPanther PantherPanther;
typedef struct _PantherPantherClass PantherPantherClass;
typedef struct _PantherPantherPrivate PantherPantherPrivate;

#define PANTHER_TYPE_PANTHER_VIEW (panther_panther_view_get_type ())
#define PANTHER_PANTHER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANTHER_TYPE_PANTHER_VIEW, PantherPantherView))
#define PANTHER_PANTHER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANTHER_TYPE_PANTHER_VIEW, PantherPantherViewClass))
#define PANTHER_IS_PANTHER_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANTHER_TYPE_PANTHER_VIEW))
#define PANTHER_IS_PANTHER_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANTHER_TYPE_PANTHER_VIEW))
#define PANTHER_PANTHER_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANTHER_TYPE_PANTHER_VIEW, PantherPantherViewClass))

typedef struct _PantherPantherView PantherPantherView;
typedef struct _PantherPantherViewClass PantherPantherViewClass;

#define PANTHER_TYPE_DBUS_SERVICE (panther_dbus_service_get_type ())
#define PANTHER_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANTHER_TYPE_DBUS_SERVICE, PantherDBusService))
#define PANTHER_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANTHER_TYPE_DBUS_SERVICE, PantherDBusServiceClass))
#define PANTHER_IS_DBUS_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANTHER_TYPE_DBUS_SERVICE))
#define PANTHER_IS_DBUS_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANTHER_TYPE_DBUS_SERVICE))
#define PANTHER_DBUS_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANTHER_TYPE_DBUS_SERVICE, PantherDBusServiceClass))

typedef struct _PantherDBusService PantherDBusService;
typedef struct _PantherDBusServiceClass PantherDBusServiceClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define PANTHER_TYPE_SETTINGS (panther_settings_get_type ())
#define PANTHER_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PANTHER_TYPE_SETTINGS, PantherSettings))
#define PANTHER_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PANTHER_TYPE_SETTINGS, PantherSettingsClass))
#define PANTHER_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PANTHER_TYPE_SETTINGS))
#define PANTHER_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PANTHER_TYPE_SETTINGS))
#define PANTHER_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PANTHER_TYPE_SETTINGS, PantherSettingsClass))

typedef struct _PantherSettings PantherSettings;
typedef struct _PantherSettingsClass PantherSettingsClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_option_context_free0(var) ((var == NULL) ? NULL : (var = (g_option_context_free (var), NULL)))

#define TYPE_REMOTE_CONTROL (remote_control_get_type ())
#define REMOTE_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_REMOTE_CONTROL, RemoteControl))
#define REMOTE_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_REMOTE_CONTROL, RemoteControlClass))
#define IS_REMOTE_CONTROL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_REMOTE_CONTROL))
#define IS_REMOTE_CONTROL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_REMOTE_CONTROL))
#define REMOTE_CONTROL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_REMOTE_CONTROL, RemoteControlClass))

typedef struct _RemoteControl RemoteControl;
typedef struct _RemoteControlClass RemoteControlClass;
typedef struct _RemoteControlPrivate RemoteControlPrivate;

struct _PantherPanther {
	GtkApplication parent_instance;
	PantherPantherPrivate * priv;
	PantherPantherView* view;
	gboolean launched;
};

struct _PantherPantherClass {
	GtkApplicationClass parent_class;
};

struct _PantherPantherPrivate {
	PantherDBusService* dbus_service;
	gint view_width;
	gint view_height;
};

struct _RemoteControl {
	GObject parent_instance;
	RemoteControlPrivate * priv;
};

struct _RemoteControlClass {
	GObjectClass parent_class;
};


extern PantherPanther* app;
PantherPanther* app = NULL;
static gpointer panther_panther_parent_class = NULL;
extern gboolean panther_panther_silent;
gboolean panther_panther_silent = FALSE;
extern gboolean panther_panther_command_mode;
gboolean panther_panther_command_mode = FALSE;
static PantherSettings* panther_panther__settings;
static PantherSettings* panther_panther__settings = NULL;
static GtkIconTheme* panther_panther__icon_theme;
static GtkIconTheme* panther_panther__icon_theme = NULL;
extern gint panther_pixels_ITEM_SIZE;
extern gint panther_pixels_SIDEBAR_WIDTH;
static gpointer remote_control_parent_class = NULL;

GType panther_panther_get_type (void) G_GNUC_CONST;
GType panther_panther_view_get_type (void) G_GNUC_CONST;
GType panther_dbus_service_get_type (void) G_GNUC_CONST;
#define PANTHER_PANTHER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), PANTHER_TYPE_PANTHER, PantherPantherPrivate))
enum  {
	PANTHER_PANTHER_DUMMY_PROPERTY
};
GType panther_settings_get_type (void) G_GNUC_CONST;
PantherPanther* panther_panther_new (void);
PantherPanther* panther_panther_construct (GType object_type);
PantherSettings* panther_panther_get_settings (void);
PantherSettings* panther_settings_new (void);
PantherSettings* panther_settings_construct (GType object_type);
static void panther_panther_set_settings (PantherSettings* value);
gint panther_settings_get_icon_size (PantherSettings* self);
#define PANTHER_PIXELS_PADDING 25
#define PANTHER_PIXELS_SIDEBAR_GRID_PADDING 5
static gboolean panther_panther_realize_view (PantherPanther* self, cairo_t* cr);
void panther_panther_view_reposition (PantherPantherView* self);
static void panther_panther_real_activate (GApplication* base);
PantherPantherView* panther_panther_view_new (void);
PantherPantherView* panther_panther_view_construct (GType object_type);
static gboolean _panther_panther_realize_view_gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self);
PantherDBusService* panther_dbus_service_new (PantherPantherView* view);
PantherDBusService* panther_dbus_service_construct (GType object_type, PantherPantherView* view);
void panther_panther_view_show_panther (PantherPantherView* self);
gint panther_panther_main (gchar** args, int args_length1);
#define CONSTANTS_GETTEXT_PACKAGE "panther_launcher"
#define CONSTANTS_DATADIR "/usr/local/share"
void on_bus_aquired (GDBusConnection* conn);
static void _on_bus_aquired_gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void __lambda69_ (void);
static void ___lambda69__gbus_name_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self);
static void __lambda70_ (void);
static void ___lambda70__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self);
GtkIconTheme* panther_panther_get_icon_theme (void);
void panther_panther_set_icon_theme (GtkIconTheme* value);
static GObject * panther_panther_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void panther_panther_finalize (GObject* obj);
static void _vala_panther_panther_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_panther_panther_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
RemoteControl* remote_control_new (void);
RemoteControl* remote_control_construct (GType object_type);
GType remote_control_get_type (void) G_GNUC_CONST;
guint remote_control_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
enum  {
	REMOTE_CONTROL_DUMMY_PROPERTY
};
gint remote_control_do_ping (RemoteControl* self, gint v);
void remote_control_do_show (RemoteControl* self);
static void _dbus_remote_control_do_ping (RemoteControl* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void _dbus_remote_control_do_show (RemoteControl* self, GVariant* _parameters_, GDBusMethodInvocation* invocation);
static void remote_control_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* remote_control_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static gboolean remote_control_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _remote_control_unregister_object (gpointer user_data);

static const GOptionEntry PANTHER_PANTHER_entries[3] = {{"silent", 's', 0, G_OPTION_ARG_NONE, &panther_panther_silent, "Launch Panther as a background process without it appearing visually.", NULL}, {"command-mode", 'c', 0, G_OPTION_ARG_NONE, &panther_panther_command_mode, "This feature is not implemented yet. When it is, description will be c" \
"hanged.", NULL}, {NULL}};
static const GDBusArgInfo _remote_control_dbus_arg_info_do_ping_v = {-1, "v", "i"};
static const GDBusArgInfo _remote_control_dbus_arg_info_do_ping_result = {-1, "result", "i"};
static const GDBusArgInfo * const _remote_control_dbus_arg_info_do_ping_in[] = {&_remote_control_dbus_arg_info_do_ping_v, NULL};
static const GDBusArgInfo * const _remote_control_dbus_arg_info_do_ping_out[] = {&_remote_control_dbus_arg_info_do_ping_result, NULL};
static const GDBusMethodInfo _remote_control_dbus_method_info_do_ping = {-1, "DoPing", (GDBusArgInfo **) (&_remote_control_dbus_arg_info_do_ping_in), (GDBusArgInfo **) (&_remote_control_dbus_arg_info_do_ping_out)};
static const GDBusArgInfo * const _remote_control_dbus_arg_info_do_show_in[] = {NULL};
static const GDBusArgInfo * const _remote_control_dbus_arg_info_do_show_out[] = {NULL};
static const GDBusMethodInfo _remote_control_dbus_method_info_do_show = {-1, "DoShow", (GDBusArgInfo **) (&_remote_control_dbus_arg_info_do_show_in), (GDBusArgInfo **) (&_remote_control_dbus_arg_info_do_show_out)};
static const GDBusMethodInfo * const _remote_control_dbus_method_info[] = {&_remote_control_dbus_method_info_do_ping, &_remote_control_dbus_method_info_do_show, NULL};
static const GDBusSignalInfo * const _remote_control_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo * const _remote_control_dbus_property_info[] = {NULL};
static const GDBusInterfaceInfo _remote_control_dbus_interface_info = {-1, "com.rastersoft.panther.remotecontrol", (GDBusMethodInfo **) (&_remote_control_dbus_method_info), (GDBusSignalInfo **) (&_remote_control_dbus_signal_info), (GDBusPropertyInfo **) (&_remote_control_dbus_property_info)};
static const GDBusInterfaceVTable _remote_control_dbus_interface_vtable = {remote_control_dbus_interface_method_call, remote_control_dbus_interface_get_property, remote_control_dbus_interface_set_property};

PantherPanther* panther_panther_construct (GType object_type) {
	PantherPanther * self = NULL;
	PantherSettings* _tmp0_ = NULL;
	PantherSettings* _tmp1_ = NULL;
	PantherSettings* _tmp2_ = NULL;
	PantherSettings* _tmp3_ = NULL;
	PantherSettings* _tmp4_ = NULL;
	PantherSettings* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	self = (PantherPanther*) g_object_new (object_type, NULL);
	_tmp0_ = panther_panther_get_settings ();
	_tmp1_ = _tmp0_;
	_tmp2_ = panther_settings_new ();
	_tmp3_ = _tmp2_;
	panther_panther_set_settings (_tmp3_);
	_g_object_unref0 (_tmp3_);
	_tmp4_ = panther_panther_get_settings ();
	_tmp5_ = _tmp4_;
	_tmp6_ = panther_settings_get_icon_size (_tmp5_);
	_tmp7_ = _tmp6_;
	panther_pixels_ITEM_SIZE = _tmp7_ * 2;
	_tmp8_ = panther_pixels_ITEM_SIZE;
	panther_pixels_SIDEBAR_WIDTH = ((PANTHER_PIXELS_PADDING + _tmp8_) - PANTHER_PIXELS_SIDEBAR_GRID_PADDING) - 1;
	return self;
}


PantherPanther* panther_panther_new (void) {
	return panther_panther_construct (PANTHER_TYPE_PANTHER);
}


static gboolean panther_panther_realize_view (PantherPanther* self, cairo_t* cr) {
	gboolean result = FALSE;
	GtkAllocation alloc = {0};
	PantherPantherView* _tmp0_ = NULL;
	GtkAllocation _tmp1_ = {0};
	gboolean _tmp2_ = FALSE;
	GtkAllocation _tmp3_ = {0};
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->view;
	gtk_widget_get_allocation ((GtkWidget*) _tmp0_, &_tmp1_);
	alloc = _tmp1_;
	_tmp3_ = alloc;
	_tmp4_ = _tmp3_.width;
	_tmp5_ = self->priv->view_width;
	if (_tmp4_ != _tmp5_) {
		_tmp2_ = TRUE;
	} else {
		GtkAllocation _tmp6_ = {0};
		gint _tmp7_ = 0;
		gint _tmp8_ = 0;
		_tmp6_ = alloc;
		_tmp7_ = _tmp6_.height;
		_tmp8_ = self->priv->view_height;
		_tmp2_ = _tmp7_ != _tmp8_;
	}
	if (_tmp2_) {
		GtkAllocation _tmp9_ = {0};
		gint _tmp10_ = 0;
		GtkAllocation _tmp11_ = {0};
		gint _tmp12_ = 0;
		PantherPantherView* _tmp13_ = NULL;
		_tmp9_ = alloc;
		_tmp10_ = _tmp9_.width;
		self->priv->view_width = _tmp10_;
		_tmp11_ = alloc;
		_tmp12_ = _tmp11_.height;
		self->priv->view_height = _tmp12_;
		_tmp13_ = self->view;
		panther_panther_view_reposition (_tmp13_);
	}
	result = FALSE;
	return result;
}


static gboolean _panther_panther_realize_view_gtk_widget_draw (GtkWidget* _sender, cairo_t* cr, gpointer self) {
	gboolean result;
	result = panther_panther_realize_view ((PantherPanther*) self, cr);
	return result;
}


static void panther_panther_real_activate (GApplication* base) {
	PantherPanther * self;
	GList* _tmp0_ = NULL;
	self = (PantherPanther*) base;
	_tmp0_ = gtk_application_get_windows ((GtkApplication*) self);
	if (_tmp0_ == NULL) {
		PantherPantherView* _tmp1_ = NULL;
		PantherPantherView* _tmp2_ = NULL;
		PantherPantherView* _tmp3_ = NULL;
		PantherDBusService* _tmp4_ = NULL;
		gboolean _tmp7_ = FALSE;
		self->priv->view_width = -1;
		self->priv->view_height = -1;
		_tmp1_ = panther_panther_view_new ();
		g_object_ref_sink (_tmp1_);
		_g_object_unref0 (self->view);
		self->view = _tmp1_;
		_tmp2_ = self->view;
		gtk_window_set_application ((GtkWindow*) _tmp2_, (GtkApplication*) self);
		_tmp3_ = self->view;
		g_signal_connect_object ((GtkWidget*) _tmp3_, "draw", (GCallback) _panther_panther_realize_view_gtk_widget_draw, self, G_CONNECT_AFTER);
		_tmp4_ = self->priv->dbus_service;
		if (_tmp4_ == NULL) {
			PantherPantherView* _tmp5_ = NULL;
			PantherDBusService* _tmp6_ = NULL;
			_tmp5_ = self->view;
			_tmp6_ = panther_dbus_service_new (_tmp5_);
			_g_object_unref0 (self->priv->dbus_service);
			self->priv->dbus_service = _tmp6_;
		}
		_tmp7_ = panther_panther_silent;
		if (!_tmp7_) {
			PantherPantherView* _tmp8_ = NULL;
			_tmp8_ = self->view;
			panther_panther_view_show_panther (_tmp8_);
		}
	} else {
		gboolean _tmp9_ = FALSE;
		PantherPantherView* _tmp10_ = NULL;
		gboolean _tmp11_ = FALSE;
		gboolean _tmp12_ = FALSE;
		_tmp10_ = self->view;
		_tmp11_ = gtk_widget_get_visible ((GtkWidget*) _tmp10_);
		_tmp12_ = _tmp11_;
		if (_tmp12_) {
			gboolean _tmp13_ = FALSE;
			_tmp13_ = panther_panther_silent;
			_tmp9_ = !_tmp13_;
		} else {
			_tmp9_ = FALSE;
		}
		if (_tmp9_) {
			PantherPantherView* _tmp14_ = NULL;
			_tmp14_ = self->view;
			gtk_widget_hide ((GtkWidget*) _tmp14_);
		} else {
			PantherPantherView* _tmp15_ = NULL;
			_tmp15_ = self->view;
			panther_panther_view_show_panther (_tmp15_);
		}
	}
	panther_panther_silent = FALSE;
}


static void _on_bus_aquired_gbus_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	on_bus_aquired (connection);
}


static void __lambda69_ (void) {
}


static void ___lambda69__gbus_name_acquired_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	__lambda69_ ();
}


static void __lambda70_ (void) {
}


static void ___lambda70__gbus_name_lost_callback (GDBusConnection* connection, const gchar* name, gpointer self) {
	__lambda70_ ();
}


gint panther_panther_main (gchar** args, int args_length1) {
	gint result = 0;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	PantherPanther* _tmp12_ = NULL;
	PantherPanther* _tmp13_ = NULL;
	gchar** _tmp14_ = NULL;
	gint _tmp14__length1 = 0;
	gint _tmp15_ = 0;
	GError * _inner_error_ = NULL;
	_tmp0_ = g_build_filename (CONSTANTS_DATADIR, "locale", NULL);
	_tmp1_ = _tmp0_;
	bindtextdomain (CONSTANTS_GETTEXT_PACKAGE, _tmp1_);
	_g_free0 (_tmp1_);
	textdomain (CONSTANTS_GETTEXT_PACKAGE);
	bind_textdomain_codeset (CONSTANTS_GETTEXT_PACKAGE, "UTF-8");
	_tmp2_ = args;
	_tmp2__length1 = args_length1;
	if (_tmp2__length1 > 1) {
		GOptionContext* context = NULL;
		GOptionContext* _tmp3_ = NULL;
		GOptionContext* _tmp4_ = NULL;
		GOptionContext* _tmp5_ = NULL;
		GOptionGroup* _tmp6_ = NULL;
		_tmp3_ = g_option_context_new ("");
		context = _tmp3_;
		_tmp4_ = context;
		g_option_context_add_main_entries (_tmp4_, PANTHER_PANTHER_entries, "panther");
		_tmp5_ = context;
		_tmp6_ = gtk_get_option_group (TRUE);
		g_option_context_add_group (_tmp5_, _tmp6_);
		{
			GOptionContext* _tmp7_ = NULL;
			_tmp7_ = context;
			g_option_context_parse (_tmp7_, &args_length1, &args, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				goto __catch14_g_error;
			}
		}
		goto __finally14;
		__catch14_g_error:
		{
			GError* e = NULL;
			GError* _tmp8_ = NULL;
			const gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_ = NULL;
			e = _inner_error_;
			_inner_error_ = NULL;
			_tmp8_ = e;
			_tmp9_ = _tmp8_->message;
			_tmp10_ = g_strconcat (_tmp9_, "\n", NULL);
			_tmp11_ = _tmp10_;
			g_print ("%s", _tmp11_);
			_g_free0 (_tmp11_);
			_g_error_free0 (e);
		}
		__finally14:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_option_context_free0 (context);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return 0;
		}
		_g_option_context_free0 (context);
	}
	_tmp12_ = panther_panther_new ();
	_g_object_unref0 (app);
	app = _tmp12_;
	g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, "com.rastersoft.panther.remotecontrol", G_BUS_NAME_OWNER_FLAGS_NONE, (GClosure*) ((_on_bus_aquired_gbus_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) _on_bus_aquired_gbus_acquired_callback, NULL, NULL)), (GClosure*) ((___lambda69__gbus_name_acquired_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda69__gbus_name_acquired_callback, NULL, NULL)), (GClosure*) ((___lambda70__gbus_name_lost_callback == NULL) ? NULL : g_cclosure_new ((GCallback) ___lambda70__gbus_name_lost_callback, NULL, NULL)));
	_tmp13_ = app;
	_tmp14_ = args;
	_tmp14__length1 = args_length1;
	_tmp15_ = g_application_run ((GApplication*) _tmp13_, _tmp14__length1, _tmp14_);
	result = _tmp15_;
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return panther_panther_main (argv, argc);
}


PantherSettings* panther_panther_get_settings (void) {
	PantherSettings* result;
	PantherSettings* _tmp0_ = NULL;
	_tmp0_ = panther_panther__settings;
	result = _tmp0_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void panther_panther_set_settings (PantherSettings* value) {
	PantherSettings* _tmp0_ = NULL;
	PantherSettings* _tmp1_ = NULL;
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (panther_panther__settings);
	panther_panther__settings = _tmp1_;
}


GtkIconTheme* panther_panther_get_icon_theme (void) {
	GtkIconTheme* result;
	GtkIconTheme* _tmp0_ = NULL;
	_tmp0_ = panther_panther__icon_theme;
	result = _tmp0_;
	return result;
}


void panther_panther_set_icon_theme (GtkIconTheme* value) {
	GtkIconTheme* _tmp0_ = NULL;
	GtkIconTheme* _tmp1_ = NULL;
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (panther_panther__icon_theme);
	panther_panther__icon_theme = _tmp1_;
}


static GObject * panther_panther_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	PantherPanther * self;
	parent_class = G_OBJECT_CLASS (panther_panther_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PANTHER_TYPE_PANTHER, PantherPanther);
	g_application_set_application_id ((GApplication*) self, "com.rastersoft.panther");
	return obj;
}


static void panther_panther_class_init (PantherPantherClass * klass) {
	panther_panther_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PantherPantherPrivate));
	((GApplicationClass *) klass)->activate = panther_panther_real_activate;
	G_OBJECT_CLASS (klass)->get_property = _vala_panther_panther_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_panther_panther_set_property;
	G_OBJECT_CLASS (klass)->constructor = panther_panther_constructor;
	G_OBJECT_CLASS (klass)->finalize = panther_panther_finalize;
}


static void panther_panther_instance_init (PantherPanther * self) {
	self->priv = PANTHER_PANTHER_GET_PRIVATE (self);
	self->view = NULL;
	self->launched = FALSE;
	self->priv->dbus_service = NULL;
}


static void panther_panther_finalize (GObject* obj) {
	PantherPanther * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PANTHER_TYPE_PANTHER, PantherPanther);
	_g_object_unref0 (self->view);
	_g_object_unref0 (self->priv->dbus_service);
	G_OBJECT_CLASS (panther_panther_parent_class)->finalize (obj);
}


GType panther_panther_get_type (void) {
	static volatile gsize panther_panther_type_id__volatile = 0;
	if (g_once_init_enter (&panther_panther_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PantherPantherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) panther_panther_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PantherPanther), 0, (GInstanceInitFunc) panther_panther_instance_init, NULL };
		GType panther_panther_type_id;
		panther_panther_type_id = g_type_register_static (gtk_application_get_type (), "PantherPanther", &g_define_type_info, 0);
		g_once_init_leave (&panther_panther_type_id__volatile, panther_panther_type_id);
	}
	return panther_panther_type_id__volatile;
}


static void _vala_panther_panther_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	PantherPanther * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PANTHER_TYPE_PANTHER, PantherPanther);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_panther_panther_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	PantherPanther * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PANTHER_TYPE_PANTHER, PantherPanther);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


void on_bus_aquired (GDBusConnection* conn) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (conn != NULL);
	{
		GDBusConnection* _tmp0_ = NULL;
		RemoteControl* _tmp1_ = NULL;
		RemoteControl* _tmp2_ = NULL;
		_tmp0_ = conn;
		_tmp1_ = remote_control_new ();
		_tmp2_ = _tmp1_;
		remote_control_register_object (_tmp2_, _tmp0_, "/com/rastersoft/panther/remotecontrol", &_inner_error_);
		_g_object_unref0 (_tmp2_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_IO_ERROR) {
				goto __catch15_g_io_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally15;
	__catch15_g_io_error:
	{
		GError* e = NULL;
		FILE* _tmp3_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = stderr;
		fprintf (_tmp3_, "Could not register service\n");
		_g_error_free0 (e);
	}
	__finally15:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


gint remote_control_do_ping (RemoteControl* self, gint v) {
	gint result = 0;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = v;
	result = _tmp0_ + 1;
	return result;
}


void remote_control_do_show (RemoteControl* self) {
	PantherPanther* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_print ("Called from DBus\n");
	_tmp0_ = app;
	g_application_activate ((GApplication*) _tmp0_);
}


RemoteControl* remote_control_construct (GType object_type) {
	RemoteControl * self = NULL;
	self = (RemoteControl*) g_object_new (object_type, NULL);
	return self;
}


RemoteControl* remote_control_new (void) {
	return remote_control_construct (TYPE_REMOTE_CONTROL);
}


static void remote_control_class_init (RemoteControlClass * klass) {
	remote_control_parent_class = g_type_class_peek_parent (klass);
}


static void remote_control_instance_init (RemoteControl * self) {
}


GType remote_control_get_type (void) {
	static volatile gsize remote_control_type_id__volatile = 0;
	if (g_once_init_enter (&remote_control_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (RemoteControlClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) remote_control_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (RemoteControl), 0, (GInstanceInitFunc) remote_control_instance_init, NULL };
		GType remote_control_type_id;
		remote_control_type_id = g_type_register_static (G_TYPE_OBJECT, "RemoteControl", &g_define_type_info, 0);
		g_type_set_qdata (remote_control_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) remote_control_register_object);
		g_once_init_leave (&remote_control_type_id__volatile, remote_control_type_id);
	}
	return remote_control_type_id__volatile;
}


static void _dbus_remote_control_do_ping (RemoteControl* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	gint v = 0;
	GVariant* _tmp0_;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	gint result;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	_tmp0_ = g_variant_iter_next_value (&_arguments_iter);
	v = g_variant_get_int32 (_tmp0_);
	g_variant_unref (_tmp0_);
	result = remote_control_do_ping (self, v);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	g_variant_builder_add_value (&_reply_builder, g_variant_new_int32 (result));
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void _dbus_remote_control_do_show (RemoteControl* self, GVariant* _parameters_, GDBusMethodInvocation* invocation) {
	GError* error = NULL;
	GVariantIter _arguments_iter;
	GDBusMessage* _reply_message;
	GVariant* _reply;
	GVariantBuilder _reply_builder;
	g_variant_iter_init (&_arguments_iter, _parameters_);
	remote_control_do_show (self);
	_reply_message = g_dbus_message_new_method_reply (g_dbus_method_invocation_get_message (invocation));
	g_variant_builder_init (&_reply_builder, G_VARIANT_TYPE_TUPLE);
	_reply = g_variant_builder_end (&_reply_builder);
	g_dbus_message_set_body (_reply_message, _reply);
	g_dbus_connection_send_message (g_dbus_method_invocation_get_connection (invocation), _reply_message, G_DBUS_SEND_MESSAGE_FLAGS_NONE, NULL, NULL);
	g_object_unref (invocation);
	g_object_unref (_reply_message);
}


static void remote_control_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (method_name, "DoPing") == 0) {
		_dbus_remote_control_do_ping (object, parameters, invocation);
	} else if (strcmp (method_name, "DoShow") == 0) {
		_dbus_remote_control_do_show (object, parameters, invocation);
	} else {
		g_object_unref (invocation);
	}
}


static GVariant* remote_control_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return NULL;
}


static gboolean remote_control_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint remote_control_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_remote_control_dbus_interface_info), &_remote_control_dbus_interface_vtable, data, _remote_control_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _remote_control_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}



