/* utils.c generated by valac 0.30.1, the Vala compiler
 * generated from utils.vala, do not modify */

/*
 * Copyright (C) 2010 Michal Hruby <michal.mhr@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Michal Hruby <michal.mhr@gmail.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdarg.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _SynapseUtilsQueryExistsAsyncData SynapseUtilsQueryExistsAsyncData;

#define SYNAPSE_UTILS_TYPE_LOGGER (synapse_utils_logger_get_type ())
#define SYNAPSE_UTILS_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_UTILS_TYPE_LOGGER, SynapseUtilsLogger))
#define SYNAPSE_UTILS_LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_UTILS_TYPE_LOGGER, SynapseUtilsLoggerClass))
#define SYNAPSE_UTILS_IS_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_UTILS_TYPE_LOGGER))
#define SYNAPSE_UTILS_IS_LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_UTILS_TYPE_LOGGER))
#define SYNAPSE_UTILS_LOGGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_UTILS_TYPE_LOGGER, SynapseUtilsLoggerClass))

typedef struct _SynapseUtilsLogger SynapseUtilsLogger;
typedef struct _SynapseUtilsLoggerClass SynapseUtilsLoggerClass;
typedef struct _SynapseUtilsLoggerPrivate SynapseUtilsLoggerPrivate;
typedef struct _SynapseUtilsParamSpecLogger SynapseUtilsParamSpecLogger;
typedef struct _SynapseUtilsDelegateWrapper SynapseUtilsDelegateWrapper;

#define SYNAPSE_UTILS_TYPE_ASYNC_ONCE (synapse_utils_async_once_get_type ())
#define SYNAPSE_UTILS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOnce))
#define SYNAPSE_UTILS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOnceClass))
#define SYNAPSE_UTILS_IS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_UTILS_TYPE_ASYNC_ONCE))
#define SYNAPSE_UTILS_IS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_UTILS_TYPE_ASYNC_ONCE))
#define SYNAPSE_UTILS_ASYNC_ONCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOnceClass))

typedef struct _SynapseUtilsAsyncOnce SynapseUtilsAsyncOnce;
typedef struct _SynapseUtilsAsyncOnceClass SynapseUtilsAsyncOnceClass;
typedef struct _SynapseUtilsAsyncOncePrivate SynapseUtilsAsyncOncePrivate;

#define SYNAPSE_UTILS_ASYNC_ONCE_TYPE_OPERATION_STATE (synapse_utils_async_once_operation_state_get_type ())
#define _synapse_utils_async_once_unref0(var) ((var == NULL) ? NULL : (var = (synapse_utils_async_once_unref (var), NULL)))
typedef struct _SynapseUtilsAsyncOnceEnterData SynapseUtilsAsyncOnceEnterData;
typedef struct _SynapseUtilsAsyncOnceWaitAsyncData SynapseUtilsAsyncOnceWaitAsyncData;
typedef struct _SynapseUtilsParamSpecAsyncOnce SynapseUtilsParamSpecAsyncOnce;

#define SYNAPSE_UTILS_TYPE_FILE_INFO (synapse_utils_file_info_get_type ())
#define SYNAPSE_UTILS_FILE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_UTILS_TYPE_FILE_INFO, SynapseUtilsFileInfo))
#define SYNAPSE_UTILS_FILE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_UTILS_TYPE_FILE_INFO, SynapseUtilsFileInfoClass))
#define SYNAPSE_UTILS_IS_FILE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_UTILS_TYPE_FILE_INFO))
#define SYNAPSE_UTILS_IS_FILE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_UTILS_TYPE_FILE_INFO))
#define SYNAPSE_UTILS_FILE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_UTILS_TYPE_FILE_INFO, SynapseUtilsFileInfoClass))

typedef struct _SynapseUtilsFileInfo SynapseUtilsFileInfo;
typedef struct _SynapseUtilsFileInfoClass SynapseUtilsFileInfoClass;
typedef struct _SynapseUtilsFileInfoPrivate SynapseUtilsFileInfoPrivate;

#define SYNAPSE_TYPE_QUERY_FLAGS (synapse_query_flags_get_type ())

#define SYNAPSE_TYPE_MATCH (synapse_match_get_type ())
#define SYNAPSE_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_MATCH, SynapseMatch))
#define SYNAPSE_IS_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_MATCH))
#define SYNAPSE_MATCH_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_MATCH, SynapseMatchIface))

typedef struct _SynapseMatch SynapseMatch;
typedef struct _SynapseMatchIface SynapseMatchIface;

#define SYNAPSE_TYPE_MATCH_TYPE (synapse_match_type_get_type ())

#define SYNAPSE_TYPE_URI_MATCH (synapse_uri_match_get_type ())
#define SYNAPSE_URI_MATCH(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_URI_MATCH, SynapseUriMatch))
#define SYNAPSE_IS_URI_MATCH(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_URI_MATCH))
#define SYNAPSE_URI_MATCH_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), SYNAPSE_TYPE_URI_MATCH, SynapseUriMatchIface))

typedef struct _SynapseUriMatch SynapseUriMatch;
typedef struct _SynapseUriMatchIface SynapseUriMatchIface;
#define _synapse_utils_file_info_unref0(var) ((var == NULL) ? NULL : (var = (synapse_utils_file_info_unref (var), NULL)))
typedef struct _SynapseUtilsFileInfoInitializeData SynapseUtilsFileInfoInitializeData;
typedef struct _SynapseUtilsFileInfoExistsData SynapseUtilsFileInfoExistsData;
typedef struct _SynapseUtilsParamSpecFileInfo SynapseUtilsParamSpecFileInfo;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _SynapseUtilsQueryExistsAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	GFile* f;
	gboolean result;
	gboolean exists;
	GFile* _tmp0_;
	GFileInfo* _tmp1_;
	GFileInfo* _tmp2_;
	GError* err;
	GError * _inner_error_;
};

struct _SynapseUtilsLogger {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SynapseUtilsLoggerPrivate * priv;
};

struct _SynapseUtilsLoggerClass {
	GTypeClass parent_class;
	void (*finalize) (SynapseUtilsLogger *self);
};

struct _SynapseUtilsParamSpecLogger {
	GParamSpec parent_instance;
};

struct _SynapseUtilsDelegateWrapper {
	GSourceFunc callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
};

struct _SynapseUtilsAsyncOnce {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SynapseUtilsAsyncOncePrivate * priv;
};

struct _SynapseUtilsAsyncOnceClass {
	GTypeClass parent_class;
	void (*finalize) (SynapseUtilsAsyncOnce *self);
};

typedef enum  {
	SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED,
	SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS,
	SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE
} SynapseUtilsAsyncOnceOperationState;

struct _SynapseUtilsAsyncOncePrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gpointer inner;
	SynapseUtilsAsyncOnceOperationState state;
	SynapseUtilsDelegateWrapper** callbacks;
	gint callbacks_length1;
	gint _callbacks_size_;
};

struct _SynapseUtilsAsyncOnceEnterData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseUtilsAsyncOnce* self;
	gboolean result;
	SynapseUtilsAsyncOnceOperationState _tmp0_;
	SynapseUtilsAsyncOnceOperationState _tmp1_;
};

struct _SynapseUtilsAsyncOnceWaitAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseUtilsAsyncOnce* self;
	SynapseUtilsDelegateWrapper** _tmp0_;
	gint _tmp0__length1;
	SynapseUtilsDelegateWrapper* _tmp1_;
};

struct _SynapseUtilsParamSpecAsyncOnce {
	GParamSpec parent_instance;
};

typedef enum  {
	SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE = 1 << 0,
	SYNAPSE_QUERY_FLAGS_UNCATEGORIZED = 1 << 1,
	SYNAPSE_QUERY_FLAGS_APPLICATIONS = 1 << 2,
	SYNAPSE_QUERY_FLAGS_ACTIONS = 1 << 3,
	SYNAPSE_QUERY_FLAGS_AUDIO = 1 << 4,
	SYNAPSE_QUERY_FLAGS_VIDEO = 1 << 5,
	SYNAPSE_QUERY_FLAGS_DOCUMENTS = 1 << 6,
	SYNAPSE_QUERY_FLAGS_IMAGES = 1 << 7,
	SYNAPSE_QUERY_FLAGS_FILES = ((SYNAPSE_QUERY_FLAGS_AUDIO | SYNAPSE_QUERY_FLAGS_VIDEO) | SYNAPSE_QUERY_FLAGS_DOCUMENTS) | SYNAPSE_QUERY_FLAGS_IMAGES,
	SYNAPSE_QUERY_FLAGS_PLACES = 1 << 8,
	SYNAPSE_QUERY_FLAGS_INTERNET = 1 << 9,
	SYNAPSE_QUERY_FLAGS_TEXT = 1 << 10,
	SYNAPSE_QUERY_FLAGS_CONTACTS = 1 << 11,
	SYNAPSE_QUERY_FLAGS_ALL = 0xFFFFFFFFLL,
	SYNAPSE_QUERY_FLAGS_LOCAL_CONTENT = SYNAPSE_QUERY_FLAGS_ALL ^ SYNAPSE_QUERY_FLAGS_INCLUDE_REMOTE
} SynapseQueryFlags;

typedef enum  {
	SYNAPSE_MATCH_TYPE_UNKNOWN = 0,
	SYNAPSE_MATCH_TYPE_TEXT,
	SYNAPSE_MATCH_TYPE_APPLICATION,
	SYNAPSE_MATCH_TYPE_GENERIC_URI,
	SYNAPSE_MATCH_TYPE_ACTION,
	SYNAPSE_MATCH_TYPE_SEARCH,
	SYNAPSE_MATCH_TYPE_CONTACT
} SynapseMatchType;

struct _SynapseMatchIface {
	GTypeInterface parent_iface;
	void (*execute) (SynapseMatch* self, SynapseMatch* match);
	void (*execute_with_target) (SynapseMatch* self, SynapseMatch* source, SynapseMatch* target);
	gboolean (*needs_target) (SynapseMatch* self);
	SynapseQueryFlags (*target_flags) (SynapseMatch* self);
	const gchar* (*get_title) (SynapseMatch* self);
	void (*set_title) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_description) (SynapseMatch* self);
	void (*set_description) (SynapseMatch* self, const gchar* value);
	const gchar* (*get_icon_name) (SynapseMatch* self);
	void (*set_icon_name) (SynapseMatch* self, const gchar* value);
	gboolean (*get_has_thumbnail) (SynapseMatch* self);
	void (*set_has_thumbnail) (SynapseMatch* self, gboolean value);
	const gchar* (*get_thumbnail_path) (SynapseMatch* self);
	void (*set_thumbnail_path) (SynapseMatch* self, const gchar* value);
	SynapseMatchType (*get_match_type) (SynapseMatch* self);
	void (*set_match_type) (SynapseMatch* self, SynapseMatchType value);
};

struct _SynapseUriMatchIface {
	GTypeInterface parent_iface;
	const gchar* (*get_uri) (SynapseUriMatch* self);
	void (*set_uri) (SynapseUriMatch* self, const gchar* value);
	SynapseQueryFlags (*get_file_type) (SynapseUriMatch* self);
	void (*set_file_type) (SynapseUriMatch* self, SynapseQueryFlags value);
	const gchar* (*get_mime_type) (SynapseUriMatch* self);
	void (*set_mime_type) (SynapseUriMatch* self, const gchar* value);
};

struct _SynapseUtilsFileInfo {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SynapseUtilsFileInfoPrivate * priv;
	gchar* uri;
	gchar* parse_name;
	SynapseQueryFlags file_type;
	SynapseUriMatch* match_obj;
};

struct _SynapseUtilsFileInfoClass {
	GTypeClass parent_class;
	void (*finalize) (SynapseUtilsFileInfo *self);
};

struct _SynapseUtilsFileInfoPrivate {
	gboolean initialized;
	GType match_obj_type;
};

struct _SynapseUtilsFileInfoInitializeData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseUtilsFileInfo* self;
	GFile* f;
	const gchar* _tmp0_;
	GFile* _tmp1_;
	GFileInfo* fi;
	const gchar* _tmp2_;
	GFileInfo* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	GFileType _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp8_;
	GType _tmp9_;
	const gchar* _tmp10_;
	GIcon* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	const gchar* _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	GObject* _tmp18_;
	GObject* _tmp19_;
	const gchar* mime_type;
	const gchar* _tmp20_;
	const gchar* _tmp21_;
	gboolean _tmp22_;
	const gchar* _tmp23_;
	gboolean _tmp24_;
	const gchar* _tmp25_;
	gboolean _tmp26_;
	const gchar* _tmp27_;
	gboolean _tmp28_;
	const gchar* _tmp29_;
	gboolean _tmp30_;
	const gchar* _tmp31_;
	gboolean _tmp32_;
	SynapseUriMatch* _tmp33_;
	SynapseQueryFlags _tmp34_;
	SynapseUriMatch* _tmp35_;
	const gchar* _tmp36_;
	GError* err;
	GError* _tmp37_;
	const gchar* _tmp38_;
	GError * _inner_error_;
};

struct _SynapseUtilsFileInfoExistsData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseUtilsFileInfo* self;
	gboolean result;
	GFile* f;
	const gchar* _tmp0_;
	GFile* _tmp1_;
	gboolean _result_;
	gboolean _tmp2_;
};

struct _SynapseUtilsParamSpecFileInfo {
	GParamSpec parent_instance;
};


static gpointer synapse_utils_logger_parent_class = NULL;
static gboolean synapse_utils_logger_initialized;
static gboolean synapse_utils_logger_initialized = FALSE;
static gboolean synapse_utils_logger_show_debug;
static gboolean synapse_utils_logger_show_debug = FALSE;
static gpointer synapse_utils_async_once_parent_class = NULL;
static gpointer synapse_utils_file_info_parent_class = NULL;
static gchar* synapse_utils_file_info_interesting_attributes;
static gchar* synapse_utils_file_info_interesting_attributes = NULL;

gchar* synapse_utils_remove_accents (const gchar* input);
gchar* synapse_utils_remove_last_unichar (const gchar* input);
static void synapse_utils_query_exists_async_data_free (gpointer _data);
void synapse_utils_query_exists_async (GFile* f, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean synapse_utils_query_exists_finish (GAsyncResult* _res_);
static gboolean synapse_utils_query_exists_async_co (SynapseUtilsQueryExistsAsyncData* _data_);
static void synapse_utils_query_exists_async_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
gchar* synapse_utils_extract_type_name (GType obj_type);
gpointer synapse_utils_logger_ref (gpointer instance);
void synapse_utils_logger_unref (gpointer instance);
GParamSpec* synapse_utils_param_spec_logger (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void synapse_utils_value_set_logger (GValue* value, gpointer v_object);
void synapse_utils_value_take_logger (GValue* value, gpointer v_object);
gpointer synapse_utils_value_get_logger (const GValue* value);
GType synapse_utils_logger_get_type (void) G_GNUC_CONST;
enum  {
	SYNAPSE_UTILS_LOGGER_DUMMY_PROPERTY
};
#define SYNAPSE_UTILS_LOGGER_RED "\x1b[31m"
#define SYNAPSE_UTILS_LOGGER_GREEN "\x1b[32m"
#define SYNAPSE_UTILS_LOGGER_YELLOW "\x1b[33m"
#define SYNAPSE_UTILS_LOGGER_BLUE "\x1b[34m"
#define SYNAPSE_UTILS_LOGGER_MAGENTA "\x1b[35m"
#define SYNAPSE_UTILS_LOGGER_CYAN "\x1b[36m"
#define SYNAPSE_UTILS_LOGGER_RESET "\x1b[0m"
static void synapse_utils_logger_log_internal (GObject* obj, GLogLevelFlags level, const gchar* format, va_list args);
static void synapse_utils_logger_initialize (void);
void synapse_utils_logger_handler (const gchar* domain, GLogLevelFlags level, const gchar* msg);
static void _synapse_utils_logger_handler_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self);
gboolean synapse_utils_logger_debug_enabled (void);
void synapse_utils_logger_log (GObject* obj, const gchar* format, ...);
void synapse_utils_logger_debug (GObject* obj, const gchar* format, ...);
void synapse_utils_logger_warning (GObject* obj, const gchar* format, ...);
void synapse_utils_logger_error (GObject* obj, const gchar* format, ...);
SynapseUtilsLogger* synapse_utils_logger_new (void);
SynapseUtilsLogger* synapse_utils_logger_construct (GType object_type);
static void synapse_utils_logger_finalize (SynapseUtilsLogger* obj);
void synapse_utils_delegate_wrapper_free (SynapseUtilsDelegateWrapper* self);
static void synapse_utils_delegate_wrapper_instance_init (SynapseUtilsDelegateWrapper * self);
SynapseUtilsDelegateWrapper* synapse_utils_delegate_wrapper_new (GSourceFunc cb, void* cb_target, GDestroyNotify cb_target_destroy_notify);
SynapseUtilsDelegateWrapper* synapse_utils_delegate_wrapper_new (GSourceFunc cb, void* cb_target, GDestroyNotify cb_target_destroy_notify);
gpointer synapse_utils_async_once_ref (gpointer instance);
void synapse_utils_async_once_unref (gpointer instance);
GParamSpec* synapse_utils_param_spec_async_once (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void synapse_utils_value_set_async_once (GValue* value, gpointer v_object);
void synapse_utils_value_take_async_once (GValue* value, gpointer v_object);
gpointer synapse_utils_value_get_async_once (const GValue* value);
GType synapse_utils_async_once_get_type (void) G_GNUC_CONST;
static GType synapse_utils_async_once_operation_state_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
#define SYNAPSE_UTILS_ASYNC_ONCE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOncePrivate))
enum  {
	SYNAPSE_UTILS_ASYNC_ONCE_DUMMY_PROPERTY
};
SynapseUtilsAsyncOnce* synapse_utils_async_once_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
SynapseUtilsAsyncOnce* synapse_utils_async_once_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
gconstpointer synapse_utils_async_once_get_data (SynapseUtilsAsyncOnce* self);
gboolean synapse_utils_async_once_is_initialized (SynapseUtilsAsyncOnce* self);
static void synapse_utils_async_once_enter_data_free (gpointer _data);
void synapse_utils_async_once_enter (SynapseUtilsAsyncOnce* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean synapse_utils_async_once_enter_finish (SynapseUtilsAsyncOnce* self, GAsyncResult* _res_);
static gboolean synapse_utils_async_once_enter_co (SynapseUtilsAsyncOnceEnterData* _data_);
static void synapse_utils_async_once_wait_async (SynapseUtilsAsyncOnce* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void synapse_utils_async_once_wait_finish (SynapseUtilsAsyncOnce* self, GAsyncResult* _res_);
static void synapse_utils_async_once_enter_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void synapse_utils_async_once_leave (SynapseUtilsAsyncOnce* self, gconstpointer _result_);
static void synapse_utils_async_once_notify_all (SynapseUtilsAsyncOnce* self);
void synapse_utils_async_once_reset (SynapseUtilsAsyncOnce* self);
static void synapse_utils_async_once_wait_async_data_free (gpointer _data);
static gboolean synapse_utils_async_once_wait_async_co (SynapseUtilsAsyncOnceWaitAsyncData* _data_);
static gboolean _synapse_utils_async_once_wait_async_co_gsource_func (gpointer self);
static void _vala_array_add9 (SynapseUtilsDelegateWrapper*** array, int* length, int* size, SynapseUtilsDelegateWrapper* value);
static void synapse_utils_async_once_finalize (SynapseUtilsAsyncOnce* obj);
gpointer synapse_utils_file_info_ref (gpointer instance);
void synapse_utils_file_info_unref (gpointer instance);
GParamSpec* synapse_utils_param_spec_file_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void synapse_utils_value_set_file_info (GValue* value, gpointer v_object);
void synapse_utils_value_take_file_info (GValue* value, gpointer v_object);
gpointer synapse_utils_value_get_file_info (const GValue* value);
GType synapse_utils_file_info_get_type (void) G_GNUC_CONST;
GType synapse_query_flags_get_type (void) G_GNUC_CONST;
GType synapse_match_type_get_type (void) G_GNUC_CONST;
GType synapse_match_get_type (void) G_GNUC_CONST;
GType synapse_uri_match_get_type (void) G_GNUC_CONST;
#define SYNAPSE_UTILS_FILE_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SYNAPSE_UTILS_TYPE_FILE_INFO, SynapseUtilsFileInfoPrivate))
enum  {
	SYNAPSE_UTILS_FILE_INFO_DUMMY_PROPERTY
};
SynapseUtilsFileInfo* synapse_utils_file_info_new (const gchar* uri, GType obj_type);
SynapseUtilsFileInfo* synapse_utils_file_info_construct (GType object_type, const gchar* uri, GType obj_type);
gboolean synapse_utils_file_info_is_initialized (SynapseUtilsFileInfo* self);
static void synapse_utils_file_info_initialize_data_free (gpointer _data);
void synapse_utils_file_info_initialize (SynapseUtilsFileInfo* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void synapse_utils_file_info_initialize_finish (SynapseUtilsFileInfo* self, GAsyncResult* _res_);
static gboolean synapse_utils_file_info_initialize_co (SynapseUtilsFileInfoInitializeData* _data_);
static void synapse_utils_file_info_initialize_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void synapse_uri_match_set_file_type (SynapseUriMatch* self, SynapseQueryFlags value);
void synapse_uri_match_set_mime_type (SynapseUriMatch* self, const gchar* value);
static void synapse_utils_file_info_exists_data_free (gpointer _data);
void synapse_utils_file_info_exists (SynapseUtilsFileInfo* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean synapse_utils_file_info_exists_finish (SynapseUtilsFileInfo* self, GAsyncResult* _res_);
static gboolean synapse_utils_file_info_exists_co (SynapseUtilsFileInfoExistsData* _data_);
static void synapse_utils_file_info_exists_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void synapse_utils_file_info_finalize (SynapseUtilsFileInfo* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


gchar* synapse_utils_remove_accents (const gchar* input) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	const gchar* charset = NULL;
	const gchar* _tmp0_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (input != NULL, NULL);
	g_get_charset (&_tmp0_);
	charset = _tmp0_;
	{
		gchar* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		const gchar* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		_tmp2_ = input;
		_tmp3_ = input;
		_tmp4_ = strlen (_tmp3_);
		_tmp5_ = _tmp4_;
		_tmp6_ = charset;
		_tmp7_ = g_convert (_tmp2_, (gssize) _tmp5_, "US-ASCII//TRANSLIT", _tmp6_, NULL, NULL, &_inner_error_);
		_tmp1_ = _tmp7_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_CONVERT_ERROR) {
				goto __catch46_g_convert_error;
			}
			_g_free0 (_result_);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp8_ = _tmp1_;
		_tmp1_ = NULL;
		_g_free0 (_result_);
		_result_ = _tmp8_;
		_tmp9_ = input;
		_tmp10_ = _result_;
		if (g_strcmp0 (_tmp9_, _tmp10_) == 0) {
			result = NULL;
			_g_free0 (_tmp1_);
			_g_free0 (_result_);
			return result;
		}
		_g_free0 (_tmp1_);
	}
	goto __finally46;
	__catch46_g_convert_error:
	{
		GError* err = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_g_free0 (_result_);
		_result_ = NULL;
		_g_error_free0 (err);
	}
	__finally46:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (_result_);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = _result_;
	return result;
}


static gint string_index_of_nth_char (const gchar* self, glong c) {
	gint result = 0;
	glong _tmp0_ = 0L;
	gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = c;
	_tmp1_ = g_utf8_offset_to_pointer (self, _tmp0_);
	result = (gint) (_tmp1_ - ((gchar*) self));
	return result;
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_ = NULL;
	glong _tmp1_ = 0L;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_ = 0L;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_substring (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_ = 0L;
	glong _tmp8_ = 0L;
	glong _tmp14_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	glong _tmp21_ = 0L;
	gchar* _tmp22_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_ = 0L;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		glong _tmp5_ = 0L;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_ = 0;
		gint _tmp7_ = 0;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_ = 0L;
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_ = 0L;
		glong _tmp13_ = 0L;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_ = 0L;
		glong _tmp16_ = 0L;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


gchar* synapse_utils_remove_last_unichar (const gchar* input) {
	gchar* result = NULL;
	glong char_count = 0L;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint len = 0;
	const gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	g_return_val_if_fail (input != NULL, NULL);
	_tmp0_ = input;
	_tmp1_ = g_utf8_strlen (_tmp0_, (gssize) -1);
	char_count = (glong) _tmp1_;
	_tmp2_ = input;
	_tmp3_ = string_index_of_nth_char (_tmp2_, char_count - 1);
	len = _tmp3_;
	_tmp4_ = input;
	_tmp5_ = string_substring (_tmp4_, (glong) 0, (glong) len);
	result = _tmp5_;
	return result;
}


static void synapse_utils_query_exists_async_data_free (gpointer _data) {
	SynapseUtilsQueryExistsAsyncData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->f);
	g_slice_free (SynapseUtilsQueryExistsAsyncData, _data_);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


void synapse_utils_query_exists_async (GFile* f, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseUtilsQueryExistsAsyncData* _data_;
	GFile* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	_data_ = g_slice_new0 (SynapseUtilsQueryExistsAsyncData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, synapse_utils_query_exists_async);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_utils_query_exists_async_data_free);
	_tmp0_ = f;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (_data_->f);
	_data_->f = _tmp1_;
	synapse_utils_query_exists_async_co (_data_);
}


gboolean synapse_utils_query_exists_finish (GAsyncResult* _res_) {
	gboolean result;
	SynapseUtilsQueryExistsAsyncData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	return result;
}


static void synapse_utils_query_exists_async_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseUtilsQueryExistsAsyncData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_utils_query_exists_async_co (_data_);
}


static gboolean synapse_utils_query_exists_async_co (SynapseUtilsQueryExistsAsyncData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = NULL;
		_data_->_tmp0_ = _data_->f;
		_data_->_state_ = 1;
		g_file_query_info_async (_data_->_tmp0_, G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, 0, NULL, synapse_utils_query_exists_async_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = g_file_query_info_finish (_data_->_tmp0_, _data_->_res_, &_data_->_inner_error_);
		_data_->_tmp2_ = NULL;
		_data_->_tmp2_ = _data_->_tmp1_;
		_g_object_unref0 (_data_->_tmp2_);
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch47_g_error;
		}
		_data_->exists = TRUE;
	}
	goto __finally47;
	__catch47_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->exists = FALSE;
		_g_error_free0 (_data_->err);
	}
	__finally47:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_data_->result = _data_->exists;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


gchar* synapse_utils_extract_type_name (GType obj_type) {
	gchar* result = NULL;
	gchar* obj_class = NULL;
	GType _tmp0_ = 0UL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gboolean _tmp4_ = FALSE;
	_tmp0_ = obj_type;
	_tmp1_ = g_type_name (_tmp0_);
	_tmp2_ = g_strdup (_tmp1_);
	obj_class = _tmp2_;
	_tmp3_ = obj_class;
	_tmp4_ = g_str_has_prefix (_tmp3_, "Synapse");
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		_tmp5_ = obj_class;
		_tmp6_ = string_substring (_tmp5_, (glong) 7, (glong) -1);
		result = _tmp6_;
		_g_free0 (obj_class);
		return result;
	}
	result = obj_class;
	return result;
}


static void synapse_utils_logger_log_internal (GObject* obj, GLogLevelFlags level, const gchar* format, va_list args) {
	gboolean _tmp0_ = FALSE;
	gchar* desc = NULL;
	gchar* _tmp1_ = NULL;
	GObject* _tmp2_ = NULL;
	GLogLevelFlags _tmp8_ = 0;
	const gchar* _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	g_return_if_fail (format != NULL);
	_tmp0_ = synapse_utils_logger_initialized;
	if (!_tmp0_) {
		synapse_utils_logger_initialize ();
	}
	_tmp1_ = g_strdup ("");
	desc = _tmp1_;
	_tmp2_ = obj;
	if (_tmp2_ != NULL) {
		gchar* obj_class = NULL;
		GObject* _tmp3_ = NULL;
		GType _tmp4_ = 0UL;
		gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		_tmp3_ = obj;
		_tmp4_ = G_TYPE_FROM_INSTANCE (_tmp3_);
		_tmp5_ = synapse_utils_extract_type_name (_tmp4_);
		obj_class = _tmp5_;
		_tmp6_ = obj_class;
		_tmp7_ = g_strdup_printf ("%s[%s]%s ", SYNAPSE_UTILS_LOGGER_MAGENTA, _tmp6_, SYNAPSE_UTILS_LOGGER_RESET);
		_g_free0 (desc);
		desc = _tmp7_;
		_g_free0 (obj_class);
	}
	_tmp8_ = level;
	_tmp9_ = desc;
	_tmp10_ = format;
	_tmp11_ = g_strconcat (_tmp9_, _tmp10_, NULL);
	_tmp12_ = _tmp11_;
	g_logv ("Synapse", _tmp8_, _tmp12_, args);
	_g_free0 (_tmp12_);
	_g_free0 (desc);
}


static void _synapse_utils_logger_handler_glog_func (const gchar* log_domain, GLogLevelFlags log_levels, const gchar* message, gpointer self) {
	synapse_utils_logger_handler (log_domain, log_levels, message);
}


static void synapse_utils_logger_initialize (void) {
	GLogLevelFlags levels = 0;
	gchar** domains = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar** _tmp9_ = NULL;
	gint domains_length1 = 0;
	gint _domains_size_ = 0;
	gchar** _tmp10_ = NULL;
	gint _tmp10__length1 = 0;
	GLogLevelFlags _tmp13_ = 0;
	const gchar* _tmp14_ = NULL;
	levels = (((G_LOG_LEVEL_DEBUG | G_LOG_LEVEL_INFO) | G_LOG_LEVEL_WARNING) | G_LOG_LEVEL_CRITICAL) | G_LOG_LEVEL_ERROR;
	_tmp0_ = g_strdup ("Synapse");
	_tmp1_ = g_strdup ("Gtk");
	_tmp2_ = g_strdup ("Gdk");
	_tmp3_ = g_strdup ("GLib");
	_tmp4_ = g_strdup ("GLib-GObject");
	_tmp5_ = g_strdup ("Pango");
	_tmp6_ = g_strdup ("GdkPixbuf");
	_tmp7_ = g_strdup ("GLib-GIO");
	_tmp8_ = g_strdup ("GtkHotkey");
	_tmp9_ = g_new0 (gchar*, 9 + 1);
	_tmp9_[0] = _tmp0_;
	_tmp9_[1] = _tmp1_;
	_tmp9_[2] = _tmp2_;
	_tmp9_[3] = _tmp3_;
	_tmp9_[4] = _tmp4_;
	_tmp9_[5] = _tmp5_;
	_tmp9_[6] = _tmp6_;
	_tmp9_[7] = _tmp7_;
	_tmp9_[8] = _tmp8_;
	domains = _tmp9_;
	domains_length1 = 9;
	_domains_size_ = domains_length1;
	_tmp10_ = domains;
	_tmp10__length1 = domains_length1;
	{
		gchar** domain_collection = NULL;
		gint domain_collection_length1 = 0;
		gint _domain_collection_size_ = 0;
		gint domain_it = 0;
		domain_collection = _tmp10_;
		domain_collection_length1 = _tmp10__length1;
		for (domain_it = 0; domain_it < _tmp10__length1; domain_it = domain_it + 1) {
			const gchar* domain = NULL;
			domain = domain_collection[domain_it];
			{
				const gchar* _tmp11_ = NULL;
				GLogLevelFlags _tmp12_ = 0;
				_tmp11_ = domain;
				_tmp12_ = levels;
				g_log_set_handler (_tmp11_, _tmp12_, _synapse_utils_logger_handler_glog_func, NULL);
			}
		}
	}
	_tmp13_ = levels;
	g_log_set_handler (NULL, _tmp13_, _synapse_utils_logger_handler_glog_func, NULL);
	_tmp14_ = g_getenv ("SYNAPSE_DEBUG");
	synapse_utils_logger_show_debug = _tmp14_ != NULL;
	synapse_utils_logger_initialized = TRUE;
	domains = (_vala_array_free (domains, domains_length1, (GDestroyNotify) g_free), NULL);
}


gboolean synapse_utils_logger_debug_enabled (void) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	_tmp0_ = synapse_utils_logger_initialized;
	if (!_tmp0_) {
		synapse_utils_logger_initialize ();
	}
	_tmp1_ = synapse_utils_logger_show_debug;
	result = _tmp1_;
	return result;
}


void synapse_utils_logger_log (GObject* obj, const gchar* format, ...) {
	va_list args = {0};
	GObject* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (format != NULL);
	va_start (args, format);
	_tmp0_ = obj;
	_tmp1_ = format;
	synapse_utils_logger_log_internal (_tmp0_, G_LOG_LEVEL_INFO, _tmp1_, args);
	va_end (args);
}


void synapse_utils_logger_debug (GObject* obj, const gchar* format, ...) {
	va_list args = {0};
	GObject* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (format != NULL);
	va_start (args, format);
	_tmp0_ = obj;
	_tmp1_ = format;
	synapse_utils_logger_log_internal (_tmp0_, G_LOG_LEVEL_DEBUG, _tmp1_, args);
	va_end (args);
}


void synapse_utils_logger_warning (GObject* obj, const gchar* format, ...) {
	va_list args = {0};
	GObject* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (format != NULL);
	va_start (args, format);
	_tmp0_ = obj;
	_tmp1_ = format;
	synapse_utils_logger_log_internal (_tmp0_, G_LOG_LEVEL_WARNING, _tmp1_, args);
	va_end (args);
}


void synapse_utils_logger_error (GObject* obj, const gchar* format, ...) {
	va_list args = {0};
	GObject* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_if_fail (format != NULL);
	va_start (args, format);
	_tmp0_ = obj;
	_tmp1_ = format;
	synapse_utils_logger_log_internal (_tmp0_, G_LOG_LEVEL_ERROR, _tmp1_, args);
	va_end (args);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


void synapse_utils_logger_handler (const gchar* domain, GLogLevelFlags level, const gchar* msg) {
	gchar* header = NULL;
	gchar* domain_str = NULL;
	gchar* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_ = NULL;
	GTimeVal time_val = {0};
	gint _tmp6_ = 0;
	GTimeVal _tmp7_ = {0};
	glong _tmp8_ = 0L;
	glong time_str_len = 0L;
	gchar* cur_time = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	glong _tmp11_ = 0L;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	GLogLevelFlags _tmp14_ = 0;
	FILE* _tmp56_ = NULL;
	const gchar* _tmp57_ = NULL;
	const gchar* _tmp58_ = NULL;
	g_return_if_fail (msg != NULL);
	_tmp0_ = g_strdup ("");
	domain_str = _tmp0_;
	_tmp2_ = domain;
	if (_tmp2_ != NULL) {
		const gchar* _tmp3_ = NULL;
		_tmp3_ = domain;
		_tmp1_ = g_strcmp0 (_tmp3_, "Synapse") != 0;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		const gchar* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		_tmp4_ = domain;
		_tmp5_ = g_strconcat (_tmp4_, "-", NULL);
		_g_free0 (domain_str);
		domain_str = _tmp5_;
	}
	g_get_current_time (&time_val);
	_tmp7_ = time_val;
	_tmp8_ = _tmp7_.tv_usec;
	if (_tmp8_ != ((glong) 0)) {
		_tmp6_ = 15;
	} else {
		_tmp6_ = 8;
	}
	time_str_len = (glong) _tmp6_;
	_tmp9_ = g_time_val_to_iso8601 (&time_val);
	_tmp10_ = _tmp9_;
	_tmp11_ = time_str_len;
	_tmp12_ = string_substring (_tmp10_, (glong) 11, _tmp11_);
	_tmp13_ = _tmp12_;
	_g_free0 (_tmp10_);
	cur_time = _tmp13_;
	_tmp14_ = level;
	if (_tmp14_ == G_LOG_LEVEL_DEBUG) {
		gboolean _tmp15_ = FALSE;
		gboolean _tmp16_ = FALSE;
		const gchar* _tmp18_ = NULL;
		const gchar* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		const gchar* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		_tmp16_ = synapse_utils_logger_show_debug;
		if (!_tmp16_) {
			const gchar* _tmp17_ = NULL;
			_tmp17_ = domain_str;
			_tmp15_ = g_strcmp0 (_tmp17_, "") == 0;
		} else {
			_tmp15_ = FALSE;
		}
		if (_tmp15_) {
			_g_free0 (cur_time);
			_g_free0 (domain_str);
			_g_free0 (header);
			return;
		}
		_tmp18_ = string_to_string (SYNAPSE_UTILS_LOGGER_GREEN);
		_tmp19_ = cur_time;
		_tmp20_ = string_to_string (_tmp19_);
		_tmp21_ = domain_str;
		_tmp22_ = string_to_string (_tmp21_);
		_tmp23_ = string_to_string (SYNAPSE_UTILS_LOGGER_RESET);
		_tmp24_ = g_strconcat (_tmp18_, "[", _tmp20_, " ", _tmp22_, "Debug]", _tmp23_, NULL);
		_g_free0 (header);
		header = _tmp24_;
	} else {
		GLogLevelFlags _tmp25_ = 0;
		_tmp25_ = level;
		if (_tmp25_ == G_LOG_LEVEL_INFO) {
			const gchar* _tmp26_ = NULL;
			const gchar* _tmp27_ = NULL;
			const gchar* _tmp28_ = NULL;
			const gchar* _tmp29_ = NULL;
			const gchar* _tmp30_ = NULL;
			const gchar* _tmp31_ = NULL;
			gchar* _tmp32_ = NULL;
			_tmp26_ = string_to_string (SYNAPSE_UTILS_LOGGER_BLUE);
			_tmp27_ = cur_time;
			_tmp28_ = string_to_string (_tmp27_);
			_tmp29_ = domain_str;
			_tmp30_ = string_to_string (_tmp29_);
			_tmp31_ = string_to_string (SYNAPSE_UTILS_LOGGER_RESET);
			_tmp32_ = g_strconcat (_tmp26_, "[", _tmp28_, " ", _tmp30_, "Info]", _tmp31_, NULL);
			_g_free0 (header);
			header = _tmp32_;
		} else {
			GLogLevelFlags _tmp33_ = 0;
			_tmp33_ = level;
			if (_tmp33_ == G_LOG_LEVEL_WARNING) {
				const gchar* _tmp34_ = NULL;
				const gchar* _tmp35_ = NULL;
				const gchar* _tmp36_ = NULL;
				const gchar* _tmp37_ = NULL;
				const gchar* _tmp38_ = NULL;
				const gchar* _tmp39_ = NULL;
				gchar* _tmp40_ = NULL;
				_tmp34_ = string_to_string (SYNAPSE_UTILS_LOGGER_RED);
				_tmp35_ = cur_time;
				_tmp36_ = string_to_string (_tmp35_);
				_tmp37_ = domain_str;
				_tmp38_ = string_to_string (_tmp37_);
				_tmp39_ = string_to_string (SYNAPSE_UTILS_LOGGER_RESET);
				_tmp40_ = g_strconcat (_tmp34_, "[", _tmp36_, " ", _tmp38_, "Warning]", _tmp39_, NULL);
				_g_free0 (header);
				header = _tmp40_;
			} else {
				gboolean _tmp41_ = FALSE;
				GLogLevelFlags _tmp42_ = 0;
				_tmp42_ = level;
				if (_tmp42_ == G_LOG_LEVEL_CRITICAL) {
					_tmp41_ = TRUE;
				} else {
					GLogLevelFlags _tmp43_ = 0;
					_tmp43_ = level;
					_tmp41_ = _tmp43_ == G_LOG_LEVEL_ERROR;
				}
				if (_tmp41_) {
					const gchar* _tmp44_ = NULL;
					const gchar* _tmp45_ = NULL;
					const gchar* _tmp46_ = NULL;
					const gchar* _tmp47_ = NULL;
					const gchar* _tmp48_ = NULL;
					const gchar* _tmp49_ = NULL;
					gchar* _tmp50_ = NULL;
					_tmp44_ = string_to_string (SYNAPSE_UTILS_LOGGER_RED);
					_tmp45_ = cur_time;
					_tmp46_ = string_to_string (_tmp45_);
					_tmp47_ = domain_str;
					_tmp48_ = string_to_string (_tmp47_);
					_tmp49_ = string_to_string (SYNAPSE_UTILS_LOGGER_RESET);
					_tmp50_ = g_strconcat (_tmp44_, "[", _tmp46_, " ", _tmp48_, "Critical]", _tmp49_, NULL);
					_g_free0 (header);
					header = _tmp50_;
				} else {
					const gchar* _tmp51_ = NULL;
					const gchar* _tmp52_ = NULL;
					const gchar* _tmp53_ = NULL;
					const gchar* _tmp54_ = NULL;
					gchar* _tmp55_ = NULL;
					_tmp51_ = string_to_string (SYNAPSE_UTILS_LOGGER_YELLOW);
					_tmp52_ = cur_time;
					_tmp53_ = string_to_string (_tmp52_);
					_tmp54_ = string_to_string (SYNAPSE_UTILS_LOGGER_RESET);
					_tmp55_ = g_strconcat (_tmp51_, "[", _tmp53_, "]", _tmp54_, NULL);
					_g_free0 (header);
					header = _tmp55_;
				}
			}
		}
	}
	_tmp56_ = stdout;
	_tmp57_ = header;
	_tmp58_ = msg;
	fprintf (_tmp56_, "%s %s\n", _tmp57_, _tmp58_);
	_g_free0 (cur_time);
	_g_free0 (domain_str);
	_g_free0 (header);
}


SynapseUtilsLogger* synapse_utils_logger_construct (GType object_type) {
	SynapseUtilsLogger* self = NULL;
	self = (SynapseUtilsLogger*) g_type_create_instance (object_type);
	return self;
}


SynapseUtilsLogger* synapse_utils_logger_new (void) {
	return synapse_utils_logger_construct (SYNAPSE_UTILS_TYPE_LOGGER);
}


static void synapse_utils_value_logger_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void synapse_utils_value_logger_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		synapse_utils_logger_unref (value->data[0].v_pointer);
	}
}


static void synapse_utils_value_logger_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = synapse_utils_logger_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer synapse_utils_value_logger_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* synapse_utils_value_logger_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SynapseUtilsLogger* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = synapse_utils_logger_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* synapse_utils_value_logger_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SynapseUtilsLogger** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = synapse_utils_logger_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* synapse_utils_param_spec_logger (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SynapseUtilsParamSpecLogger* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SYNAPSE_UTILS_TYPE_LOGGER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer synapse_utils_value_get_logger (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_LOGGER), NULL);
	return value->data[0].v_pointer;
}


void synapse_utils_value_set_logger (GValue* value, gpointer v_object) {
	SynapseUtilsLogger* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_LOGGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYNAPSE_UTILS_TYPE_LOGGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		synapse_utils_logger_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		synapse_utils_logger_unref (old);
	}
}


void synapse_utils_value_take_logger (GValue* value, gpointer v_object) {
	SynapseUtilsLogger* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_LOGGER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYNAPSE_UTILS_TYPE_LOGGER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		synapse_utils_logger_unref (old);
	}
}


static void synapse_utils_logger_class_init (SynapseUtilsLoggerClass * klass) {
	synapse_utils_logger_parent_class = g_type_class_peek_parent (klass);
	((SynapseUtilsLoggerClass *) klass)->finalize = synapse_utils_logger_finalize;
}


static void synapse_utils_logger_instance_init (SynapseUtilsLogger * self) {
	self->ref_count = 1;
}


static void synapse_utils_logger_finalize (SynapseUtilsLogger* obj) {
	SynapseUtilsLogger * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYNAPSE_UTILS_TYPE_LOGGER, SynapseUtilsLogger);
	g_signal_handlers_destroy (self);
}


GType synapse_utils_logger_get_type (void) {
	static volatile gsize synapse_utils_logger_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_utils_logger_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { synapse_utils_value_logger_init, synapse_utils_value_logger_free_value, synapse_utils_value_logger_copy_value, synapse_utils_value_logger_peek_pointer, "p", synapse_utils_value_logger_collect_value, "p", synapse_utils_value_logger_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SynapseUtilsLoggerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_utils_logger_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SynapseUtilsLogger), 0, (GInstanceInitFunc) synapse_utils_logger_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType synapse_utils_logger_type_id;
		synapse_utils_logger_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SynapseUtilsLogger", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&synapse_utils_logger_type_id__volatile, synapse_utils_logger_type_id);
	}
	return synapse_utils_logger_type_id__volatile;
}


gpointer synapse_utils_logger_ref (gpointer instance) {
	SynapseUtilsLogger* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void synapse_utils_logger_unref (gpointer instance) {
	SynapseUtilsLogger* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SYNAPSE_UTILS_LOGGER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SynapseUtilsDelegateWrapper* synapse_utils_delegate_wrapper_new (GSourceFunc cb, void* cb_target, GDestroyNotify cb_target_destroy_notify) {
	SynapseUtilsDelegateWrapper* self;
	GSourceFunc _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	GDestroyNotify _tmp0__target_destroy_notify = NULL;
	self = g_slice_new0 (SynapseUtilsDelegateWrapper);
	synapse_utils_delegate_wrapper_instance_init (self);
	_tmp0_ = cb;
	_tmp0__target = cb_target;
	_tmp0__target_destroy_notify = cb_target_destroy_notify;
	cb_target_destroy_notify = NULL;
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	self->callback = _tmp0_;
	self->callback_target = _tmp0__target;
	self->callback_target_destroy_notify = _tmp0__target_destroy_notify;
	(cb_target_destroy_notify == NULL) ? NULL : (cb_target_destroy_notify (cb_target), NULL);
	cb = NULL;
	cb_target = NULL;
	cb_target_destroy_notify = NULL;
	return self;
}


static void synapse_utils_delegate_wrapper_instance_init (SynapseUtilsDelegateWrapper * self) {
}


void synapse_utils_delegate_wrapper_free (SynapseUtilsDelegateWrapper* self) {
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	g_slice_free (SynapseUtilsDelegateWrapper, self);
}


static GType synapse_utils_async_once_operation_state_get_type (void) {
	static volatile gsize synapse_utils_async_once_operation_state_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_utils_async_once_operation_state_type_id__volatile)) {
		static const GEnumValue values[] = {{SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED, "SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED", "not-started"}, {SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS, "SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS", "in-progress"}, {SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE, "SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE", "done"}, {0, NULL, NULL}};
		GType synapse_utils_async_once_operation_state_type_id;
		synapse_utils_async_once_operation_state_type_id = g_enum_register_static ("SynapseUtilsAsyncOnceOperationState", values);
		g_once_init_leave (&synapse_utils_async_once_operation_state_type_id__volatile, synapse_utils_async_once_operation_state_type_id);
	}
	return synapse_utils_async_once_operation_state_type_id__volatile;
}


SynapseUtilsAsyncOnce* synapse_utils_async_once_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func) {
	SynapseUtilsAsyncOnce* self = NULL;
	self = (SynapseUtilsAsyncOnce*) g_type_create_instance (object_type);
	self->priv->g_type = g_type;
	self->priv->g_dup_func = g_dup_func;
	self->priv->g_destroy_func = g_destroy_func;
	self->priv->state = SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED;
	return self;
}


SynapseUtilsAsyncOnce* synapse_utils_async_once_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func) {
	return synapse_utils_async_once_construct (SYNAPSE_UTILS_TYPE_ASYNC_ONCE, g_type, g_dup_func, g_destroy_func);
}


gconstpointer synapse_utils_async_once_get_data (SynapseUtilsAsyncOnce* self) {
	gconstpointer result = NULL;
	gconstpointer _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->inner;
	result = _tmp0_;
	return result;
}


gboolean synapse_utils_async_once_is_initialized (SynapseUtilsAsyncOnce* self) {
	gboolean result = FALSE;
	SynapseUtilsAsyncOnceOperationState _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->state;
	result = _tmp0_ == SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE;
	return result;
}


static void synapse_utils_async_once_enter_data_free (gpointer _data) {
	SynapseUtilsAsyncOnceEnterData* _data_;
	_data_ = _data;
	_synapse_utils_async_once_unref0 (_data_->self);
	g_slice_free (SynapseUtilsAsyncOnceEnterData, _data_);
}


static gpointer _synapse_utils_async_once_ref0 (gpointer self) {
	return self ? synapse_utils_async_once_ref (self) : NULL;
}


void synapse_utils_async_once_enter (SynapseUtilsAsyncOnce* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseUtilsAsyncOnceEnterData* _data_;
	SynapseUtilsAsyncOnce* _tmp0_ = NULL;
	_data_ = g_slice_new0 (SynapseUtilsAsyncOnceEnterData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, synapse_utils_async_once_enter);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_utils_async_once_enter_data_free);
	_tmp0_ = _synapse_utils_async_once_ref0 (self);
	_data_->self = _tmp0_;
	synapse_utils_async_once_enter_co (_data_);
}


gboolean synapse_utils_async_once_enter_finish (SynapseUtilsAsyncOnce* self, GAsyncResult* _res_) {
	gboolean result;
	SynapseUtilsAsyncOnceEnterData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	return result;
}


static void synapse_utils_async_once_enter_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseUtilsAsyncOnceEnterData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_utils_async_once_enter_co (_data_);
}


static gboolean synapse_utils_async_once_enter_co (SynapseUtilsAsyncOnceEnterData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = 0;
	_data_->_tmp0_ = _data_->self->priv->state;
	if (_data_->_tmp0_ == SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED) {
		_data_->self->priv->state = SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS;
		_data_->result = TRUE;
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	} else {
		_data_->_tmp1_ = 0;
		_data_->_tmp1_ = _data_->self->priv->state;
		if (_data_->_tmp1_ == SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS) {
			_data_->_state_ = 1;
			synapse_utils_async_once_wait_async (_data_->self, synapse_utils_async_once_enter_ready, _data_);
			return FALSE;
			_state_1:
			synapse_utils_async_once_wait_finish (_data_->self, _data_->_res_);
		}
	}
	_data_->result = FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


void synapse_utils_async_once_leave (SynapseUtilsAsyncOnce* self, gconstpointer _result_) {
	SynapseUtilsAsyncOnceOperationState _tmp0_ = 0;
	gconstpointer _tmp1_ = NULL;
	gpointer _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state;
	if (_tmp0_ != SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS) {
		g_warning ("utils.vala:289: Incorrect usage of AsyncOnce");
		return;
	}
	self->priv->state = SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_DONE;
	_tmp1_ = _result_;
	_tmp2_ = ((_tmp1_ != NULL) && (self->priv->g_dup_func != NULL)) ? self->priv->g_dup_func ((gpointer) _tmp1_) : ((gpointer) _tmp1_);
	((self->priv->inner == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->priv->inner = (self->priv->g_destroy_func (self->priv->inner), NULL));
	self->priv->inner = _tmp2_;
	synapse_utils_async_once_notify_all (self);
}


void synapse_utils_async_once_reset (SynapseUtilsAsyncOnce* self) {
	SynapseUtilsAsyncOnceOperationState _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->state;
	if (_tmp0_ == SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_IN_PROGRESS) {
		g_warning ("utils.vala:302: AsyncOnce.reset() cannot be called in the middle of in" \
"itialization.");
	} else {
		self->priv->state = SYNAPSE_UTILS_ASYNC_ONCE_OPERATION_STATE_NOT_STARTED;
		((self->priv->inner == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->priv->inner = (self->priv->g_destroy_func (self->priv->inner), NULL));
		self->priv->inner = NULL;
	}
}


static void synapse_utils_async_once_notify_all (SynapseUtilsAsyncOnce* self) {
	SynapseUtilsDelegateWrapper** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	SynapseUtilsDelegateWrapper** _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->callbacks;
	_tmp0__length1 = self->priv->callbacks_length1;
	{
		SynapseUtilsDelegateWrapper** wrapper_collection = NULL;
		gint wrapper_collection_length1 = 0;
		gint _wrapper_collection_size_ = 0;
		gint wrapper_it = 0;
		wrapper_collection = _tmp0_;
		wrapper_collection_length1 = _tmp0__length1;
		for (wrapper_it = 0; wrapper_it < _tmp0__length1; wrapper_it = wrapper_it + 1) {
			SynapseUtilsDelegateWrapper* wrapper = NULL;
			wrapper = wrapper_collection[wrapper_it];
			{
				SynapseUtilsDelegateWrapper* _tmp1_ = NULL;
				GSourceFunc _tmp2_ = NULL;
				void* _tmp2__target = NULL;
				_tmp1_ = wrapper;
				_tmp2_ = _tmp1_->callback;
				_tmp2__target = _tmp1_->callback_target;
				_tmp2_ (_tmp2__target);
			}
		}
	}
	_tmp3_ = g_new0 (SynapseUtilsDelegateWrapper*, 0 + 1);
	self->priv->callbacks = (_vala_array_free (self->priv->callbacks, self->priv->callbacks_length1, (GDestroyNotify) synapse_utils_delegate_wrapper_free), NULL);
	self->priv->callbacks = _tmp3_;
	self->priv->callbacks_length1 = 0;
	self->priv->_callbacks_size_ = self->priv->callbacks_length1;
}


static void synapse_utils_async_once_wait_async_data_free (gpointer _data) {
	SynapseUtilsAsyncOnceWaitAsyncData* _data_;
	_data_ = _data;
	_synapse_utils_async_once_unref0 (_data_->self);
	g_slice_free (SynapseUtilsAsyncOnceWaitAsyncData, _data_);
}


static void synapse_utils_async_once_wait_async (SynapseUtilsAsyncOnce* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseUtilsAsyncOnceWaitAsyncData* _data_;
	SynapseUtilsAsyncOnce* _tmp0_ = NULL;
	_data_ = g_slice_new0 (SynapseUtilsAsyncOnceWaitAsyncData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, synapse_utils_async_once_wait_async);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_utils_async_once_wait_async_data_free);
	_tmp0_ = _synapse_utils_async_once_ref0 (self);
	_data_->self = _tmp0_;
	synapse_utils_async_once_wait_async_co (_data_);
}


static void synapse_utils_async_once_wait_finish (SynapseUtilsAsyncOnce* self, GAsyncResult* _res_) {
	SynapseUtilsAsyncOnceWaitAsyncData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gboolean _synapse_utils_async_once_wait_async_co_gsource_func (gpointer self) {
	gboolean result;
	result = synapse_utils_async_once_wait_async_co (self);
	return result;
}


static void _vala_array_add9 (SynapseUtilsDelegateWrapper*** array, int* length, int* size, SynapseUtilsDelegateWrapper* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (SynapseUtilsDelegateWrapper*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static gboolean synapse_utils_async_once_wait_async_co (SynapseUtilsAsyncOnceWaitAsyncData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0__length1 = 0;
	_data_->_tmp0_ = _data_->self->priv->callbacks;
	_data_->_tmp0__length1 = _data_->self->priv->callbacks_length1;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = synapse_utils_delegate_wrapper_new (_synapse_utils_async_once_wait_async_co_gsource_func, _data_, NULL);
	_vala_array_add9 (&_data_->self->priv->callbacks, &_data_->self->priv->callbacks_length1, &_data_->self->priv->_callbacks_size_, _data_->_tmp1_);
	_data_->_state_ = 1;
	return FALSE;
	_state_1:
	;
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void synapse_utils_value_async_once_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void synapse_utils_value_async_once_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		synapse_utils_async_once_unref (value->data[0].v_pointer);
	}
}


static void synapse_utils_value_async_once_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = synapse_utils_async_once_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer synapse_utils_value_async_once_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* synapse_utils_value_async_once_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SynapseUtilsAsyncOnce* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = synapse_utils_async_once_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* synapse_utils_value_async_once_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SynapseUtilsAsyncOnce** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = synapse_utils_async_once_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* synapse_utils_param_spec_async_once (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SynapseUtilsParamSpecAsyncOnce* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SYNAPSE_UTILS_TYPE_ASYNC_ONCE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer synapse_utils_value_get_async_once (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_ASYNC_ONCE), NULL);
	return value->data[0].v_pointer;
}


void synapse_utils_value_set_async_once (GValue* value, gpointer v_object) {
	SynapseUtilsAsyncOnce* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_ASYNC_ONCE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYNAPSE_UTILS_TYPE_ASYNC_ONCE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		synapse_utils_async_once_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		synapse_utils_async_once_unref (old);
	}
}


void synapse_utils_value_take_async_once (GValue* value, gpointer v_object) {
	SynapseUtilsAsyncOnce* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_ASYNC_ONCE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYNAPSE_UTILS_TYPE_ASYNC_ONCE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		synapse_utils_async_once_unref (old);
	}
}


static void synapse_utils_async_once_class_init (SynapseUtilsAsyncOnceClass * klass) {
	synapse_utils_async_once_parent_class = g_type_class_peek_parent (klass);
	((SynapseUtilsAsyncOnceClass *) klass)->finalize = synapse_utils_async_once_finalize;
	g_type_class_add_private (klass, sizeof (SynapseUtilsAsyncOncePrivate));
}


static void synapse_utils_async_once_instance_init (SynapseUtilsAsyncOnce * self) {
	SynapseUtilsDelegateWrapper** _tmp0_ = NULL;
	self->priv = SYNAPSE_UTILS_ASYNC_ONCE_GET_PRIVATE (self);
	_tmp0_ = g_new0 (SynapseUtilsDelegateWrapper*, 0 + 1);
	self->priv->callbacks = _tmp0_;
	self->priv->callbacks_length1 = 0;
	self->priv->_callbacks_size_ = self->priv->callbacks_length1;
	self->ref_count = 1;
}


static void synapse_utils_async_once_finalize (SynapseUtilsAsyncOnce* obj) {
	SynapseUtilsAsyncOnce * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOnce);
	g_signal_handlers_destroy (self);
	((self->priv->inner == NULL) || (self->priv->g_destroy_func == NULL)) ? NULL : (self->priv->inner = (self->priv->g_destroy_func (self->priv->inner), NULL));
	self->priv->callbacks = (_vala_array_free (self->priv->callbacks, self->priv->callbacks_length1, (GDestroyNotify) synapse_utils_delegate_wrapper_free), NULL);
}


GType synapse_utils_async_once_get_type (void) {
	static volatile gsize synapse_utils_async_once_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_utils_async_once_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { synapse_utils_value_async_once_init, synapse_utils_value_async_once_free_value, synapse_utils_value_async_once_copy_value, synapse_utils_value_async_once_peek_pointer, "p", synapse_utils_value_async_once_collect_value, "p", synapse_utils_value_async_once_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SynapseUtilsAsyncOnceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_utils_async_once_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SynapseUtilsAsyncOnce), 0, (GInstanceInitFunc) synapse_utils_async_once_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType synapse_utils_async_once_type_id;
		synapse_utils_async_once_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SynapseUtilsAsyncOnce", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&synapse_utils_async_once_type_id__volatile, synapse_utils_async_once_type_id);
	}
	return synapse_utils_async_once_type_id__volatile;
}


gpointer synapse_utils_async_once_ref (gpointer instance) {
	SynapseUtilsAsyncOnce* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void synapse_utils_async_once_unref (gpointer instance) {
	SynapseUtilsAsyncOnce* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SYNAPSE_UTILS_ASYNC_ONCE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SynapseUtilsFileInfo* synapse_utils_file_info_construct (GType object_type, const gchar* uri, GType obj_type) {
	SynapseUtilsFileInfo* self = NULL;
	GType _tmp0_ = 0UL;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GType _tmp4_ = 0UL;
	GFile* f = NULL;
	const gchar* _tmp5_ = NULL;
	GFile* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	g_return_val_if_fail (uri != NULL, NULL);
	self = (SynapseUtilsFileInfo*) g_type_create_instance (object_type);
	_tmp0_ = obj_type;
	_tmp1_ = g_type_is_a (_tmp0_, SYNAPSE_TYPE_URI_MATCH);
	_vala_assert (_tmp1_, "obj_type.is_a (typeof (UriMatch))");
	_tmp2_ = uri;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->uri);
	self->uri = _tmp3_;
	_g_object_unref0 (self->match_obj);
	self->match_obj = NULL;
	_tmp4_ = obj_type;
	self->priv->match_obj_type = _tmp4_;
	self->priv->initialized = FALSE;
	self->file_type = SYNAPSE_QUERY_FLAGS_UNCATEGORIZED;
	_tmp5_ = uri;
	_tmp6_ = g_file_new_for_uri (_tmp5_);
	f = _tmp6_;
	_tmp7_ = g_file_get_parse_name (f);
	_g_free0 (self->parse_name);
	self->parse_name = _tmp7_;
	_g_object_unref0 (f);
	return self;
}


SynapseUtilsFileInfo* synapse_utils_file_info_new (const gchar* uri, GType obj_type) {
	return synapse_utils_file_info_construct (SYNAPSE_UTILS_TYPE_FILE_INFO, uri, obj_type);
}


gboolean synapse_utils_file_info_is_initialized (SynapseUtilsFileInfo* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->initialized;
	result = _tmp0_;
	return result;
}


static void synapse_utils_file_info_initialize_data_free (gpointer _data) {
	SynapseUtilsFileInfoInitializeData* _data_;
	_data_ = _data;
	_synapse_utils_file_info_unref0 (_data_->self);
	g_slice_free (SynapseUtilsFileInfoInitializeData, _data_);
}


static gpointer _synapse_utils_file_info_ref0 (gpointer self) {
	return self ? synapse_utils_file_info_ref (self) : NULL;
}


void synapse_utils_file_info_initialize (SynapseUtilsFileInfo* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseUtilsFileInfoInitializeData* _data_;
	SynapseUtilsFileInfo* _tmp0_ = NULL;
	_data_ = g_slice_new0 (SynapseUtilsFileInfoInitializeData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, synapse_utils_file_info_initialize);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_utils_file_info_initialize_data_free);
	_tmp0_ = _synapse_utils_file_info_ref0 (self);
	_data_->self = _tmp0_;
	synapse_utils_file_info_initialize_co (_data_);
}


void synapse_utils_file_info_initialize_finish (SynapseUtilsFileInfo* self, GAsyncResult* _res_) {
	SynapseUtilsFileInfoInitializeData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void synapse_utils_file_info_initialize_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseUtilsFileInfoInitializeData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_utils_file_info_initialize_co (_data_);
}


static gboolean synapse_utils_file_info_initialize_co (SynapseUtilsFileInfoInitializeData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->self->priv->initialized = TRUE;
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->uri;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_file_new_for_uri (_data_->_tmp0_);
	_data_->f = _data_->_tmp1_;
	{
		_data_->_tmp2_ = NULL;
		_data_->_tmp2_ = synapse_utils_file_info_interesting_attributes;
		_data_->_state_ = 1;
		g_file_query_info_async (_data_->f, _data_->_tmp2_, 0, 0, NULL, synapse_utils_file_info_initialize_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp3_ = NULL;
		_data_->_tmp3_ = g_file_query_info_finish (_data_->f, _data_->_res_, &_data_->_inner_error_);
		_data_->fi = _data_->_tmp3_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch48_g_error;
		}
		_data_->_tmp6_ = 0;
		_data_->_tmp6_ = g_file_info_get_file_type (_data_->fi);
		if (_data_->_tmp6_ == G_FILE_TYPE_REGULAR) {
			_data_->_tmp7_ = FALSE;
			_data_->_tmp7_ = g_file_info_get_is_hidden (_data_->fi);
			_data_->_tmp5_ = !_data_->_tmp7_;
		} else {
			_data_->_tmp5_ = FALSE;
		}
		if (_data_->_tmp5_) {
			_data_->_tmp8_ = FALSE;
			_data_->_tmp8_ = g_file_info_get_is_backup (_data_->fi);
			_data_->_tmp4_ = !_data_->_tmp8_;
		} else {
			_data_->_tmp4_ = FALSE;
		}
		if (_data_->_tmp4_) {
			_data_->_tmp9_ = 0UL;
			_data_->_tmp9_ = _data_->self->priv->match_obj_type;
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = g_file_info_get_attribute_byte_string (_data_->fi, G_FILE_ATTRIBUTE_THUMBNAIL_PATH);
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = g_file_info_get_icon (_data_->fi);
			_data_->_tmp12_ = NULL;
			_data_->_tmp12_ = g_icon_to_string (_data_->_tmp11_);
			_data_->_tmp13_ = NULL;
			_data_->_tmp13_ = _data_->_tmp12_;
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = _data_->self->uri;
			_data_->_tmp15_ = NULL;
			_data_->_tmp15_ = g_file_info_get_display_name (_data_->fi);
			_data_->_tmp16_ = NULL;
			_data_->_tmp16_ = g_file_get_parse_name (_data_->f);
			_data_->_tmp17_ = NULL;
			_data_->_tmp17_ = _data_->_tmp16_;
			_data_->_tmp18_ = NULL;
			_data_->_tmp18_ = g_object_new (_data_->_tmp9_, "thumbnail-path", _data_->_tmp10_, "icon-name", _data_->_tmp13_, "uri", _data_->_tmp14_, "title", _data_->_tmp15_, "description", _data_->_tmp17_, "match-type", SYNAPSE_MATCH_TYPE_GENERIC_URI, NULL, NULL);
			_data_->_tmp19_ = NULL;
			_data_->_tmp19_ = G_IS_INITIALLY_UNOWNED (_data_->_tmp18_) ? g_object_ref_sink (_data_->_tmp18_) : _data_->_tmp18_;
			_g_object_unref0 (_data_->self->match_obj);
			_data_->self->match_obj = G_TYPE_CHECK_INSTANCE_CAST (_data_->_tmp19_, SYNAPSE_TYPE_URI_MATCH, SynapseUriMatch);
			_g_free0 (_data_->_tmp17_);
			_g_free0 (_data_->_tmp13_);
			_data_->_tmp20_ = NULL;
			_data_->_tmp20_ = g_file_info_get_attribute_string (_data_->fi, G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE);
			_data_->mime_type = _data_->_tmp20_;
			_data_->_tmp21_ = NULL;
			_data_->_tmp21_ = _data_->mime_type;
			_data_->_tmp22_ = FALSE;
			_data_->_tmp22_ = g_content_type_is_unknown (_data_->_tmp21_);
			if (_data_->_tmp22_) {
				_data_->self->file_type = SYNAPSE_QUERY_FLAGS_UNCATEGORIZED;
			} else {
				_data_->_tmp23_ = NULL;
				_data_->_tmp23_ = _data_->mime_type;
				_data_->_tmp24_ = FALSE;
				_data_->_tmp24_ = g_content_type_is_a (_data_->_tmp23_, "audio/*");
				if (_data_->_tmp24_) {
					_data_->self->file_type = SYNAPSE_QUERY_FLAGS_AUDIO;
				} else {
					_data_->_tmp25_ = NULL;
					_data_->_tmp25_ = _data_->mime_type;
					_data_->_tmp26_ = FALSE;
					_data_->_tmp26_ = g_content_type_is_a (_data_->_tmp25_, "video/*");
					if (_data_->_tmp26_) {
						_data_->self->file_type = SYNAPSE_QUERY_FLAGS_VIDEO;
					} else {
						_data_->_tmp27_ = NULL;
						_data_->_tmp27_ = _data_->mime_type;
						_data_->_tmp28_ = FALSE;
						_data_->_tmp28_ = g_content_type_is_a (_data_->_tmp27_, "image/*");
						if (_data_->_tmp28_) {
							_data_->self->file_type = SYNAPSE_QUERY_FLAGS_IMAGES;
						} else {
							_data_->_tmp29_ = NULL;
							_data_->_tmp29_ = _data_->mime_type;
							_data_->_tmp30_ = FALSE;
							_data_->_tmp30_ = g_content_type_is_a (_data_->_tmp29_, "text/*");
							if (_data_->_tmp30_) {
								_data_->self->file_type = SYNAPSE_QUERY_FLAGS_DOCUMENTS;
							} else {
								_data_->_tmp31_ = NULL;
								_data_->_tmp31_ = _data_->mime_type;
								_data_->_tmp32_ = FALSE;
								_data_->_tmp32_ = g_content_type_is_a (_data_->_tmp31_, "application/*");
								if (_data_->_tmp32_) {
									_data_->self->file_type = SYNAPSE_QUERY_FLAGS_DOCUMENTS;
								}
							}
						}
					}
				}
			}
			_data_->_tmp33_ = NULL;
			_data_->_tmp33_ = _data_->self->match_obj;
			_data_->_tmp34_ = 0;
			_data_->_tmp34_ = _data_->self->file_type;
			synapse_uri_match_set_file_type (_data_->_tmp33_, _data_->_tmp34_);
			_data_->_tmp35_ = NULL;
			_data_->_tmp35_ = _data_->self->match_obj;
			_data_->_tmp36_ = NULL;
			_data_->_tmp36_ = _data_->mime_type;
			synapse_uri_match_set_mime_type (_data_->_tmp35_, _data_->_tmp36_);
		}
		_g_object_unref0 (_data_->fi);
	}
	goto __finally48;
	__catch48_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp37_ = NULL;
		_data_->_tmp37_ = _data_->err;
		_data_->_tmp38_ = NULL;
		_data_->_tmp38_ = _data_->_tmp37_->message;
		g_warning ("utils.vala:425: %s", _data_->_tmp38_);
		_g_error_free0 (_data_->err);
	}
	__finally48:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		_g_object_unref0 (_data_->f);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_g_object_unref0 (_data_->f);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void synapse_utils_file_info_exists_data_free (gpointer _data) {
	SynapseUtilsFileInfoExistsData* _data_;
	_data_ = _data;
	_synapse_utils_file_info_unref0 (_data_->self);
	g_slice_free (SynapseUtilsFileInfoExistsData, _data_);
}


void synapse_utils_file_info_exists (SynapseUtilsFileInfo* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseUtilsFileInfoExistsData* _data_;
	SynapseUtilsFileInfo* _tmp0_ = NULL;
	_data_ = g_slice_new0 (SynapseUtilsFileInfoExistsData);
	_data_->_async_result = g_simple_async_result_new (NULL, _callback_, _user_data_, synapse_utils_file_info_exists);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_utils_file_info_exists_data_free);
	_tmp0_ = _synapse_utils_file_info_ref0 (self);
	_data_->self = _tmp0_;
	synapse_utils_file_info_exists_co (_data_);
}


gboolean synapse_utils_file_info_exists_finish (SynapseUtilsFileInfo* self, GAsyncResult* _res_) {
	gboolean result;
	SynapseUtilsFileInfoExistsData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
	result = _data_->result;
	return result;
}


static void synapse_utils_file_info_exists_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseUtilsFileInfoExistsData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_utils_file_info_exists_co (_data_);
}


static gboolean synapse_utils_file_info_exists_co (SynapseUtilsFileInfoExistsData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->uri;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_file_new_for_uri (_data_->_tmp0_);
	_data_->f = _data_->_tmp1_;
	_data_->_state_ = 1;
	synapse_utils_query_exists_async (_data_->f, synapse_utils_file_info_exists_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp2_ = FALSE;
	_data_->_tmp2_ = synapse_utils_query_exists_finish (_data_->_res_);
	_data_->_result_ = _data_->_tmp2_;
	_data_->result = _data_->_result_;
	_g_object_unref0 (_data_->f);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
	_g_object_unref0 (_data_->f);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void synapse_utils_value_file_info_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void synapse_utils_value_file_info_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		synapse_utils_file_info_unref (value->data[0].v_pointer);
	}
}


static void synapse_utils_value_file_info_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = synapse_utils_file_info_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer synapse_utils_value_file_info_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* synapse_utils_value_file_info_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SynapseUtilsFileInfo* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = synapse_utils_file_info_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* synapse_utils_value_file_info_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SynapseUtilsFileInfo** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = synapse_utils_file_info_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* synapse_utils_param_spec_file_info (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	SynapseUtilsParamSpecFileInfo* spec;
	g_return_val_if_fail (g_type_is_a (object_type, SYNAPSE_UTILS_TYPE_FILE_INFO), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer synapse_utils_value_get_file_info (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_FILE_INFO), NULL);
	return value->data[0].v_pointer;
}


void synapse_utils_value_set_file_info (GValue* value, gpointer v_object) {
	SynapseUtilsFileInfo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_FILE_INFO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYNAPSE_UTILS_TYPE_FILE_INFO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		synapse_utils_file_info_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		synapse_utils_file_info_unref (old);
	}
}


void synapse_utils_value_take_file_info (GValue* value, gpointer v_object) {
	SynapseUtilsFileInfo* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, SYNAPSE_UTILS_TYPE_FILE_INFO));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, SYNAPSE_UTILS_TYPE_FILE_INFO));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		synapse_utils_file_info_unref (old);
	}
}


static void synapse_utils_file_info_class_init (SynapseUtilsFileInfoClass * klass) {
	gchar* _tmp0_ = NULL;
	synapse_utils_file_info_parent_class = g_type_class_peek_parent (klass);
	((SynapseUtilsFileInfoClass *) klass)->finalize = synapse_utils_file_info_finalize;
	g_type_class_add_private (klass, sizeof (SynapseUtilsFileInfoPrivate));
	_tmp0_ = g_strjoin (",", G_FILE_ATTRIBUTE_STANDARD_TYPE, G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN, G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP, G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME, G_FILE_ATTRIBUTE_STANDARD_ICON, G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE, G_FILE_ATTRIBUTE_THUMBNAIL_PATH, NULL, NULL);
	_g_free0 (synapse_utils_file_info_interesting_attributes);
	synapse_utils_file_info_interesting_attributes = _tmp0_;
}


static void synapse_utils_file_info_instance_init (SynapseUtilsFileInfo * self) {
	self->priv = SYNAPSE_UTILS_FILE_INFO_GET_PRIVATE (self);
	self->ref_count = 1;
}


static void synapse_utils_file_info_finalize (SynapseUtilsFileInfo* obj) {
	SynapseUtilsFileInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYNAPSE_UTILS_TYPE_FILE_INFO, SynapseUtilsFileInfo);
	g_signal_handlers_destroy (self);
	_g_free0 (self->uri);
	_g_free0 (self->parse_name);
	_g_object_unref0 (self->match_obj);
}


GType synapse_utils_file_info_get_type (void) {
	static volatile gsize synapse_utils_file_info_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_utils_file_info_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { synapse_utils_value_file_info_init, synapse_utils_value_file_info_free_value, synapse_utils_value_file_info_copy_value, synapse_utils_value_file_info_peek_pointer, "p", synapse_utils_value_file_info_collect_value, "p", synapse_utils_value_file_info_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SynapseUtilsFileInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_utils_file_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SynapseUtilsFileInfo), 0, (GInstanceInitFunc) synapse_utils_file_info_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType synapse_utils_file_info_type_id;
		synapse_utils_file_info_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SynapseUtilsFileInfo", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&synapse_utils_file_info_type_id__volatile, synapse_utils_file_info_type_id);
	}
	return synapse_utils_file_info_type_id__volatile;
}


gpointer synapse_utils_file_info_ref (gpointer instance) {
	SynapseUtilsFileInfo* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void synapse_utils_file_info_unref (gpointer instance) {
	SynapseUtilsFileInfo* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SYNAPSE_UTILS_FILE_INFO_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



