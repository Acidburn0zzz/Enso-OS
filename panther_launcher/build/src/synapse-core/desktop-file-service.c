/* desktop-file-service.c generated by valac 0.30.1, the Vala compiler
 * generated from desktop-file-service.vala, do not modify */

/*
 * Copyright (C) 2010 Michal Hruby <michal.mhr@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Michal Hruby <michal.mhr@gmail.com>
 *             Alberto Aldegheri <albyrock87+dev@gmail.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gdesktopappinfo.h>
#include <gio/gio.h>
#include <gee.h>
#include <locale.h>


#define SYNAPSE_TYPE_DESKTOP_FILE_INFO (synapse_desktop_file_info_get_type ())
#define SYNAPSE_DESKTOP_FILE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_DESKTOP_FILE_INFO, SynapseDesktopFileInfo))
#define SYNAPSE_DESKTOP_FILE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_TYPE_DESKTOP_FILE_INFO, SynapseDesktopFileInfoClass))
#define SYNAPSE_IS_DESKTOP_FILE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_DESKTOP_FILE_INFO))
#define SYNAPSE_IS_DESKTOP_FILE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_TYPE_DESKTOP_FILE_INFO))
#define SYNAPSE_DESKTOP_FILE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_TYPE_DESKTOP_FILE_INFO, SynapseDesktopFileInfoClass))

typedef struct _SynapseDesktopFileInfo SynapseDesktopFileInfo;
typedef struct _SynapseDesktopFileInfoClass SynapseDesktopFileInfoClass;
typedef struct _SynapseDesktopFileInfoPrivate SynapseDesktopFileInfoPrivate;

#define SYNAPSE_DESKTOP_FILE_INFO_TYPE_ENVIRONMENT_TYPE (synapse_desktop_file_info_environment_type_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define SYNAPSE_TYPE_DESKTOP_FILE_SERVICE (synapse_desktop_file_service_get_type ())
#define SYNAPSE_DESKTOP_FILE_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, SynapseDesktopFileService))
#define SYNAPSE_DESKTOP_FILE_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, SynapseDesktopFileServiceClass))
#define SYNAPSE_IS_DESKTOP_FILE_SERVICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_TYPE_DESKTOP_FILE_SERVICE))
#define SYNAPSE_IS_DESKTOP_FILE_SERVICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_TYPE_DESKTOP_FILE_SERVICE))
#define SYNAPSE_DESKTOP_FILE_SERVICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, SynapseDesktopFileServiceClass))

typedef struct _SynapseDesktopFileService SynapseDesktopFileService;
typedef struct _SynapseDesktopFileServiceClass SynapseDesktopFileServiceClass;
typedef struct _SynapseDesktopFileServicePrivate SynapseDesktopFileServicePrivate;

#define SYNAPSE_UTILS_TYPE_ASYNC_ONCE (synapse_utils_async_once_get_type ())
#define SYNAPSE_UTILS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOnce))
#define SYNAPSE_UTILS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOnceClass))
#define SYNAPSE_UTILS_IS_ASYNC_ONCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SYNAPSE_UTILS_TYPE_ASYNC_ONCE))
#define SYNAPSE_UTILS_IS_ASYNC_ONCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SYNAPSE_UTILS_TYPE_ASYNC_ONCE))
#define SYNAPSE_UTILS_ASYNC_ONCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), SYNAPSE_UTILS_TYPE_ASYNC_ONCE, SynapseUtilsAsyncOnceClass))

typedef struct _SynapseUtilsAsyncOnce SynapseUtilsAsyncOnce;
typedef struct _SynapseUtilsAsyncOnceClass SynapseUtilsAsyncOnceClass;
#define _synapse_utils_async_once_unref0(var) ((var == NULL) ? NULL : (var = (synapse_utils_async_once_unref (var), NULL)))
typedef struct _SynapseDesktopFileServiceInitializeData SynapseDesktopFileServiceInitializeData;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _SynapseDesktopFileServiceProcessDirectoryData SynapseDesktopFileServiceProcessDirectoryData;
typedef struct _SynapseDesktopFileServiceLoadAllDesktopFilesData SynapseDesktopFileServiceLoadAllDesktopFilesData;
typedef struct _SynapseDesktopFileServiceReloadDesktopFilesData SynapseDesktopFileServiceReloadDesktopFilesData;
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
typedef struct _SynapseDesktopFileServiceLoadDesktopFileData SynapseDesktopFileServiceLoadDesktopFileData;
typedef struct _SynapseDesktopFileServiceLoadMimeParentsFromFileData SynapseDesktopFileServiceLoadMimeParentsFromFileData;

typedef enum  {
	SYNAPSE_DESKTOP_FILE_ERROR_UNINTERESTING_ENTRY
} SynapseDesktopFileError;
#define SYNAPSE_DESKTOP_FILE_ERROR synapse_desktop_file_error_quark ()
struct _SynapseDesktopFileInfo {
	GObject parent_instance;
	SynapseDesktopFileInfoPrivate * priv;
	gchar** mime_types;
	gint mime_types_length1;
};

struct _SynapseDesktopFileInfoClass {
	GObjectClass parent_class;
};

typedef enum  {
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_GNOME = 1 << 0,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_KDE = 1 << 1,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_LXDE = 1 << 2,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_MATE = 1 << 3,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_RAZOR = 1 << 4,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ROX = 1 << 5,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_TDE = 1 << 6,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_UNITY = 1 << 7,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_XFCE = 1 << 8,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_PANTHEON = 1 << 9,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_OLD = 1 << 10,
	SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ALL = 0x3FF
} SynapseDesktopFileInfoEnvironmentType;

struct _SynapseDesktopFileInfoPrivate {
	gchar* _desktop_id;
	gchar* _name;
	gchar* _generic_name;
	gchar* _comment;
	gchar* _icon_name;
	gboolean _needs_terminal;
	gchar* _filename;
	gchar* _exec;
	gboolean _is_hidden;
	gboolean _is_valid;
	gchar* name_folded;
	SynapseDesktopFileInfoEnvironmentType _show_in;
};

struct _SynapseDesktopFileService {
	GObject parent_instance;
	SynapseDesktopFileServicePrivate * priv;
};

struct _SynapseDesktopFileServiceClass {
	GObjectClass parent_class;
};

struct _SynapseDesktopFileServicePrivate {
	SynapseUtilsAsyncOnce* init_once;
	GeeList* directory_monitors;
	GeeList* all_desktop_files;
	GeeList* non_hidden_desktop_files;
	GeeMap* mimetype_map;
	GeeMap* exec_map;
	GeeMap* desktop_id_map;
	GeeMultiMap* mimetype_parent_map;
	SynapseDesktopFileInfoEnvironmentType session_type;
	gchar* session_type_str;
	guint timer_id;
};

struct _SynapseDesktopFileServiceInitializeData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseDesktopFileService* self;
	SynapseUtilsAsyncOnce* _tmp0_;
	gboolean _tmp1_;
	gboolean is_locked;
	SynapseUtilsAsyncOnce* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	const gchar* _tmp5_;
	SynapseUtilsAsyncOnce* _tmp6_;
};

struct _SynapseDesktopFileServiceProcessDirectoryData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseDesktopFileService* self;
	GFile* directory;
	gchar* id_prefix;
	GeeSet* monitored_dirs;
	gchar* path;
	GFile* _tmp0_;
	gchar* _tmp1_;
	gboolean _tmp2_;
	const gchar* _tmp3_;
	const gchar* _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	const gchar* _tmp7_;
	const gchar* _tmp8_;
	gboolean _tmp9_;
	const gchar* _tmp10_;
	gboolean exists;
	GFile* _tmp11_;
	gboolean _tmp12_;
	gboolean _tmp13_;
	GeeIterator* _scanned_dir_it;
	GeeSet* _tmp14_;
	GeeIterator* _tmp15_;
	GeeIterator* _tmp16_;
	gboolean _tmp17_;
	GFile* scanned_dir;
	GeeIterator* _tmp18_;
	gpointer _tmp19_;
	const gchar* _tmp20_;
	GFile* _tmp21_;
	gchar* _tmp22_;
	gchar* _tmp23_;
	gboolean _tmp24_;
	GeeSet* _tmp25_;
	GFile* _tmp26_;
	GFileEnumerator* enumerator;
	GFile* _tmp27_;
	GFileEnumerator* _tmp28_;
	GList* files;
	GFileEnumerator* _tmp29_;
	GList* _tmp30_;
	GList* _tmp31_;
	GList* f_collection;
	GList* f_it;
	GFileInfo* _tmp32_;
	GFileInfo* f;
	const gchar* name;
	GFileInfo* _tmp33_;
	const gchar* _tmp34_;
	GFileInfo* _tmp35_;
	GFileType _tmp36_;
	GFile* subdir;
	GFile* _tmp37_;
	const gchar* _tmp38_;
	GFile* _tmp39_;
	gchar* new_prefix;
	const gchar* _tmp40_;
	GFile* _tmp41_;
	gchar* _tmp42_;
	gchar* _tmp43_;
	gchar* _tmp44_;
	gchar* _tmp45_;
	GFile* _tmp46_;
	const gchar* _tmp47_;
	GeeSet* _tmp48_;
	const gchar* _tmp49_;
	gboolean _tmp50_;
	const gchar* _tmp51_;
	gboolean _tmp52_;
	GFile* _tmp53_;
	const gchar* _tmp54_;
	GFile* _tmp55_;
	GFile* _tmp56_;
	const gchar* _tmp57_;
	GError* err;
	GError* _tmp58_;
	const gchar* _tmp59_;
	GError * _inner_error_;
};

struct _SynapseDesktopFileServiceLoadAllDesktopFilesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseDesktopFileService* self;
	gchar** data_dirs;
	gchar** _tmp0_;
	gchar** _tmp1_;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gint data_dirs_length1;
	gint _data_dirs_size_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	const gchar* _tmp4_;
	gchar* _tmp5_;
	GeeSet* desktop_file_dirs;
	GeeHashSet* _tmp6_;
	GeeMultiMap* _tmp7_;
	gchar** _tmp8_;
	gint _tmp8__length1;
	gchar** data_dir_collection;
	gint data_dir_collection_length1;
	gint _data_dir_collection_size_;
	gint data_dir_it;
	const gchar* data_dir;
	gchar* dir_path;
	const gchar* _tmp9_;
	gchar* _tmp10_;
	GFile* directory;
	const gchar* _tmp11_;
	GFile* _tmp12_;
	GFile* _tmp13_;
	GeeSet* _tmp14_;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	const gchar* _tmp17_;
	GeeArrayList* _tmp18_;
	GeeIterator* _d_it;
	GeeSet* _tmp19_;
	GeeIterator* _tmp20_;
	GeeIterator* _tmp21_;
	gboolean _tmp22_;
	GFile* d;
	GeeIterator* _tmp23_;
	gpointer _tmp24_;
	GFileMonitor* monitor;
	GFile* _tmp25_;
	GFileMonitor* _tmp26_;
	GFileMonitor* _tmp27_;
	GeeList* _tmp28_;
	GFileMonitor* _tmp29_;
	GError* err;
	GError* _tmp30_;
	const gchar* _tmp31_;
	GError * _inner_error_;
};

struct _SynapseDesktopFileServiceReloadDesktopFilesData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseDesktopFileService* self;
	GeeList* _tmp0_;
	GeeList* _tmp1_;
};

struct _SynapseDesktopFileServiceLoadDesktopFileData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseDesktopFileService* self;
	GFile* file;
	gchar* id_prefix;
	guint8* file_contents;
	gint file_contents_length1;
	gint _file_contents_size_;
	gboolean success;
	GFile* _tmp0_;
	guint8* _tmp1_;
	gsize _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GKeyFile* keyfile;
	GKeyFile* _tmp5_;
	GKeyFile* _tmp6_;
	guint8* _tmp7_;
	gint _tmp7__length1;
	guint8* _tmp8_;
	gint _tmp8__length1;
	gchar* desktop_id;
	const gchar* _tmp9_;
	GFile* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	SynapseDesktopFileInfo* dfi;
	GFile* _tmp15_;
	gchar* _tmp16_;
	gchar* _tmp17_;
	GKeyFile* _tmp18_;
	const gchar* _tmp19_;
	SynapseDesktopFileInfo* _tmp20_;
	SynapseDesktopFileInfo* _tmp21_;
	SynapseDesktopFileInfo* _tmp22_;
	gboolean _tmp23_;
	gboolean _tmp24_;
	GeeList* _tmp25_;
	SynapseDesktopFileInfo* _tmp26_;
	gboolean _tmp27_;
	SynapseDesktopFileInfo* _tmp28_;
	gboolean _tmp29_;
	gboolean _tmp30_;
	SynapseDesktopFileInfoEnvironmentType _tmp31_;
	SynapseDesktopFileInfo* _tmp32_;
	SynapseDesktopFileInfoEnvironmentType _tmp33_;
	SynapseDesktopFileInfoEnvironmentType _tmp34_;
	GeeList* _tmp35_;
	SynapseDesktopFileInfo* _tmp36_;
	GError* err;
	GError* _tmp37_;
	const gchar* _tmp38_;
	GError * _inner_error_;
};

struct _SynapseDesktopFileServiceLoadMimeParentsFromFileData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GSimpleAsyncResult* _async_result;
	SynapseDesktopFileService* self;
	gchar* fi;
	GFile* file;
	const gchar* _tmp0_;
	GFile* _tmp1_;
	gboolean exists;
	GFile* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GFileInputStream* fis;
	GFile* _tmp5_;
	GFileInputStream* _tmp6_;
	GDataInputStream* dis;
	GFileInputStream* _tmp7_;
	GDataInputStream* _tmp8_;
	gchar* line;
	gchar** mimes;
	gint mimes_length1;
	gint _mimes_size_;
	gint len;
	gchar* _tmp9_;
	GDataInputStream* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	const gchar* _tmp13_;
	const gchar* _tmp14_;
	gboolean _tmp15_;
	const gchar* _tmp16_;
	gchar** _tmp17_;
	gchar** _tmp18_;
	gchar** _tmp19_;
	gint _tmp19__length1;
	guint _tmp20_;
	gint _tmp21_;
	gchar** _tmp22_;
	gint _tmp22__length1;
	const gchar* _tmp23_;
	gchar** _tmp24_;
	gint _tmp24__length1;
	const gchar* _tmp25_;
	GeeMultiMap* _tmp26_;
	gchar** _tmp27_;
	gint _tmp27__length1;
	const gchar* _tmp28_;
	gchar** _tmp29_;
	gint _tmp29__length1;
	const gchar* _tmp30_;
	GError* err;
	GError * _inner_error_;
};


static gpointer synapse_desktop_file_info_parent_class = NULL;
static gpointer synapse_desktop_file_service_parent_class = NULL;
static SynapseDesktopFileService* synapse_desktop_file_service_instance;
static SynapseDesktopFileService* synapse_desktop_file_service_instance = NULL;

GQuark synapse_desktop_file_error_quark (void);
GType synapse_desktop_file_info_get_type (void) G_GNUC_CONST;
GType synapse_desktop_file_info_environment_type_get_type (void) G_GNUC_CONST;
#define SYNAPSE_DESKTOP_FILE_INFO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SYNAPSE_TYPE_DESKTOP_FILE_INFO, SynapseDesktopFileInfoPrivate))
enum  {
	SYNAPSE_DESKTOP_FILE_INFO_DUMMY_PROPERTY,
	SYNAPSE_DESKTOP_FILE_INFO_DESKTOP_ID,
	SYNAPSE_DESKTOP_FILE_INFO_NAME,
	SYNAPSE_DESKTOP_FILE_INFO_GENERIC_NAME,
	SYNAPSE_DESKTOP_FILE_INFO_COMMENT,
	SYNAPSE_DESKTOP_FILE_INFO_ICON_NAME,
	SYNAPSE_DESKTOP_FILE_INFO_NEEDS_TERMINAL,
	SYNAPSE_DESKTOP_FILE_INFO_FILENAME,
	SYNAPSE_DESKTOP_FILE_INFO_EXEC,
	SYNAPSE_DESKTOP_FILE_INFO_IS_HIDDEN,
	SYNAPSE_DESKTOP_FILE_INFO_IS_VALID,
	SYNAPSE_DESKTOP_FILE_INFO_SHOW_IN
};
#define SYNAPSE_DESKTOP_FILE_INFO_GROUP "Desktop Entry"
const gchar* synapse_desktop_file_info_get_name_folded (SynapseDesktopFileInfo* self);
const gchar* synapse_desktop_file_info_get_name (SynapseDesktopFileInfo* self);
SynapseDesktopFileInfo* synapse_desktop_file_info_new_for_keyfile (const gchar* path, GKeyFile* keyfile, const gchar* desktop_id);
SynapseDesktopFileInfo* synapse_desktop_file_info_construct_for_keyfile (GType object_type, const gchar* path, GKeyFile* keyfile, const gchar* desktop_id);
static void synapse_desktop_file_info_init_from_keyfile (SynapseDesktopFileInfo* self, GKeyFile* keyfile);
static SynapseDesktopFileInfoEnvironmentType synapse_desktop_file_info_parse_environments (SynapseDesktopFileInfo* self, gchar** environments, int environments_length1);
static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle);
void synapse_desktop_file_info_set_name (SynapseDesktopFileInfo* self, const gchar* value);
void synapse_desktop_file_info_set_generic_name (SynapseDesktopFileInfo* self, const gchar* value);
void synapse_desktop_file_info_set_exec (SynapseDesktopFileInfo* self, const gchar* value);
const gchar* synapse_desktop_file_info_get_exec (SynapseDesktopFileInfo* self);
static void synapse_desktop_file_info_set_is_hidden (SynapseDesktopFileInfo* self, gboolean value);
void synapse_desktop_file_info_set_comment (SynapseDesktopFileInfo* self, const gchar* value);
void synapse_desktop_file_info_set_icon_name (SynapseDesktopFileInfo* self, const gchar* value);
void synapse_desktop_file_info_set_needs_terminal (SynapseDesktopFileInfo* self, gboolean value);
void synapse_desktop_file_info_set_show_in (SynapseDesktopFileInfo* self, SynapseDesktopFileInfoEnvironmentType value);
const gchar* synapse_desktop_file_info_get_filename (SynapseDesktopFileInfo* self);
void synapse_utils_logger_warning (GObject* obj, const gchar* format, ...);
static void synapse_desktop_file_info_set_is_valid (SynapseDesktopFileInfo* self, gboolean value);
SynapseDesktopFileInfo* synapse_desktop_file_info_new (void);
SynapseDesktopFileInfo* synapse_desktop_file_info_construct (GType object_type);
const gchar* synapse_desktop_file_info_get_desktop_id (SynapseDesktopFileInfo* self);
void synapse_desktop_file_info_set_desktop_id (SynapseDesktopFileInfo* self, const gchar* value);
const gchar* synapse_desktop_file_info_get_generic_name (SynapseDesktopFileInfo* self);
const gchar* synapse_desktop_file_info_get_comment (SynapseDesktopFileInfo* self);
const gchar* synapse_desktop_file_info_get_icon_name (SynapseDesktopFileInfo* self);
gboolean synapse_desktop_file_info_get_needs_terminal (SynapseDesktopFileInfo* self);
void synapse_desktop_file_info_set_filename (SynapseDesktopFileInfo* self, const gchar* value);
gboolean synapse_desktop_file_info_get_is_hidden (SynapseDesktopFileInfo* self);
gboolean synapse_desktop_file_info_get_is_valid (SynapseDesktopFileInfo* self);
SynapseDesktopFileInfoEnvironmentType synapse_desktop_file_info_get_show_in (SynapseDesktopFileInfo* self);
static void synapse_desktop_file_info_finalize (GObject* obj);
static void _vala_synapse_desktop_file_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_synapse_desktop_file_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType synapse_desktop_file_service_get_type (void) G_GNUC_CONST;
gpointer synapse_utils_async_once_ref (gpointer instance);
void synapse_utils_async_once_unref (gpointer instance);
GParamSpec* synapse_utils_param_spec_async_once (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void synapse_utils_value_set_async_once (GValue* value, gpointer v_object);
void synapse_utils_value_take_async_once (GValue* value, gpointer v_object);
gpointer synapse_utils_value_get_async_once (const GValue* value);
GType synapse_utils_async_once_get_type (void) G_GNUC_CONST;
#define SYNAPSE_DESKTOP_FILE_SERVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, SynapseDesktopFileServicePrivate))
enum  {
	SYNAPSE_DESKTOP_FILE_SERVICE_DUMMY_PROPERTY
};
SynapseDesktopFileService* synapse_desktop_file_service_get_default (void);
static SynapseDesktopFileService* synapse_desktop_file_service_new (void);
static SynapseDesktopFileService* synapse_desktop_file_service_construct (GType object_type);
static void synapse_desktop_file_service_initialize_data_free (gpointer _data);
void synapse_desktop_file_service_initialize (SynapseDesktopFileService* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
void synapse_desktop_file_service_initialize_finish (SynapseDesktopFileService* self, GAsyncResult* _res_);
static gboolean synapse_desktop_file_service_initialize_co (SynapseDesktopFileServiceInitializeData* _data_);
gboolean synapse_utils_async_once_is_initialized (SynapseUtilsAsyncOnce* self);
void synapse_utils_async_once_enter (SynapseUtilsAsyncOnce* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean synapse_utils_async_once_enter_finish (SynapseUtilsAsyncOnce* self, GAsyncResult* _res_);
static void synapse_desktop_file_service_initialize_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void synapse_desktop_file_service_get_environment_type (SynapseDesktopFileService* self);
static gboolean _synapse_desktop_file_service_initialize_co_gsource_func (gpointer self);
static void synapse_desktop_file_service_load_all_desktop_files (SynapseDesktopFileService* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void synapse_desktop_file_service_load_all_desktop_files_finish (SynapseDesktopFileService* self, GAsyncResult* _res_);
void synapse_utils_async_once_leave (SynapseUtilsAsyncOnce* self, gconstpointer _result_);
SynapseDesktopFileInfoEnvironmentType synapse_desktop_file_service_get_environment (SynapseDesktopFileService* self);
static gchar* synapse_desktop_file_service_get_cache_file_name (SynapseDesktopFileService* self, const gchar* dir_name);
static void synapse_desktop_file_service_process_directory_data_free (gpointer _data);
static void synapse_desktop_file_service_process_directory (SynapseDesktopFileService* self, GFile* directory, const gchar* id_prefix, GeeSet* monitored_dirs, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void synapse_desktop_file_service_process_directory_finish (SynapseDesktopFileService* self, GAsyncResult* _res_);
static gboolean synapse_desktop_file_service_process_directory_co (SynapseDesktopFileServiceProcessDirectoryData* _data_);
void synapse_utils_logger_debug (GObject* obj, const gchar* format, ...);
void synapse_utils_query_exists_async (GFile* f, GAsyncReadyCallback _callback_, gpointer _user_data_);
gboolean synapse_utils_query_exists_finish (GAsyncResult* _res_);
static void synapse_desktop_file_service_process_directory_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void synapse_desktop_file_service_load_desktop_file (SynapseDesktopFileService* self, GFile* file, const gchar* id_prefix, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void synapse_desktop_file_service_load_desktop_file_finish (SynapseDesktopFileService* self, GAsyncResult* _res_);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void synapse_desktop_file_service_load_all_desktop_files_data_free (gpointer _data);
static gboolean synapse_desktop_file_service_load_all_desktop_files_co (SynapseDesktopFileServiceLoadAllDesktopFilesData* _data_);
static gchar** _vala_array_dup3 (gchar** self, int length);
static void _vala_array_add6 (gchar*** array, int* length, int* size, gchar* value);
static void synapse_desktop_file_service_load_all_desktop_files_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void synapse_desktop_file_service_load_mime_parents_from_file (SynapseDesktopFileService* self, const gchar* fi, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void synapse_desktop_file_service_load_mime_parents_from_file_finish (SynapseDesktopFileService* self, GAsyncResult* _res_);
static void synapse_desktop_file_service_create_indices (SynapseDesktopFileService* self);
static void synapse_desktop_file_service_desktop_file_directory_changed (SynapseDesktopFileService* self);
static void _synapse_desktop_file_service_desktop_file_directory_changed_g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self);
static gboolean __lambda9_ (SynapseDesktopFileService* self);
static void synapse_desktop_file_service_reload_desktop_files (SynapseDesktopFileService* self, GAsyncReadyCallback _callback_, gpointer _user_data_);
static void synapse_desktop_file_service_reload_desktop_files_finish (SynapseDesktopFileService* self, GAsyncResult* _res_);
static gboolean ___lambda9__gsource_func (gpointer self);
static void synapse_desktop_file_service_reload_desktop_files_data_free (gpointer _data);
static gboolean synapse_desktop_file_service_reload_desktop_files_co (SynapseDesktopFileServiceReloadDesktopFilesData* _data_);
static void synapse_desktop_file_service_reload_desktop_files_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void synapse_desktop_file_service_load_desktop_file_data_free (gpointer _data);
static gboolean synapse_desktop_file_service_load_desktop_file_co (SynapseDesktopFileServiceLoadDesktopFileData* _data_);
static void synapse_desktop_file_service_load_desktop_file_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
void synapse_utils_logger_error (GObject* obj, const gchar* format, ...);
static void synapse_desktop_file_service_load_mime_parents_from_file_data_free (gpointer _data);
static gboolean synapse_desktop_file_service_load_mime_parents_from_file_co (SynapseDesktopFileServiceLoadMimeParentsFromFileData* _data_);
static void synapse_desktop_file_service_load_mime_parents_from_file_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_);
static void synapse_desktop_file_service_add_dfi_for_mime (SynapseDesktopFileService* self, const gchar* mime, GeeSet* ret);
GeeList* synapse_desktop_file_service_get_desktop_files (SynapseDesktopFileService* self);
GeeList* synapse_desktop_file_service_get_all_desktop_files (SynapseDesktopFileService* self);
GeeList* synapse_desktop_file_service_get_desktop_files_for_type (SynapseDesktopFileService* self, const gchar* mime_type);
GeeList* synapse_desktop_file_service_get_desktop_files_for_exec (SynapseDesktopFileService* self, const gchar* exec);
SynapseDesktopFileInfo* synapse_desktop_file_service_get_desktop_file_for_id (SynapseDesktopFileService* self, const gchar* desktop_id);
static GObject * synapse_desktop_file_service_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
SynapseUtilsAsyncOnce* synapse_utils_async_once_new (GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
SynapseUtilsAsyncOnce* synapse_utils_async_once_construct (GType object_type, GType g_type, GBoxedCopyFunc g_dup_func, GDestroyNotify g_destroy_func);
static void synapse_desktop_file_service_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GQuark synapse_desktop_file_error_quark (void) {
	return g_quark_from_static_string ("synapse_desktop_file_error-quark");
}


GType synapse_desktop_file_info_environment_type_get_type (void) {
	static volatile gsize synapse_desktop_file_info_environment_type_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_desktop_file_info_environment_type_type_id__volatile)) {
		static const GFlagsValue values[] = {{SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_GNOME, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_GNOME", "gnome"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_KDE, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_KDE", "kde"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_LXDE, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_LXDE", "lxde"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_MATE, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_MATE", "mate"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_RAZOR, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_RAZOR", "razor"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ROX, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ROX", "rox"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_TDE, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_TDE", "tde"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_UNITY, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_UNITY", "unity"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_XFCE, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_XFCE", "xfce"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_PANTHEON, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_PANTHEON", "pantheon"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_OLD, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_OLD", "old"}, {SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ALL, "SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ALL", "all"}, {0, NULL, NULL}};
		GType synapse_desktop_file_info_environment_type_type_id;
		synapse_desktop_file_info_environment_type_type_id = g_flags_register_static ("SynapseDesktopFileInfoEnvironmentType", values);
		g_once_init_leave (&synapse_desktop_file_info_environment_type_type_id__volatile, synapse_desktop_file_info_environment_type_type_id);
	}
	return synapse_desktop_file_info_environment_type_type_id__volatile;
}


const gchar* synapse_desktop_file_info_get_name_folded (SynapseDesktopFileInfo* self) {
	const gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->name_folded;
	if (_tmp0_ == NULL) {
		const gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		_tmp1_ = self->priv->_name;
		_tmp2_ = g_utf8_casefold (_tmp1_, (gssize) -1);
		_g_free0 (self->priv->name_folded);
		self->priv->name_folded = _tmp2_;
	}
	_tmp3_ = self->priv->name_folded;
	result = _tmp3_;
	return result;
}


SynapseDesktopFileInfo* synapse_desktop_file_info_construct_for_keyfile (GType object_type, const gchar* path, GKeyFile* keyfile, const gchar* desktop_id) {
	SynapseDesktopFileInfo * self = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GKeyFile* _tmp2_ = NULL;
	g_return_val_if_fail (path != NULL, NULL);
	g_return_val_if_fail (keyfile != NULL, NULL);
	g_return_val_if_fail (desktop_id != NULL, NULL);
	_tmp0_ = path;
	_tmp1_ = desktop_id;
	self = (SynapseDesktopFileInfo*) g_object_new (object_type, "filename", _tmp0_, "desktop-id", _tmp1_, NULL);
	_tmp2_ = keyfile;
	synapse_desktop_file_info_init_from_keyfile (self, _tmp2_);
	return self;
}


SynapseDesktopFileInfo* synapse_desktop_file_info_new_for_keyfile (const gchar* path, GKeyFile* keyfile, const gchar* desktop_id) {
	return synapse_desktop_file_info_construct_for_keyfile (SYNAPSE_TYPE_DESKTOP_FILE_INFO, path, keyfile, desktop_id);
}


static SynapseDesktopFileInfoEnvironmentType synapse_desktop_file_info_parse_environments (SynapseDesktopFileInfo* self, gchar** environments, int environments_length1) {
	SynapseDesktopFileInfoEnvironmentType result = 0;
	SynapseDesktopFileInfoEnvironmentType _result_ = 0;
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	g_return_val_if_fail (self != NULL, 0);
	_result_ = 0;
	_tmp0_ = environments;
	_tmp0__length1 = environments_length1;
	{
		gchar** env_collection = NULL;
		gint env_collection_length1 = 0;
		gint _env_collection_size_ = 0;
		gint env_it = 0;
		env_collection = _tmp0_;
		env_collection_length1 = _tmp0__length1;
		for (env_it = 0; env_it < _tmp0__length1; env_it = env_it + 1) {
			const gchar* env = NULL;
			env = env_collection[env_it];
			{
				gchar* env_up = NULL;
				const gchar* _tmp1_ = NULL;
				gchar* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				const gchar* _tmp4_ = NULL;
				GQuark _tmp6_ = 0U;
				static GQuark _tmp5_label0 = 0;
				static GQuark _tmp5_label1 = 0;
				static GQuark _tmp5_label2 = 0;
				static GQuark _tmp5_label3 = 0;
				static GQuark _tmp5_label4 = 0;
				static GQuark _tmp5_label5 = 0;
				static GQuark _tmp5_label6 = 0;
				static GQuark _tmp5_label7 = 0;
				static GQuark _tmp5_label8 = 0;
				static GQuark _tmp5_label9 = 0;
				static GQuark _tmp5_label10 = 0;
				_tmp1_ = env;
				_tmp2_ = g_utf8_strup (_tmp1_, (gssize) -1);
				env_up = _tmp2_;
				_tmp3_ = env_up;
				_tmp4_ = _tmp3_;
				_tmp6_ = (NULL == _tmp4_) ? 0 : g_quark_from_string (_tmp4_);
				if (_tmp6_ == ((0 != _tmp5_label0) ? _tmp5_label0 : (_tmp5_label0 = g_quark_from_static_string ("GNOME")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp7_ = 0;
							_tmp7_ = _result_;
							_result_ = _tmp7_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_GNOME;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label1) ? _tmp5_label1 : (_tmp5_label1 = g_quark_from_static_string ("PANTHEON")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp8_ = 0;
							_tmp8_ = _result_;
							_result_ = _tmp8_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_PANTHEON;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label2) ? _tmp5_label2 : (_tmp5_label2 = g_quark_from_static_string ("KDE")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp9_ = 0;
							_tmp9_ = _result_;
							_result_ = _tmp9_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_KDE;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label3) ? _tmp5_label3 : (_tmp5_label3 = g_quark_from_static_string ("LXDE")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp10_ = 0;
							_tmp10_ = _result_;
							_result_ = _tmp10_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_LXDE;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label4) ? _tmp5_label4 : (_tmp5_label4 = g_quark_from_static_string ("MATE")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp11_ = 0;
							_tmp11_ = _result_;
							_result_ = _tmp11_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_MATE;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label5) ? _tmp5_label5 : (_tmp5_label5 = g_quark_from_static_string ("RAZOR")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp12_ = 0;
							_tmp12_ = _result_;
							_result_ = _tmp12_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_RAZOR;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label6) ? _tmp5_label6 : (_tmp5_label6 = g_quark_from_static_string ("ROX")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp13_ = 0;
							_tmp13_ = _result_;
							_result_ = _tmp13_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ROX;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label7) ? _tmp5_label7 : (_tmp5_label7 = g_quark_from_static_string ("TDE")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp14_ = 0;
							_tmp14_ = _result_;
							_result_ = _tmp14_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_TDE;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label8) ? _tmp5_label8 : (_tmp5_label8 = g_quark_from_static_string ("UNITY")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp15_ = 0;
							_tmp15_ = _result_;
							_result_ = _tmp15_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_UNITY;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label9) ? _tmp5_label9 : (_tmp5_label9 = g_quark_from_static_string ("XFCE")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp16_ = 0;
							_tmp16_ = _result_;
							_result_ = _tmp16_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_XFCE;
							break;
						}
					}
				} else if (_tmp6_ == ((0 != _tmp5_label10) ? _tmp5_label10 : (_tmp5_label10 = g_quark_from_static_string ("OLD")))) {
					switch (0) {
						default:
						{
							SynapseDesktopFileInfoEnvironmentType _tmp17_ = 0;
							_tmp17_ = _result_;
							_result_ = _tmp17_ | SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_OLD;
							break;
						}
					}
				} else {
					switch (0) {
						default:
						{
							const gchar* _tmp18_ = NULL;
							_tmp18_ = env;
							g_warning ("desktop-file-service.vala:105: %s is not understood", _tmp18_);
							break;
						}
					}
				}
				_g_free0 (env_up);
			}
		}
	}
	result = _result_;
	return result;
}


static gboolean _vala_string_array_contains (gchar** stack, int stack_length, gchar* needle) {
	int i;
	for (i = 0; i < stack_length; i++) {
		if (g_strcmp0 (stack[i], needle) == 0) {
			return TRUE;
		}
	}
	return FALSE;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void synapse_desktop_file_info_init_from_keyfile (SynapseDesktopFileInfo* self, GKeyFile* keyfile) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (keyfile != NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp7_ = FALSE;
		GKeyFile* _tmp8_ = NULL;
		gboolean _tmp9_ = FALSE;
		GDesktopAppInfo* app_info = NULL;
		GKeyFile* _tmp15_ = NULL;
		GDesktopAppInfo* _tmp16_ = NULL;
		GDesktopAppInfo* _tmp17_ = NULL;
		GDesktopAppInfo* _tmp19_ = NULL;
		const gchar* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		GDesktopAppInfo* _tmp22_ = NULL;
		const gchar* _tmp23_ = NULL;
		GDesktopAppInfo* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		const gchar* _tmp26_ = NULL;
		gboolean _tmp32_ = FALSE;
		gboolean _tmp33_ = FALSE;
		GKeyFile* _tmp34_ = NULL;
		gboolean _tmp35_ = FALSE;
		gboolean _tmp39_ = FALSE;
		gboolean _tmp40_ = FALSE;
		GKeyFile* _tmp41_ = NULL;
		gboolean _tmp42_ = FALSE;
		const gchar* _tmp46_ = NULL;
		GDesktopAppInfo* _tmp47_ = NULL;
		const gchar* _tmp48_ = NULL;
		GIcon* _tmp49_ = NULL;
		GDesktopAppInfo* _tmp50_ = NULL;
		GIcon* _tmp51_ = NULL;
		GIcon* _tmp52_ = NULL;
		GIcon* icon = NULL;
		GIcon* _tmp54_ = NULL;
		GIcon* _tmp55_ = NULL;
		gchar* _tmp56_ = NULL;
		gchar* _tmp57_ = NULL;
		gboolean _tmp58_ = FALSE;
		GKeyFile* _tmp59_ = NULL;
		gboolean _tmp60_ = FALSE;
		gboolean _tmp66_ = FALSE;
		GKeyFile* _tmp67_ = NULL;
		gboolean _tmp68_ = FALSE;
		gboolean _tmp72_ = FALSE;
		GKeyFile* _tmp73_ = NULL;
		gboolean _tmp74_ = FALSE;
		gboolean _tmp89_ = FALSE;
		const gchar* _tmp90_ = NULL;
		gboolean _tmp91_ = FALSE;
		_tmp1_ = keyfile;
		_tmp2_ = g_key_file_get_string (_tmp1_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "Type", &_inner_error_);
		_tmp0_ = _tmp2_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch34_g_error;
		}
		_tmp3_ = _tmp0_;
		_tmp0_ = NULL;
		_tmp4_ = _tmp3_;
		_tmp5_ = g_strcmp0 (_tmp4_, "Application") != 0;
		_g_free0 (_tmp4_);
		if (_tmp5_) {
			GError* _tmp6_ = NULL;
			_tmp6_ = g_error_new_literal (SYNAPSE_DESKTOP_FILE_ERROR, SYNAPSE_DESKTOP_FILE_ERROR_UNINTERESTING_ENTRY, "Not Application-type desktop entry");
			_inner_error_ = _tmp6_;
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		_tmp8_ = keyfile;
		_tmp9_ = g_key_file_has_key (_tmp8_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "Categories", &_inner_error_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		if (_tmp7_) {
			gchar** categories = NULL;
			GKeyFile* _tmp10_ = NULL;
			gsize _tmp11_;
			gchar** _tmp12_ = NULL;
			gint categories_length1 = 0;
			gint _categories_size_ = 0;
			gchar** _tmp13_ = NULL;
			gint _tmp13__length1 = 0;
			_tmp10_ = keyfile;
			_tmp12_ = g_key_file_get_string_list (_tmp10_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "Categories", &_tmp11_, &_inner_error_);
			categories = _tmp12_;
			categories_length1 = _tmp11_;
			_categories_size_ = categories_length1;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			_tmp13_ = categories;
			_tmp13__length1 = categories_length1;
			if (_vala_string_array_contains (_tmp13_, _tmp13__length1, "Screensaver")) {
				GError* _tmp14_ = NULL;
				_tmp14_ = g_error_new_literal (SYNAPSE_DESKTOP_FILE_ERROR, SYNAPSE_DESKTOP_FILE_ERROR_UNINTERESTING_ENTRY, "Screensaver desktop entry");
				_inner_error_ = _tmp14_;
				categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			categories = (_vala_array_free (categories, categories_length1, (GDestroyNotify) g_free), NULL);
		}
		_tmp15_ = keyfile;
		_tmp16_ = g_desktop_app_info_new_from_keyfile (_tmp15_);
		_g_object_unref0 (app_info);
		app_info = _tmp16_;
		_tmp17_ = app_info;
		if (_tmp17_ == NULL) {
			GError* _tmp18_ = NULL;
			_tmp18_ = g_error_new_literal (SYNAPSE_DESKTOP_FILE_ERROR, SYNAPSE_DESKTOP_FILE_ERROR_UNINTERESTING_ENTRY, "Unable to create AppInfo");
			_inner_error_ = _tmp18_;
			_g_object_unref0 (app_info);
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		_tmp19_ = app_info;
		_tmp20_ = g_app_info_get_name ((GAppInfo*) _tmp19_);
		synapse_desktop_file_info_set_name (self, _tmp20_);
		_tmp22_ = app_info;
		_tmp23_ = g_desktop_app_info_get_generic_name (_tmp22_);
		_tmp21_ = _tmp23_;
		if (_tmp21_ == NULL) {
			_tmp21_ = "";
		}
		synapse_desktop_file_info_set_generic_name (self, _tmp21_);
		_tmp24_ = app_info;
		_tmp25_ = g_app_info_get_commandline ((GAppInfo*) _tmp24_);
		synapse_desktop_file_info_set_exec (self, _tmp25_);
		_tmp26_ = self->priv->_exec;
		if (_tmp26_ == NULL) {
			const gchar* _tmp27_ = NULL;
			gchar* _tmp28_ = NULL;
			gchar* _tmp29_ = NULL;
			GError* _tmp30_ = NULL;
			GError* _tmp31_ = NULL;
			_tmp27_ = self->priv->_name;
			_tmp28_ = g_strdup_printf ("Unable to get exec for %s", _tmp27_);
			_tmp29_ = _tmp28_;
			_tmp30_ = g_error_new_literal (SYNAPSE_DESKTOP_FILE_ERROR, SYNAPSE_DESKTOP_FILE_ERROR_UNINTERESTING_ENTRY, _tmp29_);
			_tmp31_ = _tmp30_;
			_g_free0 (_tmp29_);
			_inner_error_ = _tmp31_;
			_g_object_unref0 (app_info);
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		_tmp34_ = keyfile;
		_tmp35_ = g_key_file_has_key (_tmp34_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "Hidden", &_inner_error_);
		_tmp33_ = _tmp35_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (app_info);
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		if (_tmp33_) {
			gboolean _tmp36_ = FALSE;
			GKeyFile* _tmp37_ = NULL;
			gboolean _tmp38_ = FALSE;
			_tmp37_ = keyfile;
			_tmp38_ = g_key_file_get_boolean (_tmp37_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "Hidden", &_inner_error_);
			_tmp36_ = _tmp38_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (app_info);
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			_tmp32_ = _tmp36_;
		} else {
			_tmp32_ = FALSE;
		}
		if (_tmp32_) {
			synapse_desktop_file_info_set_is_hidden (self, TRUE);
		}
		_tmp41_ = keyfile;
		_tmp42_ = g_key_file_has_key (_tmp41_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "NoDisplay", &_inner_error_);
		_tmp40_ = _tmp42_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (app_info);
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		if (_tmp40_) {
			gboolean _tmp43_ = FALSE;
			GKeyFile* _tmp44_ = NULL;
			gboolean _tmp45_ = FALSE;
			_tmp44_ = keyfile;
			_tmp45_ = g_key_file_get_boolean (_tmp44_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "NoDisplay", &_inner_error_);
			_tmp43_ = _tmp45_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (app_info);
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			_tmp39_ = _tmp43_;
		} else {
			_tmp39_ = FALSE;
		}
		if (_tmp39_) {
			synapse_desktop_file_info_set_is_hidden (self, TRUE);
		}
		_tmp47_ = app_info;
		_tmp48_ = g_app_info_get_description ((GAppInfo*) _tmp47_);
		_tmp46_ = _tmp48_;
		if (_tmp46_ == NULL) {
			_tmp46_ = "";
		}
		synapse_desktop_file_info_set_comment (self, _tmp46_);
		_tmp50_ = app_info;
		_tmp51_ = g_app_info_get_icon ((GAppInfo*) _tmp50_);
		_tmp52_ = _g_object_ref0 (_tmp51_);
		_tmp49_ = _tmp52_;
		if (_tmp49_ == NULL) {
			GThemedIcon* _tmp53_ = NULL;
			_tmp53_ = (GThemedIcon*) g_themed_icon_new ("application-default-icon");
			_g_object_unref0 (_tmp49_);
			_tmp49_ = (GIcon*) _tmp53_;
		}
		_tmp54_ = _tmp49_;
		_tmp49_ = NULL;
		icon = _tmp54_;
		_tmp55_ = icon;
		_tmp56_ = g_icon_to_string (_tmp55_);
		_tmp57_ = _tmp56_;
		synapse_desktop_file_info_set_icon_name (self, _tmp57_);
		_g_free0 (_tmp57_);
		_tmp59_ = keyfile;
		_tmp60_ = g_key_file_has_key (_tmp59_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "MimeType", &_inner_error_);
		_tmp58_ = _tmp60_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (icon);
			_g_object_unref0 (_tmp49_);
			_g_object_unref0 (app_info);
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		if (_tmp58_) {
			gchar** _tmp61_ = NULL;
			GKeyFile* _tmp62_ = NULL;
			gsize _tmp63_;
			gchar** _tmp64_ = NULL;
			gint _tmp61__length1 = 0;
			gint __tmp61__size_ = 0;
			gchar** _tmp65_ = NULL;
			gint _tmp65__length1 = 0;
			_tmp62_ = keyfile;
			_tmp64_ = g_key_file_get_string_list (_tmp62_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "MimeType", &_tmp63_, &_inner_error_);
			_tmp61_ = _tmp64_;
			_tmp61__length1 = _tmp63_;
			__tmp61__size_ = _tmp61__length1;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (icon);
				_g_object_unref0 (_tmp49_);
				_g_object_unref0 (app_info);
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			_tmp65_ = _tmp61_;
			_tmp65__length1 = _tmp61__length1;
			_tmp61_ = NULL;
			_tmp61__length1 = 0;
			self->mime_types = (_vala_array_free (self->mime_types, self->mime_types_length1, (GDestroyNotify) g_free), NULL);
			self->mime_types = _tmp65_;
			self->mime_types_length1 = _tmp65__length1;
			_tmp61_ = (_vala_array_free (_tmp61_, _tmp61__length1, (GDestroyNotify) g_free), NULL);
		}
		_tmp67_ = keyfile;
		_tmp68_ = g_key_file_has_key (_tmp67_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "Terminal", &_inner_error_);
		_tmp66_ = _tmp68_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (icon);
			_g_object_unref0 (_tmp49_);
			_g_object_unref0 (app_info);
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		if (_tmp66_) {
			gboolean _tmp69_ = FALSE;
			GKeyFile* _tmp70_ = NULL;
			gboolean _tmp71_ = FALSE;
			_tmp70_ = keyfile;
			_tmp71_ = g_key_file_get_boolean (_tmp70_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "Terminal", &_inner_error_);
			_tmp69_ = _tmp71_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (icon);
				_g_object_unref0 (_tmp49_);
				_g_object_unref0 (app_info);
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			synapse_desktop_file_info_set_needs_terminal (self, _tmp69_);
		}
		_tmp73_ = keyfile;
		_tmp74_ = g_key_file_has_key (_tmp73_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "OnlyShowIn", &_inner_error_);
		_tmp72_ = _tmp74_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (icon);
			_g_object_unref0 (_tmp49_);
			_g_object_unref0 (app_info);
			_g_free0 (_tmp0_);
			goto __catch34_g_error;
		}
		if (_tmp72_) {
			gchar** _tmp75_ = NULL;
			GKeyFile* _tmp76_ = NULL;
			gsize _tmp77_;
			gchar** _tmp78_ = NULL;
			gint _tmp75__length1 = 0;
			gint __tmp75__size_ = 0;
			SynapseDesktopFileInfoEnvironmentType _tmp79_ = 0;
			_tmp76_ = keyfile;
			_tmp78_ = g_key_file_get_string_list (_tmp76_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "OnlyShowIn", &_tmp77_, &_inner_error_);
			_tmp75_ = _tmp78_;
			_tmp75__length1 = _tmp77_;
			__tmp75__size_ = _tmp75__length1;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (icon);
				_g_object_unref0 (_tmp49_);
				_g_object_unref0 (app_info);
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			_tmp79_ = synapse_desktop_file_info_parse_environments (self, _tmp75_, _tmp75__length1);
			synapse_desktop_file_info_set_show_in (self, _tmp79_);
			_tmp75_ = (_vala_array_free (_tmp75_, _tmp75__length1, (GDestroyNotify) g_free), NULL);
		} else {
			gboolean _tmp80_ = FALSE;
			GKeyFile* _tmp81_ = NULL;
			gboolean _tmp82_ = FALSE;
			_tmp81_ = keyfile;
			_tmp82_ = g_key_file_has_key (_tmp81_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "NotShowIn", &_inner_error_);
			_tmp80_ = _tmp82_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_object_unref0 (icon);
				_g_object_unref0 (_tmp49_);
				_g_object_unref0 (app_info);
				_g_free0 (_tmp0_);
				goto __catch34_g_error;
			}
			if (_tmp80_) {
				gchar** _tmp83_ = NULL;
				GKeyFile* _tmp84_ = NULL;
				gsize _tmp85_;
				gchar** _tmp86_ = NULL;
				gint _tmp83__length1 = 0;
				gint __tmp83__size_ = 0;
				SynapseDesktopFileInfoEnvironmentType not_show = 0;
				SynapseDesktopFileInfoEnvironmentType _tmp87_ = 0;
				SynapseDesktopFileInfoEnvironmentType _tmp88_ = 0;
				_tmp84_ = keyfile;
				_tmp86_ = g_key_file_get_string_list (_tmp84_, SYNAPSE_DESKTOP_FILE_INFO_GROUP, "NotShowIn", &_tmp85_, &_inner_error_);
				_tmp83_ = _tmp86_;
				_tmp83__length1 = _tmp85_;
				__tmp83__size_ = _tmp83__length1;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					_g_object_unref0 (icon);
					_g_object_unref0 (_tmp49_);
					_g_object_unref0 (app_info);
					_g_free0 (_tmp0_);
					goto __catch34_g_error;
				}
				_tmp87_ = synapse_desktop_file_info_parse_environments (self, _tmp83_, _tmp83__length1);
				not_show = _tmp87_;
				_tmp88_ = not_show;
				synapse_desktop_file_info_set_show_in (self, SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ALL ^ _tmp88_);
				_tmp83_ = (_vala_array_free (_tmp83_, _tmp83__length1, (GDestroyNotify) g_free), NULL);
			}
		}
		_tmp90_ = self->priv->_filename;
		_tmp91_ = g_str_has_suffix (_tmp90_, "gconf-editor.desktop");
		if (_tmp91_) {
			_tmp89_ = TRUE;
		} else {
			const gchar* _tmp92_ = NULL;
			gboolean _tmp93_ = FALSE;
			_tmp92_ = self->priv->_filename;
			_tmp93_ = g_str_has_suffix (_tmp92_, "dconf-editor.desktop");
			_tmp89_ = _tmp93_;
		}
		if (_tmp89_) {
			synapse_desktop_file_info_set_is_hidden (self, FALSE);
		}
		_g_object_unref0 (icon);
		_g_object_unref0 (_tmp49_);
		_g_object_unref0 (app_info);
		_g_free0 (_tmp0_);
	}
	goto __finally34;
	__catch34_g_error:
	{
		GError* err = NULL;
		GError* _tmp94_ = NULL;
		const gchar* _tmp95_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp94_ = err;
		_tmp95_ = _tmp94_->message;
		synapse_utils_logger_warning ((GObject*) self, "%s", _tmp95_, NULL);
		synapse_desktop_file_info_set_is_valid (self, FALSE);
		_g_error_free0 (err);
	}
	__finally34:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
}


SynapseDesktopFileInfo* synapse_desktop_file_info_construct (GType object_type) {
	SynapseDesktopFileInfo * self = NULL;
	self = (SynapseDesktopFileInfo*) g_object_new (object_type, NULL);
	return self;
}


SynapseDesktopFileInfo* synapse_desktop_file_info_new (void) {
	return synapse_desktop_file_info_construct (SYNAPSE_TYPE_DESKTOP_FILE_INFO);
}


const gchar* synapse_desktop_file_info_get_desktop_id (SynapseDesktopFileInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_desktop_id;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_desktop_id (SynapseDesktopFileInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_desktop_id);
	self->priv->_desktop_id = _tmp1_;
	g_object_notify ((GObject *) self, "desktop-id");
}


const gchar* synapse_desktop_file_info_get_name (SynapseDesktopFileInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_name;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_name (SynapseDesktopFileInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_name);
	self->priv->_name = _tmp1_;
	g_object_notify ((GObject *) self, "name");
}


const gchar* synapse_desktop_file_info_get_generic_name (SynapseDesktopFileInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_generic_name;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_generic_name (SynapseDesktopFileInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_generic_name);
	self->priv->_generic_name = _tmp1_;
	g_object_notify ((GObject *) self, "generic-name");
}


const gchar* synapse_desktop_file_info_get_comment (SynapseDesktopFileInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_comment;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_comment (SynapseDesktopFileInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_comment);
	self->priv->_comment = _tmp1_;
	g_object_notify ((GObject *) self, "comment");
}


const gchar* synapse_desktop_file_info_get_icon_name (SynapseDesktopFileInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_icon_name;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_icon_name (SynapseDesktopFileInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_icon_name);
	self->priv->_icon_name = _tmp1_;
	g_object_notify ((GObject *) self, "icon-name");
}


gboolean synapse_desktop_file_info_get_needs_terminal (SynapseDesktopFileInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_needs_terminal;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_needs_terminal (SynapseDesktopFileInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_needs_terminal = _tmp0_;
	g_object_notify ((GObject *) self, "needs-terminal");
}


const gchar* synapse_desktop_file_info_get_filename (SynapseDesktopFileInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_filename;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_filename (SynapseDesktopFileInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_filename);
	self->priv->_filename = _tmp1_;
	g_object_notify ((GObject *) self, "filename");
}


const gchar* synapse_desktop_file_info_get_exec (SynapseDesktopFileInfo* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_exec;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_exec (SynapseDesktopFileInfo* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_exec);
	self->priv->_exec = _tmp1_;
	g_object_notify ((GObject *) self, "exec");
}


gboolean synapse_desktop_file_info_get_is_hidden (SynapseDesktopFileInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_hidden;
	result = _tmp0_;
	return result;
}


static void synapse_desktop_file_info_set_is_hidden (SynapseDesktopFileInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_is_hidden = _tmp0_;
	g_object_notify ((GObject *) self, "is-hidden");
}


gboolean synapse_desktop_file_info_get_is_valid (SynapseDesktopFileInfo* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_is_valid;
	result = _tmp0_;
	return result;
}


static void synapse_desktop_file_info_set_is_valid (SynapseDesktopFileInfo* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_is_valid = _tmp0_;
	g_object_notify ((GObject *) self, "is-valid");
}


SynapseDesktopFileInfoEnvironmentType synapse_desktop_file_info_get_show_in (SynapseDesktopFileInfo* self) {
	SynapseDesktopFileInfoEnvironmentType result;
	SynapseDesktopFileInfoEnvironmentType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_show_in;
	result = _tmp0_;
	return result;
}


void synapse_desktop_file_info_set_show_in (SynapseDesktopFileInfo* self, SynapseDesktopFileInfoEnvironmentType value) {
	SynapseDesktopFileInfoEnvironmentType _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_show_in = _tmp0_;
	g_object_notify ((GObject *) self, "show-in");
}


static void synapse_desktop_file_info_class_init (SynapseDesktopFileInfoClass * klass) {
	synapse_desktop_file_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SynapseDesktopFileInfoPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_synapse_desktop_file_info_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_synapse_desktop_file_info_set_property;
	G_OBJECT_CLASS (klass)->finalize = synapse_desktop_file_info_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_DESKTOP_ID, g_param_spec_string ("desktop-id", "desktop-id", "desktop-id", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_NAME, g_param_spec_string ("name", "name", "name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_GENERIC_NAME, g_param_spec_string ("generic-name", "generic-name", "generic-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_COMMENT, g_param_spec_string ("comment", "comment", "comment", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_ICON_NAME, g_param_spec_string ("icon-name", "icon-name", "icon-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_NEEDS_TERMINAL, g_param_spec_boolean ("needs-terminal", "needs-terminal", "needs-terminal", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_FILENAME, g_param_spec_string ("filename", "filename", "filename", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_EXEC, g_param_spec_string ("exec", "exec", "exec", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_IS_HIDDEN, g_param_spec_boolean ("is-hidden", "is-hidden", "is-hidden", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_IS_VALID, g_param_spec_boolean ("is-valid", "is-valid", "is-valid", TRUE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), SYNAPSE_DESKTOP_FILE_INFO_SHOW_IN, g_param_spec_flags ("show-in", "show-in", "show-in", SYNAPSE_DESKTOP_FILE_INFO_TYPE_ENVIRONMENT_TYPE, SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ALL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void synapse_desktop_file_info_instance_init (SynapseDesktopFileInfo * self) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	self->priv = SYNAPSE_DESKTOP_FILE_INFO_GET_PRIVATE (self);
	_tmp0_ = g_strdup ("");
	self->priv->_comment = _tmp0_;
	_tmp1_ = g_strdup ("");
	self->priv->_icon_name = _tmp1_;
	self->priv->_needs_terminal = FALSE;
	self->priv->_is_hidden = FALSE;
	self->priv->_is_valid = TRUE;
	self->mime_types = NULL;
	self->mime_types_length1 = 0;
	self->priv->name_folded = NULL;
	self->priv->_show_in = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ALL;
}


static void synapse_desktop_file_info_finalize (GObject* obj) {
	SynapseDesktopFileInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYNAPSE_TYPE_DESKTOP_FILE_INFO, SynapseDesktopFileInfo);
	_g_free0 (self->priv->_desktop_id);
	_g_free0 (self->priv->_name);
	_g_free0 (self->priv->_generic_name);
	_g_free0 (self->priv->_comment);
	_g_free0 (self->priv->_icon_name);
	_g_free0 (self->priv->_filename);
	_g_free0 (self->priv->_exec);
	self->mime_types = (_vala_array_free (self->mime_types, self->mime_types_length1, (GDestroyNotify) g_free), NULL);
	_g_free0 (self->priv->name_folded);
	G_OBJECT_CLASS (synapse_desktop_file_info_parent_class)->finalize (obj);
}


GType synapse_desktop_file_info_get_type (void) {
	static volatile gsize synapse_desktop_file_info_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_desktop_file_info_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SynapseDesktopFileInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_desktop_file_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SynapseDesktopFileInfo), 0, (GInstanceInitFunc) synapse_desktop_file_info_instance_init, NULL };
		GType synapse_desktop_file_info_type_id;
		synapse_desktop_file_info_type_id = g_type_register_static (G_TYPE_OBJECT, "SynapseDesktopFileInfo", &g_define_type_info, 0);
		g_once_init_leave (&synapse_desktop_file_info_type_id__volatile, synapse_desktop_file_info_type_id);
	}
	return synapse_desktop_file_info_type_id__volatile;
}


static void _vala_synapse_desktop_file_info_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	SynapseDesktopFileInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SYNAPSE_TYPE_DESKTOP_FILE_INFO, SynapseDesktopFileInfo);
	switch (property_id) {
		case SYNAPSE_DESKTOP_FILE_INFO_DESKTOP_ID:
		g_value_set_string (value, synapse_desktop_file_info_get_desktop_id (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_NAME:
		g_value_set_string (value, synapse_desktop_file_info_get_name (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_GENERIC_NAME:
		g_value_set_string (value, synapse_desktop_file_info_get_generic_name (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_COMMENT:
		g_value_set_string (value, synapse_desktop_file_info_get_comment (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_ICON_NAME:
		g_value_set_string (value, synapse_desktop_file_info_get_icon_name (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_NEEDS_TERMINAL:
		g_value_set_boolean (value, synapse_desktop_file_info_get_needs_terminal (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_FILENAME:
		g_value_set_string (value, synapse_desktop_file_info_get_filename (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_EXEC:
		g_value_set_string (value, synapse_desktop_file_info_get_exec (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_IS_HIDDEN:
		g_value_set_boolean (value, synapse_desktop_file_info_get_is_hidden (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_IS_VALID:
		g_value_set_boolean (value, synapse_desktop_file_info_get_is_valid (self));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_SHOW_IN:
		g_value_set_flags (value, synapse_desktop_file_info_get_show_in (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_synapse_desktop_file_info_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	SynapseDesktopFileInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, SYNAPSE_TYPE_DESKTOP_FILE_INFO, SynapseDesktopFileInfo);
	switch (property_id) {
		case SYNAPSE_DESKTOP_FILE_INFO_DESKTOP_ID:
		synapse_desktop_file_info_set_desktop_id (self, g_value_get_string (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_NAME:
		synapse_desktop_file_info_set_name (self, g_value_get_string (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_GENERIC_NAME:
		synapse_desktop_file_info_set_generic_name (self, g_value_get_string (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_COMMENT:
		synapse_desktop_file_info_set_comment (self, g_value_get_string (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_ICON_NAME:
		synapse_desktop_file_info_set_icon_name (self, g_value_get_string (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_NEEDS_TERMINAL:
		synapse_desktop_file_info_set_needs_terminal (self, g_value_get_boolean (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_FILENAME:
		synapse_desktop_file_info_set_filename (self, g_value_get_string (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_EXEC:
		synapse_desktop_file_info_set_exec (self, g_value_get_string (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_IS_HIDDEN:
		synapse_desktop_file_info_set_is_hidden (self, g_value_get_boolean (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_IS_VALID:
		synapse_desktop_file_info_set_is_valid (self, g_value_get_boolean (value));
		break;
		case SYNAPSE_DESKTOP_FILE_INFO_SHOW_IN:
		synapse_desktop_file_info_set_show_in (self, g_value_get_flags (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


SynapseDesktopFileService* synapse_desktop_file_service_get_default (void) {
	SynapseDesktopFileService* result = NULL;
	SynapseDesktopFileService* _tmp0_ = NULL;
	SynapseDesktopFileService* _tmp1_ = NULL;
	SynapseDesktopFileService* _tmp2_ = NULL;
	SynapseDesktopFileService* _tmp4_ = NULL;
	_tmp1_ = synapse_desktop_file_service_instance;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_tmp0_ = _tmp2_;
	if (_tmp0_ == NULL) {
		SynapseDesktopFileService* _tmp3_ = NULL;
		_tmp3_ = synapse_desktop_file_service_new ();
		_g_object_unref0 (_tmp0_);
		_tmp0_ = _tmp3_;
	}
	_tmp4_ = _tmp0_;
	_tmp0_ = NULL;
	result = _tmp4_;
	_g_object_unref0 (_tmp0_);
	return result;
}


static SynapseDesktopFileService* synapse_desktop_file_service_construct (GType object_type) {
	SynapseDesktopFileService * self = NULL;
	self = (SynapseDesktopFileService*) g_object_new (object_type, NULL);
	return self;
}


static SynapseDesktopFileService* synapse_desktop_file_service_new (void) {
	return synapse_desktop_file_service_construct (SYNAPSE_TYPE_DESKTOP_FILE_SERVICE);
}


static void synapse_desktop_file_service_initialize_data_free (gpointer _data) {
	SynapseDesktopFileServiceInitializeData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (SynapseDesktopFileServiceInitializeData, _data_);
}


void synapse_desktop_file_service_initialize (SynapseDesktopFileService* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseDesktopFileServiceInitializeData* _data_;
	SynapseDesktopFileService* _tmp0_ = NULL;
	_data_ = g_slice_new0 (SynapseDesktopFileServiceInitializeData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, synapse_desktop_file_service_initialize);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_desktop_file_service_initialize_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	synapse_desktop_file_service_initialize_co (_data_);
}


void synapse_desktop_file_service_initialize_finish (SynapseDesktopFileService* self, GAsyncResult* _res_) {
	SynapseDesktopFileServiceInitializeData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void synapse_desktop_file_service_initialize_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseDesktopFileServiceInitializeData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_desktop_file_service_initialize_co (_data_);
}


static gboolean _synapse_desktop_file_service_initialize_co_gsource_func (gpointer self) {
	gboolean result;
	result = synapse_desktop_file_service_initialize_co (self);
	return result;
}


static gboolean synapse_desktop_file_service_initialize_co (SynapseDesktopFileServiceInitializeData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->init_once;
	_data_->_tmp1_ = FALSE;
	_data_->_tmp1_ = synapse_utils_async_once_is_initialized (_data_->_tmp0_);
	if (_data_->_tmp1_) {
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->self->priv->init_once;
	_data_->_state_ = 1;
	synapse_utils_async_once_enter (_data_->_tmp2_, synapse_desktop_file_service_initialize_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp3_ = FALSE;
	_data_->_tmp3_ = synapse_utils_async_once_enter_finish (_data_->_tmp2_, _data_->_res_);
	_data_->is_locked = _data_->_tmp3_;
	_data_->_tmp4_ = FALSE;
	_data_->_tmp4_ = _data_->is_locked;
	if (!_data_->_tmp4_) {
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	synapse_desktop_file_service_get_environment_type (_data_->self);
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = _data_->self->priv->session_type_str;
	g_desktop_app_info_set_desktop_env (_data_->_tmp5_);
	g_idle_add_full (G_PRIORITY_LOW, _synapse_desktop_file_service_initialize_co_gsource_func, _data_, NULL);
	_data_->_state_ = 2;
	return FALSE;
	_state_2:
	;
	_data_->_state_ = 3;
	synapse_desktop_file_service_load_all_desktop_files (_data_->self, synapse_desktop_file_service_initialize_ready, _data_);
	return FALSE;
	_state_3:
	synapse_desktop_file_service_load_all_desktop_files_finish (_data_->self, _data_->_res_);
	_data_->_tmp6_ = NULL;
	_data_->_tmp6_ = _data_->self->priv->init_once;
	synapse_utils_async_once_leave (_data_->_tmp6_, (gpointer) ((gintptr) TRUE));
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


SynapseDesktopFileInfoEnvironmentType synapse_desktop_file_service_get_environment (SynapseDesktopFileService* self) {
	SynapseDesktopFileInfoEnvironmentType result = 0;
	SynapseDesktopFileInfoEnvironmentType _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->session_type;
	result = _tmp0_;
	return result;
}


static void synapse_desktop_file_service_get_environment_type (SynapseDesktopFileService* self) {
	const gchar* session_var = NULL;
	const gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* session = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gboolean _tmp6_ = FALSE;
	const gchar* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_getenv ("XDG_CURRENT_DESKTOP");
	session_var = _tmp0_;
	_tmp1_ = session_var;
	if (_tmp1_ == NULL) {
		const gchar* _tmp2_ = NULL;
		_tmp2_ = g_getenv ("DESKTOP_SESSION");
		session_var = _tmp2_;
	}
	_tmp3_ = session_var;
	if (_tmp3_ == NULL) {
		return;
	}
	_tmp4_ = session_var;
	_tmp5_ = g_utf8_strdown (_tmp4_, (gssize) -1);
	session = _tmp5_;
	_tmp7_ = session;
	_tmp8_ = g_str_has_prefix (_tmp7_, "unity");
	if (_tmp8_) {
		_tmp6_ = TRUE;
	} else {
		const gchar* _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		_tmp9_ = session;
		_tmp10_ = g_str_has_prefix (_tmp9_, "ubuntu");
		_tmp6_ = _tmp10_;
	}
	if (_tmp6_) {
		gchar* _tmp11_ = NULL;
		self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_UNITY;
		_tmp11_ = g_strdup ("Unity");
		_g_free0 (self->priv->session_type_str);
		self->priv->session_type_str = _tmp11_;
	} else {
		const gchar* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		_tmp12_ = session;
		_tmp13_ = g_str_has_prefix (_tmp12_, "kde");
		if (_tmp13_) {
			gchar* _tmp14_ = NULL;
			self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_KDE;
			_tmp14_ = g_strdup ("KDE");
			_g_free0 (self->priv->session_type_str);
			self->priv->session_type_str = _tmp14_;
		} else {
			const gchar* _tmp15_ = NULL;
			gboolean _tmp16_ = FALSE;
			_tmp15_ = session;
			_tmp16_ = g_str_has_prefix (_tmp15_, "gnome");
			if (_tmp16_) {
				gchar* _tmp17_ = NULL;
				self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_GNOME;
				_tmp17_ = g_strdup ("GNOME");
				_g_free0 (self->priv->session_type_str);
				self->priv->session_type_str = _tmp17_;
			} else {
				const gchar* _tmp18_ = NULL;
				gboolean _tmp19_ = FALSE;
				_tmp18_ = session;
				_tmp19_ = g_str_has_prefix (_tmp18_, "lx");
				if (_tmp19_) {
					gchar* _tmp20_ = NULL;
					self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_LXDE;
					_tmp20_ = g_strdup ("LXDE");
					_g_free0 (self->priv->session_type_str);
					self->priv->session_type_str = _tmp20_;
				} else {
					const gchar* _tmp21_ = NULL;
					gboolean _tmp22_ = FALSE;
					_tmp21_ = session;
					_tmp22_ = g_str_has_prefix (_tmp21_, "xfce");
					if (_tmp22_) {
						gchar* _tmp23_ = NULL;
						self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_XFCE;
						_tmp23_ = g_strdup ("XFCE");
						_g_free0 (self->priv->session_type_str);
						self->priv->session_type_str = _tmp23_;
					} else {
						const gchar* _tmp24_ = NULL;
						gboolean _tmp25_ = FALSE;
						_tmp24_ = session;
						_tmp25_ = g_str_has_prefix (_tmp24_, "mate");
						if (_tmp25_) {
							gchar* _tmp26_ = NULL;
							self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_MATE;
							_tmp26_ = g_strdup ("MATE");
							_g_free0 (self->priv->session_type_str);
							self->priv->session_type_str = _tmp26_;
						} else {
							const gchar* _tmp27_ = NULL;
							gboolean _tmp28_ = FALSE;
							_tmp27_ = session;
							_tmp28_ = g_str_has_prefix (_tmp27_, "razor");
							if (_tmp28_) {
								gchar* _tmp29_ = NULL;
								self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_RAZOR;
								_tmp29_ = g_strdup ("Razor");
								_g_free0 (self->priv->session_type_str);
								self->priv->session_type_str = _tmp29_;
							} else {
								const gchar* _tmp30_ = NULL;
								gboolean _tmp31_ = FALSE;
								_tmp30_ = session;
								_tmp31_ = g_str_has_prefix (_tmp30_, "tde");
								if (_tmp31_) {
									gchar* _tmp32_ = NULL;
									self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_TDE;
									_tmp32_ = g_strdup ("TDE");
									_g_free0 (self->priv->session_type_str);
									self->priv->session_type_str = _tmp32_;
								} else {
									const gchar* _tmp33_ = NULL;
									gboolean _tmp34_ = FALSE;
									_tmp33_ = session;
									_tmp34_ = g_str_has_prefix (_tmp33_, "rox");
									if (_tmp34_) {
										gchar* _tmp35_ = NULL;
										self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_ROX;
										_tmp35_ = g_strdup ("ROX");
										_g_free0 (self->priv->session_type_str);
										self->priv->session_type_str = _tmp35_;
									} else {
										const gchar* _tmp36_ = NULL;
										gboolean _tmp37_ = FALSE;
										_tmp36_ = session;
										_tmp37_ = g_str_has_prefix (_tmp36_, "pantheon");
										if (_tmp37_) {
											gchar* _tmp38_ = NULL;
											self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_PANTHEON;
											_tmp38_ = g_strdup ("Pantheon");
											_g_free0 (self->priv->session_type_str);
											self->priv->session_type_str = _tmp38_;
										} else {
											g_warning ("desktop-file-service.vala:331: Desktop session type is not recognized," \
" assuming GNOME.");
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_g_free0 (session);
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch35_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) -1, 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch35_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp9_ = _tmp5_;
		_tmp5_ = NULL;
		result = _tmp9_;
		_g_free0 (_tmp5_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally35;
	__catch35_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally35:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* synapse_desktop_file_service_get_cache_file_name (SynapseDesktopFileService* self, const gchar* dir_name) {
	gchar* result = NULL;
	gchar* locale = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* filename = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	const gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (dir_name != NULL, NULL);
	_tmp0_ = setlocale (LC_MESSAGES, NULL);
	_tmp1_ = g_strdup (_tmp0_);
	locale = _tmp1_;
	_tmp2_ = locale;
	if (_tmp2_ == NULL) {
		result = NULL;
		_g_free0 (locale);
		return result;
	}
	_tmp3_ = locale;
	_tmp4_ = string_replace (_tmp3_, ".UTF-8", ".utf8");
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strdup_printf ("desktop.%s.cache", _tmp5_);
	_tmp7_ = _tmp6_;
	_g_free0 (_tmp5_);
	filename = _tmp7_;
	_tmp8_ = dir_name;
	_tmp9_ = filename;
	_tmp10_ = g_build_filename (_tmp8_, _tmp9_, NULL, NULL);
	result = _tmp10_;
	_g_free0 (filename);
	_g_free0 (locale);
	return result;
}


static void synapse_desktop_file_service_process_directory_data_free (gpointer _data) {
	SynapseDesktopFileServiceProcessDirectoryData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->directory);
	_g_free0 (_data_->id_prefix);
	_g_object_unref0 (_data_->monitored_dirs);
	_g_object_unref0 (_data_->self);
	g_slice_free (SynapseDesktopFileServiceProcessDirectoryData, _data_);
}


static void synapse_desktop_file_service_process_directory (SynapseDesktopFileService* self, GFile* directory, const gchar* id_prefix, GeeSet* monitored_dirs, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseDesktopFileServiceProcessDirectoryData* _data_;
	SynapseDesktopFileService* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GeeSet* _tmp5_ = NULL;
	GeeSet* _tmp6_ = NULL;
	_data_ = g_slice_new0 (SynapseDesktopFileServiceProcessDirectoryData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, synapse_desktop_file_service_process_directory);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_desktop_file_service_process_directory_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = directory;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->directory);
	_data_->directory = _tmp2_;
	_tmp3_ = id_prefix;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (_data_->id_prefix);
	_data_->id_prefix = _tmp4_;
	_tmp5_ = monitored_dirs;
	_tmp6_ = _g_object_ref0 (_tmp5_);
	_g_object_unref0 (_data_->monitored_dirs);
	_data_->monitored_dirs = _tmp6_;
	synapse_desktop_file_service_process_directory_co (_data_);
}


static void synapse_desktop_file_service_process_directory_finish (SynapseDesktopFileService* self, GAsyncResult* _res_) {
	SynapseDesktopFileServiceProcessDirectoryData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void synapse_desktop_file_service_process_directory_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseDesktopFileServiceProcessDirectoryData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_desktop_file_service_process_directory_co (_data_);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gboolean synapse_desktop_file_service_process_directory_co (SynapseDesktopFileServiceProcessDirectoryData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		case 4:
		goto _state_4;
		case 5:
		goto _state_5;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = NULL;
		_data_->_tmp0_ = _data_->directory;
		_data_->_tmp1_ = NULL;
		_data_->_tmp1_ = g_file_get_path (_data_->_tmp0_);
		_data_->path = _data_->_tmp1_;
		_data_->_tmp3_ = NULL;
		_data_->_tmp3_ = _data_->path;
		if (_data_->_tmp3_ != NULL) {
			_data_->_tmp4_ = NULL;
			_data_->_tmp4_ = _data_->path;
			_data_->_tmp5_ = FALSE;
			_data_->_tmp5_ = g_str_has_suffix (_data_->_tmp4_, "menu-xdg");
			_data_->_tmp2_ = _data_->_tmp5_;
		} else {
			_data_->_tmp2_ = FALSE;
		}
		if (_data_->_tmp2_) {
			_g_free0 (_data_->path);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->_tmp7_ = NULL;
		_data_->_tmp7_ = _data_->path;
		if (_data_->_tmp7_ != NULL) {
			_data_->_tmp8_ = NULL;
			_data_->_tmp8_ = _data_->path;
			_data_->_tmp9_ = FALSE;
			_data_->_tmp9_ = g_str_has_suffix (_data_->_tmp8_, "/screensavers");
			_data_->_tmp6_ = _data_->_tmp9_;
		} else {
			_data_->_tmp6_ = FALSE;
		}
		if (_data_->_tmp6_) {
			_g_free0 (_data_->path);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_data_->_tmp10_ = NULL;
		_data_->_tmp10_ = _data_->path;
		synapse_utils_logger_debug ((GObject*) _data_->self, "desktop-file-service.vala:361: Searching for desktop files in: %s", _data_->_tmp10_, NULL);
		_data_->_tmp11_ = NULL;
		_data_->_tmp11_ = _data_->directory;
		_data_->_state_ = 1;
		synapse_utils_query_exists_async (_data_->_tmp11_, synapse_desktop_file_service_process_directory_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp12_ = FALSE;
		_data_->_tmp12_ = synapse_utils_query_exists_finish (_data_->_res_);
		_data_->exists = _data_->_tmp12_;
		_data_->_tmp13_ = FALSE;
		_data_->_tmp13_ = _data_->exists;
		if (!_data_->_tmp13_) {
			_g_free0 (_data_->path);
			if (_data_->_state_ == 0) {
				g_simple_async_result_complete_in_idle (_data_->_async_result);
			} else {
				g_simple_async_result_complete (_data_->_async_result);
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		{
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = _data_->monitored_dirs;
			_data_->_tmp15_ = NULL;
			_data_->_tmp15_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp14_);
			_data_->_scanned_dir_it = _data_->_tmp15_;
			while (TRUE) {
				_data_->_tmp16_ = NULL;
				_data_->_tmp16_ = _data_->_scanned_dir_it;
				_data_->_tmp17_ = FALSE;
				_data_->_tmp17_ = gee_iterator_next (_data_->_tmp16_);
				if (!_data_->_tmp17_) {
					break;
				}
				_data_->_tmp18_ = NULL;
				_data_->_tmp18_ = _data_->_scanned_dir_it;
				_data_->_tmp19_ = NULL;
				_data_->_tmp19_ = gee_iterator_get (_data_->_tmp18_);
				_data_->scanned_dir = (GFile*) _data_->_tmp19_;
				_data_->_tmp20_ = NULL;
				_data_->_tmp20_ = _data_->path;
				_data_->_tmp21_ = NULL;
				_data_->_tmp21_ = _data_->scanned_dir;
				_data_->_tmp22_ = NULL;
				_data_->_tmp22_ = g_file_get_path (_data_->_tmp21_);
				_data_->_tmp23_ = NULL;
				_data_->_tmp23_ = _data_->_tmp22_;
				_data_->_tmp24_ = FALSE;
				_data_->_tmp24_ = g_strcmp0 (_data_->_tmp20_, _data_->_tmp23_) == 0;
				_g_free0 (_data_->_tmp23_);
				if (_data_->_tmp24_) {
					_g_object_unref0 (_data_->scanned_dir);
					_g_object_unref0 (_data_->_scanned_dir_it);
					_g_free0 (_data_->path);
					if (_data_->_state_ == 0) {
						g_simple_async_result_complete_in_idle (_data_->_async_result);
					} else {
						g_simple_async_result_complete (_data_->_async_result);
					}
					g_object_unref (_data_->_async_result);
					return FALSE;
				}
				_g_object_unref0 (_data_->scanned_dir);
			}
			_g_object_unref0 (_data_->_scanned_dir_it);
		}
		_data_->_tmp25_ = NULL;
		_data_->_tmp25_ = _data_->monitored_dirs;
		_data_->_tmp26_ = NULL;
		_data_->_tmp26_ = _data_->directory;
		gee_collection_add ((GeeCollection*) _data_->_tmp25_, _data_->_tmp26_);
		_data_->_tmp27_ = NULL;
		_data_->_tmp27_ = _data_->directory;
		_data_->_state_ = 2;
		g_file_enumerate_children_async (_data_->_tmp27_, G_FILE_ATTRIBUTE_STANDARD_NAME "," G_FILE_ATTRIBUTE_STANDARD_TYPE, 0, 0, NULL, synapse_desktop_file_service_process_directory_ready, _data_);
		return FALSE;
		_state_2:
		_data_->_tmp28_ = NULL;
		_data_->_tmp28_ = g_file_enumerate_children_finish (_data_->_tmp27_, _data_->_res_, &_data_->_inner_error_);
		_data_->enumerator = _data_->_tmp28_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			_g_free0 (_data_->path);
			goto __catch36_g_error;
		}
		_data_->_tmp29_ = NULL;
		_data_->_tmp29_ = _data_->enumerator;
		_data_->_state_ = 3;
		g_file_enumerator_next_files_async (_data_->_tmp29_, 1024, 0, NULL, synapse_desktop_file_service_process_directory_ready, _data_);
		return FALSE;
		_state_3:
		_data_->_tmp30_ = NULL;
		_data_->_tmp30_ = g_file_enumerator_next_files_finish (_data_->_tmp29_, _data_->_res_, &_data_->_inner_error_);
		_data_->files = _data_->_tmp30_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			_g_object_unref0 (_data_->enumerator);
			_g_free0 (_data_->path);
			goto __catch36_g_error;
		}
		_data_->_tmp31_ = NULL;
		_data_->_tmp31_ = _data_->files;
		{
			_data_->f_collection = _data_->_tmp31_;
			for (_data_->f_it = _data_->f_collection; _data_->f_it != NULL; _data_->f_it = _data_->f_it->next) {
				_data_->_tmp32_ = NULL;
				_data_->_tmp32_ = _g_object_ref0 ((GFileInfo*) _data_->f_it->data);
				_data_->f = _data_->_tmp32_;
				{
					_data_->_tmp33_ = NULL;
					_data_->_tmp33_ = _data_->f;
					_data_->_tmp34_ = NULL;
					_data_->_tmp34_ = g_file_info_get_name (_data_->_tmp33_);
					_data_->name = _data_->_tmp34_;
					_data_->_tmp35_ = NULL;
					_data_->_tmp35_ = _data_->f;
					_data_->_tmp36_ = 0;
					_data_->_tmp36_ = g_file_info_get_file_type (_data_->_tmp35_);
					if (_data_->_tmp36_ == G_FILE_TYPE_DIRECTORY) {
						_data_->_tmp37_ = NULL;
						_data_->_tmp37_ = _data_->directory;
						_data_->_tmp38_ = NULL;
						_data_->_tmp38_ = _data_->name;
						_data_->_tmp39_ = NULL;
						_data_->_tmp39_ = g_file_get_child (_data_->_tmp37_, _data_->_tmp38_);
						_data_->subdir = _data_->_tmp39_;
						_data_->_tmp40_ = NULL;
						_data_->_tmp40_ = _data_->id_prefix;
						_data_->_tmp41_ = NULL;
						_data_->_tmp41_ = _data_->subdir;
						_data_->_tmp42_ = NULL;
						_data_->_tmp42_ = g_file_get_basename (_data_->_tmp41_);
						_data_->_tmp43_ = NULL;
						_data_->_tmp43_ = _data_->_tmp42_;
						_data_->_tmp44_ = NULL;
						_data_->_tmp44_ = g_strdup_printf ("%s%s-", _data_->_tmp40_, _data_->_tmp43_);
						_data_->_tmp45_ = NULL;
						_data_->_tmp45_ = _data_->_tmp44_;
						_g_free0 (_data_->_tmp43_);
						_data_->new_prefix = _data_->_tmp45_;
						_data_->_tmp46_ = NULL;
						_data_->_tmp46_ = _data_->subdir;
						_data_->_tmp47_ = NULL;
						_data_->_tmp47_ = _data_->new_prefix;
						_data_->_tmp48_ = NULL;
						_data_->_tmp48_ = _data_->monitored_dirs;
						_data_->_state_ = 4;
						synapse_desktop_file_service_process_directory (_data_->self, _data_->_tmp46_, _data_->_tmp47_, _data_->_tmp48_, synapse_desktop_file_service_process_directory_ready, _data_);
						return FALSE;
						_state_4:
						synapse_desktop_file_service_process_directory_finish (_data_->self, _data_->_res_);
						_g_free0 (_data_->new_prefix);
						_g_object_unref0 (_data_->subdir);
					} else {
						_data_->_tmp49_ = NULL;
						_data_->_tmp49_ = _data_->name;
						_data_->_tmp50_ = FALSE;
						_data_->_tmp50_ = g_str_has_suffix (_data_->_tmp49_, "synapse.desktop");
						if (_data_->_tmp50_) {
							_g_object_unref0 (_data_->f);
							continue;
						}
						_data_->_tmp51_ = NULL;
						_data_->_tmp51_ = _data_->name;
						_data_->_tmp52_ = FALSE;
						_data_->_tmp52_ = g_str_has_suffix (_data_->_tmp51_, ".desktop");
						if (_data_->_tmp52_) {
							_data_->_tmp53_ = NULL;
							_data_->_tmp53_ = _data_->directory;
							_data_->_tmp54_ = NULL;
							_data_->_tmp54_ = _data_->name;
							_data_->_tmp55_ = NULL;
							_data_->_tmp55_ = g_file_get_child (_data_->_tmp53_, _data_->_tmp54_);
							_data_->_tmp56_ = NULL;
							_data_->_tmp56_ = _data_->_tmp55_;
							_data_->_tmp57_ = NULL;
							_data_->_tmp57_ = _data_->id_prefix;
							_data_->_state_ = 5;
							synapse_desktop_file_service_load_desktop_file (_data_->self, _data_->_tmp56_, _data_->_tmp57_, synapse_desktop_file_service_process_directory_ready, _data_);
							return FALSE;
							_state_5:
							synapse_desktop_file_service_load_desktop_file_finish (_data_->self, _data_->_res_);
							_g_object_unref0 (_data_->_tmp56_);
						}
					}
					_g_object_unref0 (_data_->f);
				}
			}
		}
		__g_list_free__g_object_unref0_0 (_data_->files);
		_g_object_unref0 (_data_->enumerator);
		_g_free0 (_data_->path);
	}
	goto __finally36;
	__catch36_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp58_ = NULL;
		_data_->_tmp58_ = _data_->err;
		_data_->_tmp59_ = NULL;
		_data_->_tmp59_ = _data_->_tmp58_->message;
		g_warning ("desktop-file-service.vala:397: %s", _data_->_tmp59_);
		_g_error_free0 (_data_->err);
	}
	__finally36:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void synapse_desktop_file_service_load_all_desktop_files_data_free (gpointer _data) {
	SynapseDesktopFileServiceLoadAllDesktopFilesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (SynapseDesktopFileServiceLoadAllDesktopFilesData, _data_);
}


static void synapse_desktop_file_service_load_all_desktop_files (SynapseDesktopFileService* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseDesktopFileServiceLoadAllDesktopFilesData* _data_;
	SynapseDesktopFileService* _tmp0_ = NULL;
	_data_ = g_slice_new0 (SynapseDesktopFileServiceLoadAllDesktopFilesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, synapse_desktop_file_service_load_all_desktop_files);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_desktop_file_service_load_all_desktop_files_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	synapse_desktop_file_service_load_all_desktop_files_co (_data_);
}


static void synapse_desktop_file_service_load_all_desktop_files_finish (SynapseDesktopFileService* self, GAsyncResult* _res_) {
	SynapseDesktopFileServiceLoadAllDesktopFilesData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static gchar** _vala_array_dup3 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


static void _vala_array_add6 (gchar*** array, int* length, int* size, gchar* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (gchar*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void synapse_desktop_file_service_load_all_desktop_files_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseDesktopFileServiceLoadAllDesktopFilesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_desktop_file_service_load_all_desktop_files_co (_data_);
}


static void _synapse_desktop_file_service_desktop_file_directory_changed_g_file_monitor_changed (GFileMonitor* _sender, GFile* file, GFile* other_file, GFileMonitorEvent event_type, gpointer self) {
	synapse_desktop_file_service_desktop_file_directory_changed ((SynapseDesktopFileService*) self);
}


static gboolean synapse_desktop_file_service_load_all_desktop_files_co (SynapseDesktopFileServiceLoadAllDesktopFilesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = _data_->_tmp0_ = g_get_system_data_dirs ();
	_data_->_tmp2_ = NULL;
	_data_->_tmp2__length1 = 0;
	_data_->_tmp2_ = (_data_->_tmp1_ != NULL) ? _vala_array_dup3 (_data_->_tmp1_, _vala_array_length (_data_->_tmp0_)) : ((gpointer) _data_->_tmp1_);
	_data_->_tmp2__length1 = _vala_array_length (_data_->_tmp0_);
	_data_->data_dirs_length1 = 0;
	_data_->_data_dirs_size_ = 0;
	_data_->data_dirs = _data_->_tmp2_;
	_data_->data_dirs_length1 = _data_->_tmp2__length1;
	_data_->_data_dirs_size_ = _data_->data_dirs_length1;
	_data_->_tmp3_ = NULL;
	_data_->_tmp3__length1 = 0;
	_data_->_tmp3_ = _data_->data_dirs;
	_data_->_tmp3__length1 = _data_->data_dirs_length1;
	_data_->_tmp4_ = NULL;
	_data_->_tmp4_ = g_get_user_data_dir ();
	_data_->_tmp5_ = NULL;
	_data_->_tmp5_ = g_strdup (_data_->_tmp4_);
	_vala_array_add6 (&_data_->data_dirs, &_data_->data_dirs_length1, &_data_->_data_dirs_size_, _data_->_tmp5_);
	_data_->_tmp6_ = NULL;
	_data_->_tmp6_ = gee_hash_set_new (G_TYPE_FILE, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	_data_->desktop_file_dirs = (GeeSet*) _data_->_tmp6_;
	_data_->_tmp7_ = NULL;
	_data_->_tmp7_ = _data_->self->priv->mimetype_parent_map;
	gee_multi_map_clear (_data_->_tmp7_);
	_data_->_tmp8_ = NULL;
	_data_->_tmp8__length1 = 0;
	_data_->_tmp8_ = _data_->data_dirs;
	_data_->_tmp8__length1 = _data_->data_dirs_length1;
	{
		_data_->data_dir_collection_length1 = 0;
		_data_->_data_dir_collection_size_ = 0;
		_data_->data_dir_collection = _data_->_tmp8_;
		_data_->data_dir_collection_length1 = _data_->_tmp8__length1;
		for (_data_->data_dir_it = 0; _data_->data_dir_it < _data_->_tmp8__length1; _data_->data_dir_it = _data_->data_dir_it + 1) {
			_data_->data_dir = _data_->data_dir_collection[_data_->data_dir_it];
			{
				_data_->_tmp9_ = NULL;
				_data_->_tmp9_ = _data_->data_dir;
				_data_->_tmp10_ = NULL;
				_data_->_tmp10_ = g_build_filename (_data_->_tmp9_, "applications", NULL, NULL);
				_data_->dir_path = _data_->_tmp10_;
				_data_->_tmp11_ = NULL;
				_data_->_tmp11_ = _data_->dir_path;
				_data_->_tmp12_ = NULL;
				_data_->_tmp12_ = g_file_new_for_path (_data_->_tmp11_);
				_data_->directory = _data_->_tmp12_;
				_data_->_tmp13_ = NULL;
				_data_->_tmp13_ = _data_->directory;
				_data_->_tmp14_ = NULL;
				_data_->_tmp14_ = _data_->desktop_file_dirs;
				_data_->_state_ = 1;
				synapse_desktop_file_service_process_directory (_data_->self, _data_->_tmp13_, "", _data_->_tmp14_, synapse_desktop_file_service_load_all_desktop_files_ready, _data_);
				return FALSE;
				_state_1:
				synapse_desktop_file_service_process_directory_finish (_data_->self, _data_->_res_);
				_data_->_tmp15_ = NULL;
				_data_->_tmp15_ = _data_->data_dir;
				_data_->_tmp16_ = NULL;
				_data_->_tmp16_ = g_build_filename (_data_->_tmp15_, "mime", "subclasses", NULL);
				_g_free0 (_data_->dir_path);
				_data_->dir_path = _data_->_tmp16_;
				_data_->_tmp17_ = NULL;
				_data_->_tmp17_ = _data_->dir_path;
				_data_->_state_ = 2;
				synapse_desktop_file_service_load_mime_parents_from_file (_data_->self, _data_->_tmp17_, synapse_desktop_file_service_load_all_desktop_files_ready, _data_);
				return FALSE;
				_state_2:
				synapse_desktop_file_service_load_mime_parents_from_file_finish (_data_->self, _data_->_res_);
				_g_object_unref0 (_data_->directory);
				_g_free0 (_data_->dir_path);
			}
		}
	}
	synapse_desktop_file_service_create_indices (_data_->self);
	_data_->_tmp18_ = NULL;
	_data_->_tmp18_ = gee_array_list_new (g_file_monitor_get_type (), (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (_data_->self->priv->directory_monitors);
	_data_->self->priv->directory_monitors = (GeeList*) _data_->_tmp18_;
	{
		_data_->_tmp19_ = NULL;
		_data_->_tmp19_ = _data_->desktop_file_dirs;
		_data_->_tmp20_ = NULL;
		_data_->_tmp20_ = gee_iterable_iterator ((GeeIterable*) _data_->_tmp19_);
		_data_->_d_it = _data_->_tmp20_;
		while (TRUE) {
			_data_->_tmp21_ = NULL;
			_data_->_tmp21_ = _data_->_d_it;
			_data_->_tmp22_ = FALSE;
			_data_->_tmp22_ = gee_iterator_next (_data_->_tmp21_);
			if (!_data_->_tmp22_) {
				break;
			}
			_data_->_tmp23_ = NULL;
			_data_->_tmp23_ = _data_->_d_it;
			_data_->_tmp24_ = NULL;
			_data_->_tmp24_ = gee_iterator_get (_data_->_tmp23_);
			_data_->d = (GFile*) _data_->_tmp24_;
			{
				_data_->_tmp25_ = NULL;
				_data_->_tmp25_ = _data_->d;
				_data_->_tmp26_ = NULL;
				_data_->_tmp26_ = g_file_monitor_directory (_data_->_tmp25_, 0, NULL, &_data_->_inner_error_);
				_data_->monitor = _data_->_tmp26_;
				if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
					goto __catch37_g_error;
				}
				_data_->_tmp27_ = NULL;
				_data_->_tmp27_ = _data_->monitor;
				g_signal_connect_object (_data_->_tmp27_, "changed", (GCallback) _synapse_desktop_file_service_desktop_file_directory_changed_g_file_monitor_changed, _data_->self, 0);
				_data_->_tmp28_ = NULL;
				_data_->_tmp28_ = _data_->self->priv->directory_monitors;
				_data_->_tmp29_ = NULL;
				_data_->_tmp29_ = _data_->monitor;
				gee_collection_add ((GeeCollection*) _data_->_tmp28_, _data_->_tmp29_);
				_g_object_unref0 (_data_->monitor);
			}
			goto __finally37;
			__catch37_g_error:
			{
				_data_->err = _data_->_inner_error_;
				_data_->_inner_error_ = NULL;
				_data_->_tmp30_ = NULL;
				_data_->_tmp30_ = _data_->err;
				_data_->_tmp31_ = NULL;
				_data_->_tmp31_ = _data_->_tmp30_->message;
				g_warning ("desktop-file-service.vala:432: Unable to monitor directory: %s", _data_->_tmp31_);
				_g_error_free0 (_data_->err);
			}
			__finally37:
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				_g_object_unref0 (_data_->d);
				_g_object_unref0 (_data_->_d_it);
				_g_object_unref0 (_data_->desktop_file_dirs);
				_data_->data_dirs = (_vala_array_free (_data_->data_dirs, _data_->data_dirs_length1, (GDestroyNotify) g_free), NULL);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
				g_clear_error (&_data_->_inner_error_);
				return FALSE;
			}
			_g_object_unref0 (_data_->d);
		}
		_g_object_unref0 (_data_->_d_it);
	}
	_g_object_unref0 (_data_->desktop_file_dirs);
	_data_->data_dirs = (_vala_array_free (_data_->data_dirs, _data_->data_dirs_length1, (GDestroyNotify) g_free), NULL);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gboolean __lambda9_ (SynapseDesktopFileService* self) {
	gboolean result = FALSE;
	self->priv->timer_id = (guint) 0;
	synapse_desktop_file_service_reload_desktop_files (self, NULL, NULL);
	result = FALSE;
	return result;
}


static gboolean ___lambda9__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda9_ ((SynapseDesktopFileService*) self);
	return result;
}


static void synapse_desktop_file_service_desktop_file_directory_changed (SynapseDesktopFileService* self) {
	guint _tmp0_ = 0U;
	guint _tmp2_ = 0U;
	g_return_if_fail (self != NULL);
	g_signal_emit_by_name (self, "reload-started");
	_tmp0_ = self->priv->timer_id;
	if (_tmp0_ != ((guint) 0)) {
		guint _tmp1_ = 0U;
		_tmp1_ = self->priv->timer_id;
		g_source_remove (_tmp1_);
	}
	_tmp2_ = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 5000, ___lambda9__gsource_func, g_object_ref (self), g_object_unref);
	self->priv->timer_id = _tmp2_;
}


static void synapse_desktop_file_service_reload_desktop_files_data_free (gpointer _data) {
	SynapseDesktopFileServiceReloadDesktopFilesData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->self);
	g_slice_free (SynapseDesktopFileServiceReloadDesktopFilesData, _data_);
}


static void synapse_desktop_file_service_reload_desktop_files (SynapseDesktopFileService* self, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseDesktopFileServiceReloadDesktopFilesData* _data_;
	SynapseDesktopFileService* _tmp0_ = NULL;
	_data_ = g_slice_new0 (SynapseDesktopFileServiceReloadDesktopFilesData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, synapse_desktop_file_service_reload_desktop_files);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_desktop_file_service_reload_desktop_files_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	synapse_desktop_file_service_reload_desktop_files_co (_data_);
}


static void synapse_desktop_file_service_reload_desktop_files_finish (SynapseDesktopFileService* self, GAsyncResult* _res_) {
	SynapseDesktopFileServiceReloadDesktopFilesData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void synapse_desktop_file_service_reload_desktop_files_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseDesktopFileServiceReloadDesktopFilesData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_desktop_file_service_reload_desktop_files_co (_data_);
}


static gboolean synapse_desktop_file_service_reload_desktop_files_co (SynapseDesktopFileServiceReloadDesktopFilesData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	g_debug ("desktop-file-service.vala:460: Reloading desktop files...");
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->self->priv->all_desktop_files;
	gee_collection_clear ((GeeCollection*) _data_->_tmp0_);
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = _data_->self->priv->non_hidden_desktop_files;
	gee_collection_clear ((GeeCollection*) _data_->_tmp1_);
	_data_->_state_ = 1;
	synapse_desktop_file_service_load_all_desktop_files (_data_->self, synapse_desktop_file_service_reload_desktop_files_ready, _data_);
	return FALSE;
	_state_1:
	synapse_desktop_file_service_load_all_desktop_files_finish (_data_->self, _data_->_res_);
	g_signal_emit_by_name (_data_->self, "reload-done");
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void synapse_desktop_file_service_load_desktop_file_data_free (gpointer _data) {
	SynapseDesktopFileServiceLoadDesktopFileData* _data_;
	_data_ = _data;
	_g_object_unref0 (_data_->file);
	_g_free0 (_data_->id_prefix);
	_g_object_unref0 (_data_->self);
	g_slice_free (SynapseDesktopFileServiceLoadDesktopFileData, _data_);
}


static void synapse_desktop_file_service_load_desktop_file (SynapseDesktopFileService* self, GFile* file, const gchar* id_prefix, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseDesktopFileServiceLoadDesktopFileData* _data_;
	SynapseDesktopFileService* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFile* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	_data_ = g_slice_new0 (SynapseDesktopFileServiceLoadDesktopFileData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, synapse_desktop_file_service_load_desktop_file);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_desktop_file_service_load_desktop_file_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = file;
	_tmp2_ = _g_object_ref0 (_tmp1_);
	_g_object_unref0 (_data_->file);
	_data_->file = _tmp2_;
	_tmp3_ = id_prefix;
	_tmp4_ = g_strdup (_tmp3_);
	_g_free0 (_data_->id_prefix);
	_data_->id_prefix = _tmp4_;
	synapse_desktop_file_service_load_desktop_file_co (_data_);
}


static void synapse_desktop_file_service_load_desktop_file_finish (SynapseDesktopFileService* self, GAsyncResult* _res_) {
	SynapseDesktopFileServiceLoadDesktopFileData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void synapse_desktop_file_service_load_desktop_file_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseDesktopFileServiceLoadDesktopFileData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_desktop_file_service_load_desktop_file_co (_data_);
}


static gboolean synapse_desktop_file_service_load_desktop_file_co (SynapseDesktopFileServiceLoadDesktopFileData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->file_contents_length1 = 0;
		_data_->_file_contents_size_ = 0;
		_data_->_tmp0_ = NULL;
		_data_->_tmp0_ = _data_->file;
		_data_->_tmp1_ = NULL;
		memset (&_data_->_tmp2_, 0, sizeof (gsize));
		_data_->_state_ = 1;
		g_file_load_contents_async (_data_->_tmp0_, NULL, synapse_desktop_file_service_load_desktop_file_ready, _data_);
		return FALSE;
		_state_1:
		_data_->_tmp3_ = FALSE;
		_data_->_tmp3_ = g_file_load_contents_finish (_data_->_tmp0_, _data_->_res_, &_data_->_tmp1_, &_data_->_tmp2_, NULL, &_data_->_inner_error_);
		_data_->file_contents = (g_free (_data_->file_contents), NULL);
		_data_->file_contents = _data_->_tmp1_;
		_data_->file_contents_length1 = _data_->_tmp2_;
		_data_->_file_contents_size_ = _data_->file_contents_length1;
		_data_->success = _data_->_tmp3_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			_data_->file_contents = (g_free (_data_->file_contents), NULL);
			goto __catch38_g_error;
		}
		_data_->_tmp4_ = FALSE;
		_data_->_tmp4_ = _data_->success;
		if (_data_->_tmp4_) {
			_data_->_tmp5_ = NULL;
			_data_->_tmp5_ = g_key_file_new ();
			_data_->keyfile = _data_->_tmp5_;
			_data_->_tmp6_ = NULL;
			_data_->_tmp6_ = _data_->keyfile;
			_data_->_tmp7_ = NULL;
			_data_->_tmp7__length1 = 0;
			_data_->_tmp7_ = _data_->file_contents;
			_data_->_tmp7__length1 = _data_->file_contents_length1;
			_data_->_tmp8_ = NULL;
			_data_->_tmp8__length1 = 0;
			_data_->_tmp8_ = _data_->file_contents;
			_data_->_tmp8__length1 = _data_->file_contents_length1;
			g_key_file_load_from_data (_data_->_tmp6_, (const gchar*) _data_->_tmp7_, (gsize) _data_->_tmp8__length1, 0, &_data_->_inner_error_);
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				_g_key_file_free0 (_data_->keyfile);
				_data_->file_contents = (g_free (_data_->file_contents), NULL);
				goto __catch38_g_error;
			}
			_data_->_tmp9_ = NULL;
			_data_->_tmp9_ = _data_->id_prefix;
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = _data_->file;
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = g_file_get_basename (_data_->_tmp10_);
			_data_->_tmp12_ = NULL;
			_data_->_tmp12_ = _data_->_tmp11_;
			_data_->_tmp13_ = NULL;
			_data_->_tmp13_ = g_strdup_printf ("%s%s", _data_->_tmp9_, _data_->_tmp12_);
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = _data_->_tmp13_;
			_g_free0 (_data_->_tmp12_);
			_data_->desktop_id = _data_->_tmp14_;
			_data_->_tmp15_ = NULL;
			_data_->_tmp15_ = _data_->file;
			_data_->_tmp16_ = NULL;
			_data_->_tmp16_ = g_file_get_path (_data_->_tmp15_);
			_data_->_tmp17_ = NULL;
			_data_->_tmp17_ = _data_->_tmp16_;
			_data_->_tmp18_ = NULL;
			_data_->_tmp18_ = _data_->keyfile;
			_data_->_tmp19_ = NULL;
			_data_->_tmp19_ = _data_->desktop_id;
			_data_->_tmp20_ = NULL;
			_data_->_tmp20_ = synapse_desktop_file_info_new_for_keyfile (_data_->_tmp17_, _data_->_tmp18_, _data_->_tmp19_);
			_data_->_tmp21_ = NULL;
			_data_->_tmp21_ = _data_->_tmp20_;
			_g_free0 (_data_->_tmp17_);
			_data_->dfi = _data_->_tmp21_;
			_data_->_tmp22_ = NULL;
			_data_->_tmp22_ = _data_->dfi;
			_data_->_tmp23_ = FALSE;
			_data_->_tmp23_ = synapse_desktop_file_info_get_is_valid (_data_->_tmp22_);
			_data_->_tmp24_ = FALSE;
			_data_->_tmp24_ = _data_->_tmp23_;
			if (_data_->_tmp24_) {
				_data_->_tmp25_ = NULL;
				_data_->_tmp25_ = _data_->self->priv->all_desktop_files;
				_data_->_tmp26_ = NULL;
				_data_->_tmp26_ = _data_->dfi;
				gee_collection_add ((GeeCollection*) _data_->_tmp25_, _data_->_tmp26_);
				_data_->_tmp28_ = NULL;
				_data_->_tmp28_ = _data_->dfi;
				_data_->_tmp29_ = FALSE;
				_data_->_tmp29_ = synapse_desktop_file_info_get_is_hidden (_data_->_tmp28_);
				_data_->_tmp30_ = FALSE;
				_data_->_tmp30_ = _data_->_tmp29_;
				if (!_data_->_tmp30_) {
					_data_->_tmp31_ = 0;
					_data_->_tmp31_ = _data_->self->priv->session_type;
					_data_->_tmp32_ = NULL;
					_data_->_tmp32_ = _data_->dfi;
					_data_->_tmp33_ = 0;
					_data_->_tmp33_ = synapse_desktop_file_info_get_show_in (_data_->_tmp32_);
					_data_->_tmp34_ = 0;
					_data_->_tmp34_ = _data_->_tmp33_;
					_data_->_tmp27_ = (_data_->_tmp34_ & _data_->_tmp31_) == _data_->_tmp31_;
				} else {
					_data_->_tmp27_ = FALSE;
				}
				if (_data_->_tmp27_) {
					_data_->_tmp35_ = NULL;
					_data_->_tmp35_ = _data_->self->priv->non_hidden_desktop_files;
					_data_->_tmp36_ = NULL;
					_data_->_tmp36_ = _data_->dfi;
					gee_collection_add ((GeeCollection*) _data_->_tmp35_, _data_->_tmp36_);
				}
			}
			_g_object_unref0 (_data_->dfi);
			_g_free0 (_data_->desktop_id);
			_g_key_file_free0 (_data_->keyfile);
		}
		_data_->file_contents = (g_free (_data_->file_contents), NULL);
	}
	goto __finally38;
	__catch38_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_data_->_tmp37_ = NULL;
		_data_->_tmp37_ = _data_->err;
		_data_->_tmp38_ = NULL;
		_data_->_tmp38_ = _data_->_tmp37_->message;
		g_warning ("desktop-file-service.vala:497: %s", _data_->_tmp38_);
		_g_error_free0 (_data_->err);
	}
	__finally38:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static gchar* string_strip (const gchar* self) {
	gchar* result = NULL;
	gchar* _result_ = NULL;
	gchar* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	_tmp1_ = _result_;
	g_strstrip (_tmp1_);
	result = _result_;
	return result;
}


static void synapse_desktop_file_service_create_indices (SynapseDesktopFileService* self) {
	GeeHashMap* _tmp0_ = NULL;
	GeeHashMap* _tmp1_ = NULL;
	GeeHashMap* _tmp2_ = NULL;
	GRegex* exec_re = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, NULL, NULL, GEE_TYPE_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->mimetype_map);
	self->priv->mimetype_map = (GeeMap*) _tmp0_;
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, GEE_TYPE_LIST, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->exec_map);
	self->priv->exec_map = (GeeMap*) _tmp1_;
	_tmp2_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->desktop_id_map);
	self->priv->desktop_id_map = (GeeMap*) _tmp2_;
	{
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		GRegex* _tmp5_ = NULL;
		_tmp4_ = g_regex_new ("%[fFuU]", 0, 0, &_inner_error_);
		_tmp3_ = _tmp4_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch39_g_error;
		}
		_tmp5_ = _tmp3_;
		_tmp3_ = NULL;
		_g_regex_unref0 (exec_re);
		exec_re = _tmp5_;
		_g_regex_unref0 (_tmp3_);
	}
	goto __finally39;
	__catch39_g_error:
	{
		GError* err = NULL;
		GError* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		err = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = err;
		_tmp7_ = _tmp6_->message;
		g_critical ("desktop-file-service.vala:520: %s", _tmp7_);
		_g_error_free0 (err);
		_g_regex_unref0 (exec_re);
		return;
	}
	__finally39:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_regex_unref0 (exec_re);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	{
		GeeList* _dfi_list = NULL;
		GeeList* _tmp8_ = NULL;
		GeeList* _tmp9_ = NULL;
		gint _dfi_size = 0;
		GeeList* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		gint _dfi_index = 0;
		_tmp8_ = self->priv->all_desktop_files;
		_tmp9_ = _g_object_ref0 (_tmp8_);
		_dfi_list = _tmp9_;
		_tmp10_ = _dfi_list;
		_tmp11_ = gee_collection_get_size ((GeeCollection*) _tmp10_);
		_tmp12_ = _tmp11_;
		_dfi_size = _tmp12_;
		_dfi_index = -1;
		while (TRUE) {
			gint _tmp13_ = 0;
			gint _tmp14_ = 0;
			gint _tmp15_ = 0;
			SynapseDesktopFileInfo* dfi = NULL;
			GeeList* _tmp16_ = NULL;
			gint _tmp17_ = 0;
			gpointer _tmp18_ = NULL;
			gchar* exec = NULL;
			gchar* _tmp19_ = NULL;
			const gchar* _tmp29_ = NULL;
			gchar* _tmp30_ = NULL;
			GeeList* exec_list = NULL;
			GeeMap* _tmp31_ = NULL;
			const gchar* _tmp32_ = NULL;
			gpointer _tmp33_ = NULL;
			GeeList* _tmp34_ = NULL;
			GeeList* _tmp39_ = NULL;
			SynapseDesktopFileInfo* _tmp40_ = NULL;
			gchar* _tmp41_ = NULL;
			SynapseDesktopFileInfo* _tmp42_ = NULL;
			const gchar* _tmp43_ = NULL;
			const gchar* _tmp44_ = NULL;
			gchar* _tmp45_ = NULL;
			gchar* desktop_id = NULL;
			gchar* _tmp50_ = NULL;
			GeeMap* _tmp51_ = NULL;
			const gchar* _tmp52_ = NULL;
			SynapseDesktopFileInfo* _tmp53_ = NULL;
			gboolean _tmp54_ = FALSE;
			SynapseDesktopFileInfo* _tmp55_ = NULL;
			gboolean _tmp56_ = FALSE;
			gboolean _tmp57_ = FALSE;
			SynapseDesktopFileInfo* _tmp60_ = NULL;
			gchar** _tmp61_ = NULL;
			gint _tmp61__length1 = 0;
			_tmp13_ = _dfi_index;
			_dfi_index = _tmp13_ + 1;
			_tmp14_ = _dfi_index;
			_tmp15_ = _dfi_size;
			if (!(_tmp14_ < _tmp15_)) {
				break;
			}
			_tmp16_ = _dfi_list;
			_tmp17_ = _dfi_index;
			_tmp18_ = gee_list_get (_tmp16_, _tmp17_);
			dfi = (SynapseDesktopFileInfo*) _tmp18_;
			_tmp19_ = g_strdup ("");
			exec = _tmp19_;
			{
				gchar* _tmp20_ = NULL;
				GRegex* _tmp21_ = NULL;
				SynapseDesktopFileInfo* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				const gchar* _tmp24_ = NULL;
				gchar* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				_tmp21_ = exec_re;
				_tmp22_ = dfi;
				_tmp23_ = synapse_desktop_file_info_get_exec (_tmp22_);
				_tmp24_ = _tmp23_;
				_tmp25_ = g_regex_replace_literal (_tmp21_, _tmp24_, (gssize) -1, 0, "", 0, &_inner_error_);
				_tmp20_ = _tmp25_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					if (_inner_error_->domain == G_REGEX_ERROR) {
						goto __catch40_g_regex_error;
					}
					_g_free0 (exec);
					_g_object_unref0 (dfi);
					_g_object_unref0 (_dfi_list);
					_g_regex_unref0 (exec_re);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				_tmp26_ = _tmp20_;
				_tmp20_ = NULL;
				_g_free0 (exec);
				exec = _tmp26_;
				_g_free0 (_tmp20_);
			}
			goto __finally40;
			__catch40_g_regex_error:
			{
				GError* err = NULL;
				GError* _tmp27_ = NULL;
				const gchar* _tmp28_ = NULL;
				err = _inner_error_;
				_inner_error_ = NULL;
				_tmp27_ = err;
				_tmp28_ = _tmp27_->message;
				synapse_utils_logger_error ((GObject*) self, "%s", _tmp28_, NULL);
				_g_error_free0 (err);
			}
			__finally40:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (exec);
				_g_object_unref0 (dfi);
				_g_object_unref0 (_dfi_list);
				_g_regex_unref0 (exec_re);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp29_ = exec;
			_tmp30_ = string_strip (_tmp29_);
			_g_free0 (exec);
			exec = _tmp30_;
			_tmp31_ = self->priv->exec_map;
			_tmp32_ = exec;
			_tmp33_ = gee_map_get (_tmp31_, _tmp32_);
			exec_list = (GeeList*) _tmp33_;
			_tmp34_ = exec_list;
			if (_tmp34_ == NULL) {
				GeeArrayList* _tmp35_ = NULL;
				GeeMap* _tmp36_ = NULL;
				const gchar* _tmp37_ = NULL;
				GeeList* _tmp38_ = NULL;
				_tmp35_ = gee_array_list_new (SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
				_g_object_unref0 (exec_list);
				exec_list = (GeeList*) _tmp35_;
				_tmp36_ = self->priv->exec_map;
				_tmp37_ = exec;
				_tmp38_ = exec_list;
				gee_map_set (_tmp36_, _tmp37_, _tmp38_);
			}
			_tmp39_ = exec_list;
			_tmp40_ = dfi;
			gee_collection_add ((GeeCollection*) _tmp39_, _tmp40_);
			_tmp42_ = dfi;
			_tmp43_ = synapse_desktop_file_info_get_desktop_id (_tmp42_);
			_tmp44_ = _tmp43_;
			_tmp45_ = g_strdup (_tmp44_);
			_tmp41_ = _tmp45_;
			if (_tmp41_ == NULL) {
				SynapseDesktopFileInfo* _tmp46_ = NULL;
				const gchar* _tmp47_ = NULL;
				const gchar* _tmp48_ = NULL;
				gchar* _tmp49_ = NULL;
				_tmp46_ = dfi;
				_tmp47_ = synapse_desktop_file_info_get_filename (_tmp46_);
				_tmp48_ = _tmp47_;
				_tmp49_ = g_path_get_basename (_tmp48_);
				_g_free0 (_tmp41_);
				_tmp41_ = _tmp49_;
			}
			_tmp50_ = _tmp41_;
			_tmp41_ = NULL;
			desktop_id = _tmp50_;
			_tmp51_ = self->priv->desktop_id_map;
			_tmp52_ = desktop_id;
			_tmp53_ = dfi;
			gee_map_set (_tmp51_, _tmp52_, _tmp53_);
			_tmp55_ = dfi;
			_tmp56_ = synapse_desktop_file_info_get_is_hidden (_tmp55_);
			_tmp57_ = _tmp56_;
			if (_tmp57_) {
				_tmp54_ = TRUE;
			} else {
				SynapseDesktopFileInfo* _tmp58_ = NULL;
				gchar** _tmp59_ = NULL;
				gint _tmp59__length1 = 0;
				_tmp58_ = dfi;
				_tmp59_ = _tmp58_->mime_types;
				_tmp59__length1 = _tmp58_->mime_types_length1;
				_tmp54_ = _tmp59_ == NULL;
			}
			if (_tmp54_) {
				_g_free0 (desktop_id);
				_g_free0 (_tmp41_);
				_g_object_unref0 (exec_list);
				_g_free0 (exec);
				_g_object_unref0 (dfi);
				continue;
			}
			_tmp60_ = dfi;
			_tmp61_ = _tmp60_->mime_types;
			_tmp61__length1 = _tmp60_->mime_types_length1;
			{
				gchar** mime_type_collection = NULL;
				gint mime_type_collection_length1 = 0;
				gint _mime_type_collection_size_ = 0;
				gint mime_type_it = 0;
				mime_type_collection = _tmp61_;
				mime_type_collection_length1 = _tmp61__length1;
				for (mime_type_it = 0; mime_type_it < _tmp61__length1; mime_type_it = mime_type_it + 1) {
					const gchar* mime_type = NULL;
					mime_type = mime_type_collection[mime_type_it];
					{
						GeeList* list = NULL;
						GeeMap* _tmp62_ = NULL;
						const gchar* _tmp63_ = NULL;
						gpointer _tmp64_ = NULL;
						GeeList* _tmp65_ = NULL;
						GeeList* _tmp70_ = NULL;
						SynapseDesktopFileInfo* _tmp71_ = NULL;
						_tmp62_ = self->priv->mimetype_map;
						_tmp63_ = mime_type;
						_tmp64_ = gee_map_get (_tmp62_, _tmp63_);
						list = (GeeList*) _tmp64_;
						_tmp65_ = list;
						if (_tmp65_ == NULL) {
							GeeArrayList* _tmp66_ = NULL;
							GeeMap* _tmp67_ = NULL;
							const gchar* _tmp68_ = NULL;
							GeeList* _tmp69_ = NULL;
							_tmp66_ = gee_array_list_new (SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
							_g_object_unref0 (list);
							list = (GeeList*) _tmp66_;
							_tmp67_ = self->priv->mimetype_map;
							_tmp68_ = mime_type;
							_tmp69_ = list;
							gee_map_set (_tmp67_, _tmp68_, _tmp69_);
						}
						_tmp70_ = list;
						_tmp71_ = dfi;
						gee_collection_add ((GeeCollection*) _tmp70_, _tmp71_);
						_g_object_unref0 (list);
					}
				}
			}
			_g_free0 (desktop_id);
			_g_free0 (_tmp41_);
			_g_object_unref0 (exec_list);
			_g_free0 (exec);
			_g_object_unref0 (dfi);
		}
		_g_object_unref0 (_dfi_list);
	}
	_g_regex_unref0 (exec_re);
}


static void synapse_desktop_file_service_load_mime_parents_from_file_data_free (gpointer _data) {
	SynapseDesktopFileServiceLoadMimeParentsFromFileData* _data_;
	_data_ = _data;
	_g_free0 (_data_->fi);
	_g_object_unref0 (_data_->self);
	g_slice_free (SynapseDesktopFileServiceLoadMimeParentsFromFileData, _data_);
}


static void synapse_desktop_file_service_load_mime_parents_from_file (SynapseDesktopFileService* self, const gchar* fi, GAsyncReadyCallback _callback_, gpointer _user_data_) {
	SynapseDesktopFileServiceLoadMimeParentsFromFileData* _data_;
	SynapseDesktopFileService* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	_data_ = g_slice_new0 (SynapseDesktopFileServiceLoadMimeParentsFromFileData);
	_data_->_async_result = g_simple_async_result_new (G_OBJECT (self), _callback_, _user_data_, synapse_desktop_file_service_load_mime_parents_from_file);
	g_simple_async_result_set_op_res_gpointer (_data_->_async_result, _data_, synapse_desktop_file_service_load_mime_parents_from_file_data_free);
	_tmp0_ = _g_object_ref0 (self);
	_data_->self = _tmp0_;
	_tmp1_ = fi;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (_data_->fi);
	_data_->fi = _tmp2_;
	synapse_desktop_file_service_load_mime_parents_from_file_co (_data_);
}


static void synapse_desktop_file_service_load_mime_parents_from_file_finish (SynapseDesktopFileService* self, GAsyncResult* _res_) {
	SynapseDesktopFileServiceLoadMimeParentsFromFileData* _data_;
	_data_ = g_simple_async_result_get_op_res_gpointer (G_SIMPLE_ASYNC_RESULT (_res_));
}


static void synapse_desktop_file_service_load_mime_parents_from_file_ready (GObject* source_object, GAsyncResult* _res_, gpointer _user_data_) {
	SynapseDesktopFileServiceLoadMimeParentsFromFileData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	synapse_desktop_file_service_load_mime_parents_from_file_co (_data_);
}


static gboolean synapse_desktop_file_service_load_mime_parents_from_file_co (SynapseDesktopFileServiceLoadMimeParentsFromFileData* _data_) {
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		case 2:
		goto _state_2;
		case 3:
		goto _state_3;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_tmp0_ = NULL;
	_data_->_tmp0_ = _data_->fi;
	_data_->_tmp1_ = NULL;
	_data_->_tmp1_ = g_file_new_for_path (_data_->_tmp0_);
	_data_->file = _data_->_tmp1_;
	_data_->_tmp2_ = NULL;
	_data_->_tmp2_ = _data_->file;
	_data_->_state_ = 1;
	synapse_utils_query_exists_async (_data_->_tmp2_, synapse_desktop_file_service_load_mime_parents_from_file_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp3_ = FALSE;
	_data_->_tmp3_ = synapse_utils_query_exists_finish (_data_->_res_);
	_data_->exists = _data_->_tmp3_;
	_data_->_tmp4_ = FALSE;
	_data_->_tmp4_ = _data_->exists;
	if (!_data_->_tmp4_) {
		_g_object_unref0 (_data_->file);
		if (_data_->_state_ == 0) {
			g_simple_async_result_complete_in_idle (_data_->_async_result);
		} else {
			g_simple_async_result_complete (_data_->_async_result);
		}
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
	{
		_data_->_tmp5_ = NULL;
		_data_->_tmp5_ = _data_->file;
		_data_->_state_ = 2;
		g_file_read_async (_data_->_tmp5_, G_PRIORITY_DEFAULT, NULL, synapse_desktop_file_service_load_mime_parents_from_file_ready, _data_);
		return FALSE;
		_state_2:
		_data_->_tmp6_ = NULL;
		_data_->_tmp6_ = g_file_read_finish (_data_->_tmp5_, _data_->_res_, &_data_->_inner_error_);
		_data_->fis = _data_->_tmp6_;
		if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
			goto __catch41_g_error;
		}
		_data_->_tmp7_ = NULL;
		_data_->_tmp7_ = _data_->fis;
		_data_->_tmp8_ = NULL;
		_data_->_tmp8_ = g_data_input_stream_new ((GInputStream*) _data_->_tmp7_);
		_data_->dis = _data_->_tmp8_;
		_data_->line = NULL;
		_data_->mimes_length1 = 0;
		_data_->_mimes_size_ = 0;
		_data_->mimes = NULL;
		_data_->mimes_length1 = 0;
		_data_->_mimes_size_ = _data_->mimes_length1;
		_data_->len = 0;
		while (TRUE) {
			_data_->_tmp10_ = NULL;
			_data_->_tmp10_ = _data_->dis;
			_data_->_state_ = 3;
			g_data_input_stream_read_line_async (_data_->_tmp10_, G_PRIORITY_DEFAULT, NULL, synapse_desktop_file_service_load_mime_parents_from_file_ready, _data_);
			return FALSE;
			_state_3:
			_data_->_tmp11_ = NULL;
			_data_->_tmp11_ = g_data_input_stream_read_line_finish (_data_->_tmp10_, _data_->_res_, NULL, &_data_->_inner_error_);
			_data_->_tmp9_ = _data_->_tmp11_;
			if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
				_data_->mimes = (_vala_array_free (_data_->mimes, _data_->mimes_length1, (GDestroyNotify) g_free), NULL);
				_g_free0 (_data_->line);
				_g_object_unref0 (_data_->dis);
				_g_object_unref0 (_data_->fis);
				goto __catch41_g_error;
			}
			_data_->_tmp12_ = NULL;
			_data_->_tmp12_ = _data_->_tmp9_;
			_data_->_tmp9_ = NULL;
			_g_free0 (_data_->line);
			_data_->line = _data_->_tmp12_;
			_data_->_tmp13_ = NULL;
			_data_->_tmp13_ = _data_->line;
			if (_data_->_tmp13_ == NULL) {
				_g_free0 (_data_->_tmp9_);
				break;
			}
			_data_->_tmp14_ = NULL;
			_data_->_tmp14_ = _data_->line;
			_data_->_tmp15_ = FALSE;
			_data_->_tmp15_ = g_str_has_prefix (_data_->_tmp14_, "#");
			if (_data_->_tmp15_) {
				_g_free0 (_data_->_tmp9_);
				continue;
			}
			_data_->_tmp16_ = NULL;
			_data_->_tmp16_ = _data_->line;
			_data_->_tmp17_ = NULL;
			_data_->_tmp18_ = NULL;
			_data_->_tmp18_ = _data_->_tmp17_ = g_strsplit (_data_->_tmp16_, " ", 0);
			_data_->mimes = (_vala_array_free (_data_->mimes, _data_->mimes_length1, (GDestroyNotify) g_free), NULL);
			_data_->mimes = _data_->_tmp18_;
			_data_->mimes_length1 = _vala_array_length (_data_->_tmp17_);
			_data_->_mimes_size_ = _data_->mimes_length1;
			_data_->_tmp19_ = NULL;
			_data_->_tmp19__length1 = 0;
			_data_->_tmp19_ = _data_->mimes;
			_data_->_tmp19__length1 = _data_->mimes_length1;
			_data_->_tmp20_ = 0U;
			_data_->_tmp20_ = g_strv_length (_data_->_tmp19_);
			_data_->len = (gint) _data_->_tmp20_;
			_data_->_tmp21_ = 0;
			_data_->_tmp21_ = _data_->len;
			if (_data_->_tmp21_ != 2) {
				_g_free0 (_data_->_tmp9_);
				continue;
			}
			_data_->_tmp22_ = NULL;
			_data_->_tmp22__length1 = 0;
			_data_->_tmp22_ = _data_->mimes;
			_data_->_tmp22__length1 = _data_->mimes_length1;
			_data_->_tmp23_ = NULL;
			_data_->_tmp23_ = _data_->_tmp22_[0];
			_data_->_tmp24_ = NULL;
			_data_->_tmp24__length1 = 0;
			_data_->_tmp24_ = _data_->mimes;
			_data_->_tmp24__length1 = _data_->mimes_length1;
			_data_->_tmp25_ = NULL;
			_data_->_tmp25_ = _data_->_tmp24_[1];
			if (g_strcmp0 (_data_->_tmp23_, _data_->_tmp25_) == 0) {
				_g_free0 (_data_->_tmp9_);
				continue;
			}
			_data_->_tmp26_ = NULL;
			_data_->_tmp26_ = _data_->self->priv->mimetype_parent_map;
			_data_->_tmp27_ = NULL;
			_data_->_tmp27__length1 = 0;
			_data_->_tmp27_ = _data_->mimes;
			_data_->_tmp27__length1 = _data_->mimes_length1;
			_data_->_tmp28_ = NULL;
			_data_->_tmp28_ = _data_->_tmp27_[0];
			_data_->_tmp29_ = NULL;
			_data_->_tmp29__length1 = 0;
			_data_->_tmp29_ = _data_->mimes;
			_data_->_tmp29__length1 = _data_->mimes_length1;
			_data_->_tmp30_ = NULL;
			_data_->_tmp30_ = _data_->_tmp29_[1];
			gee_multi_map_set (_data_->_tmp26_, _data_->_tmp28_, _data_->_tmp30_);
			_g_free0 (_data_->_tmp9_);
		}
		_data_->mimes = (_vala_array_free (_data_->mimes, _data_->mimes_length1, (GDestroyNotify) g_free), NULL);
		_g_free0 (_data_->line);
		_g_object_unref0 (_data_->dis);
		_g_object_unref0 (_data_->fis);
	}
	goto __finally41;
	__catch41_g_error:
	{
		_data_->err = _data_->_inner_error_;
		_data_->_inner_error_ = NULL;
		_g_error_free0 (_data_->err);
	}
	__finally41:
	if (G_UNLIKELY (_data_->_inner_error_ != NULL)) {
		_g_object_unref0 (_data_->file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error_->message, g_quark_to_string (_data_->_inner_error_->domain), _data_->_inner_error_->code);
		g_clear_error (&_data_->_inner_error_);
		return FALSE;
	}
	_g_object_unref0 (_data_->file);
	if (_data_->_state_ == 0) {
		g_simple_async_result_complete_in_idle (_data_->_async_result);
	} else {
		g_simple_async_result_complete (_data_->_async_result);
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}


static void synapse_desktop_file_service_add_dfi_for_mime (SynapseDesktopFileService* self, const gchar* mime, GeeSet* ret) {
	GeeList* dfis = NULL;
	GeeMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gpointer _tmp2_ = NULL;
	GeeList* _tmp3_ = NULL;
	GeeCollection* parents = NULL;
	GeeMultiMap* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	GeeCollection* _tmp8_ = NULL;
	GeeCollection* _tmp9_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (mime != NULL);
	g_return_if_fail (ret != NULL);
	_tmp0_ = self->priv->mimetype_map;
	_tmp1_ = mime;
	_tmp2_ = gee_map_get (_tmp0_, _tmp1_);
	dfis = (GeeList*) _tmp2_;
	_tmp3_ = dfis;
	if (_tmp3_ != NULL) {
		GeeSet* _tmp4_ = NULL;
		GeeList* _tmp5_ = NULL;
		_tmp4_ = ret;
		_tmp5_ = dfis;
		gee_collection_add_all ((GeeCollection*) _tmp4_, (GeeCollection*) _tmp5_);
	}
	_tmp6_ = self->priv->mimetype_parent_map;
	_tmp7_ = mime;
	_tmp8_ = gee_multi_map_get (_tmp6_, _tmp7_);
	parents = _tmp8_;
	_tmp9_ = parents;
	if (_tmp9_ == NULL) {
		_g_object_unref0 (parents);
		_g_object_unref0 (dfis);
		return;
	}
	{
		GeeIterator* _parent_it = NULL;
		GeeCollection* _tmp10_ = NULL;
		GeeIterator* _tmp11_ = NULL;
		_tmp10_ = parents;
		_tmp11_ = gee_iterable_iterator ((GeeIterable*) _tmp10_);
		_parent_it = _tmp11_;
		while (TRUE) {
			GeeIterator* _tmp12_ = NULL;
			gboolean _tmp13_ = FALSE;
			gchar* parent = NULL;
			GeeIterator* _tmp14_ = NULL;
			gpointer _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			GeeSet* _tmp17_ = NULL;
			_tmp12_ = _parent_it;
			_tmp13_ = gee_iterator_next (_tmp12_);
			if (!_tmp13_) {
				break;
			}
			_tmp14_ = _parent_it;
			_tmp15_ = gee_iterator_get (_tmp14_);
			parent = (gchar*) _tmp15_;
			_tmp16_ = parent;
			_tmp17_ = ret;
			synapse_desktop_file_service_add_dfi_for_mime (self, _tmp16_, _tmp17_);
			_g_free0 (parent);
		}
		_g_object_unref0 (_parent_it);
	}
	_g_object_unref0 (parents);
	_g_object_unref0 (dfis);
}


GeeList* synapse_desktop_file_service_get_desktop_files (SynapseDesktopFileService* self) {
	GeeList* result = NULL;
	GeeList* _tmp0_ = NULL;
	GeeList* _tmp1_ = NULL;
	GeeList* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->non_hidden_desktop_files;
	_tmp1_ = gee_list_get_read_only_view (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


GeeList* synapse_desktop_file_service_get_all_desktop_files (SynapseDesktopFileService* self) {
	GeeList* result = NULL;
	GeeList* _tmp0_ = NULL;
	GeeList* _tmp1_ = NULL;
	GeeList* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->all_desktop_files;
	_tmp1_ = gee_list_get_read_only_view (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


GeeList* synapse_desktop_file_service_get_desktop_files_for_type (SynapseDesktopFileService* self, const gchar* mime_type) {
	GeeList* result = NULL;
	GeeHashSet* dfi_set = NULL;
	GeeHashSet* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	GeeArrayList* ret = NULL;
	GeeArrayList* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (mime_type != NULL, NULL);
	_tmp0_ = gee_hash_set_new (SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
	dfi_set = _tmp0_;
	_tmp1_ = mime_type;
	synapse_desktop_file_service_add_dfi_for_mime (self, _tmp1_, (GeeSet*) dfi_set);
	_tmp2_ = gee_array_list_new (SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	ret = _tmp2_;
	gee_array_list_add_all (ret, (GeeCollection*) dfi_set);
	result = (GeeList*) ret;
	_g_object_unref0 (dfi_set);
	return result;
}


GeeList* synapse_desktop_file_service_get_desktop_files_for_exec (SynapseDesktopFileService* self, const gchar* exec) {
	GeeList* result = NULL;
	GeeList* _tmp0_ = NULL;
	GeeMap* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gpointer _tmp3_ = NULL;
	GeeList* _tmp5_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (exec != NULL, NULL);
	_tmp1_ = self->priv->exec_map;
	_tmp2_ = exec;
	_tmp3_ = gee_map_get (_tmp1_, _tmp2_);
	_tmp0_ = (GeeList*) _tmp3_;
	if (_tmp0_ == NULL) {
		GeeArrayList* _tmp4_ = NULL;
		_tmp4_ = gee_array_list_new (SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
		_g_object_unref0 (_tmp0_);
		_tmp0_ = (GeeList*) _tmp4_;
	}
	_tmp5_ = _tmp0_;
	_tmp0_ = NULL;
	result = _tmp5_;
	_g_object_unref0 (_tmp0_);
	return result;
}


SynapseDesktopFileInfo* synapse_desktop_file_service_get_desktop_file_for_id (SynapseDesktopFileService* self, const gchar* desktop_id) {
	SynapseDesktopFileInfo* result = NULL;
	GeeMap* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gpointer _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (desktop_id != NULL, NULL);
	_tmp0_ = self->priv->desktop_id_map;
	_tmp1_ = desktop_id;
	_tmp2_ = gee_map_get (_tmp0_, _tmp1_);
	result = (SynapseDesktopFileInfo*) _tmp2_;
	return result;
}


static GObject * synapse_desktop_file_service_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	SynapseDesktopFileService * self;
	GeeArrayList* _tmp0_ = NULL;
	GeeArrayList* _tmp1_ = NULL;
	GeeArrayList* _tmp2_ = NULL;
	GeeHashMultiMap* _tmp3_ = NULL;
	SynapseUtilsAsyncOnce* _tmp4_ = NULL;
	parent_class = G_OBJECT_CLASS (synapse_desktop_file_service_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, SynapseDesktopFileService);
	synapse_desktop_file_service_instance = self;
	_tmp0_ = gee_array_list_new (g_file_monitor_get_type (), (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->directory_monitors);
	self->priv->directory_monitors = (GeeList*) _tmp0_;
	_tmp1_ = gee_array_list_new (SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->all_desktop_files);
	self->priv->all_desktop_files = (GeeList*) _tmp1_;
	_tmp2_ = gee_array_list_new (SYNAPSE_TYPE_DESKTOP_FILE_INFO, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->non_hidden_desktop_files);
	self->priv->non_hidden_desktop_files = (GeeList*) _tmp2_;
	_tmp3_ = gee_hash_multi_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	_g_object_unref0 (self->priv->mimetype_parent_map);
	self->priv->mimetype_parent_map = (GeeMultiMap*) _tmp3_;
	_tmp4_ = synapse_utils_async_once_new (G_TYPE_BOOLEAN, NULL, NULL);
	_synapse_utils_async_once_unref0 (self->priv->init_once);
	self->priv->init_once = _tmp4_;
	synapse_desktop_file_service_initialize (self, NULL, NULL);
	return obj;
}


static void synapse_desktop_file_service_class_init (SynapseDesktopFileServiceClass * klass) {
	synapse_desktop_file_service_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SynapseDesktopFileServicePrivate));
	G_OBJECT_CLASS (klass)->constructor = synapse_desktop_file_service_constructor;
	G_OBJECT_CLASS (klass)->finalize = synapse_desktop_file_service_finalize;
	g_signal_new ("reload_started", SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
	g_signal_new ("reload_done", SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void synapse_desktop_file_service_instance_init (SynapseDesktopFileService * self) {
	gchar* _tmp0_ = NULL;
	self->priv = SYNAPSE_DESKTOP_FILE_SERVICE_GET_PRIVATE (self);
	self->priv->session_type = SYNAPSE_DESKTOP_FILE_INFO_ENVIRONMENT_TYPE_GNOME;
	_tmp0_ = g_strdup ("GNOME");
	self->priv->session_type_str = _tmp0_;
	self->priv->timer_id = (guint) 0;
}


static void synapse_desktop_file_service_finalize (GObject* obj) {
	SynapseDesktopFileService * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, SYNAPSE_TYPE_DESKTOP_FILE_SERVICE, SynapseDesktopFileService);
	synapse_desktop_file_service_instance = NULL;
	_synapse_utils_async_once_unref0 (self->priv->init_once);
	_g_object_unref0 (self->priv->directory_monitors);
	_g_object_unref0 (self->priv->all_desktop_files);
	_g_object_unref0 (self->priv->non_hidden_desktop_files);
	_g_object_unref0 (self->priv->mimetype_map);
	_g_object_unref0 (self->priv->exec_map);
	_g_object_unref0 (self->priv->desktop_id_map);
	_g_object_unref0 (self->priv->mimetype_parent_map);
	_g_free0 (self->priv->session_type_str);
	G_OBJECT_CLASS (synapse_desktop_file_service_parent_class)->finalize (obj);
}


GType synapse_desktop_file_service_get_type (void) {
	static volatile gsize synapse_desktop_file_service_type_id__volatile = 0;
	if (g_once_init_enter (&synapse_desktop_file_service_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SynapseDesktopFileServiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) synapse_desktop_file_service_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SynapseDesktopFileService), 0, (GInstanceInitFunc) synapse_desktop_file_service_instance_init, NULL };
		GType synapse_desktop_file_service_type_id;
		synapse_desktop_file_service_type_id = g_type_register_static (G_TYPE_OBJECT, "SynapseDesktopFileService", &g_define_type_info, 0);
		g_once_init_leave (&synapse_desktop_file_service_type_id__volatile, synapse_desktop_file_service_type_id);
	}
	return synapse_desktop_file_service_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



