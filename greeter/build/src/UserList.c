/* UserList.c generated by valac 0.30.1, the Vala compiler
 * generated from UserList.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/

#include <glib.h>
#include <glib-object.h>
#include <gio/gio.h>
#include <string.h>
#include <gee.h>
#include <lightdm.h>
#include <stdlib.h>


#define TYPE_ACCOUNTS_SERVICE_USER (accounts_service_user_get_type ())
#define ACCOUNTS_SERVICE_USER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ACCOUNTS_SERVICE_USER, AccountsServiceUser))
#define IS_ACCOUNTS_SERVICE_USER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ACCOUNTS_SERVICE_USER))
#define ACCOUNTS_SERVICE_USER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_ACCOUNTS_SERVICE_USER, AccountsServiceUserIface))

typedef struct _AccountsServiceUser AccountsServiceUser;
typedef struct _AccountsServiceUserIface AccountsServiceUserIface;

#define TYPE_ACCOUNTS_SERVICE_USER_PROXY (accounts_service_user_proxy_get_type ())
typedef GDBusProxy AccountsServiceUserProxy;
typedef GDBusProxyClass AccountsServiceUserProxyClass;

#define TYPE_USER_LIST (user_list_get_type ())
#define USER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_LIST, UserList))
#define USER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_USER_LIST, UserListClass))
#define IS_USER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_LIST))
#define IS_USER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_USER_LIST))
#define USER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_LIST, UserListClass))

typedef struct _UserList UserList;
typedef struct _UserListClass UserListClass;
typedef struct _UserListPrivate UserListPrivate;

#define TYPE_LOGIN_OPTION (login_option_get_type ())
#define LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_OPTION, LoginOption))
#define LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIN_OPTION, LoginOptionClass))
#define IS_LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_OPTION))
#define IS_LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIN_OPTION))
#define LOGIN_OPTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIN_OPTION, LoginOptionClass))

typedef struct _LoginOption LoginOption;
typedef struct _LoginOptionClass LoginOptionClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_LOGIN_GATEWAY (login_gateway_get_type ())
#define LOGIN_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_GATEWAY, LoginGateway))
#define IS_LOGIN_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_GATEWAY))
#define LOGIN_GATEWAY_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_LOGIN_GATEWAY, LoginGatewayIface))

typedef struct _LoginGateway LoginGateway;
typedef struct _LoginGatewayIface LoginGatewayIface;

#define TYPE_LOGIN_MASK (login_mask_get_type ())
#define LOGIN_MASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_MASK, LoginMask))
#define IS_LOGIN_MASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_MASK))
#define LOGIN_MASK_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_LOGIN_MASK, LoginMaskIface))

typedef struct _LoginMask LoginMask;
typedef struct _LoginMaskIface LoginMaskIface;

#define TYPE_PROMPT_TYPE (prompt_type_get_type ())

#define TYPE_PROMPT_TEXT (prompt_text_get_type ())

#define TYPE_MESSAGE_TEXT (message_text_get_type ())
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_USER_LOGIN (user_login_get_type ())
#define USER_LOGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_LOGIN, UserLogin))
#define USER_LOGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_USER_LOGIN, UserLoginClass))
#define IS_USER_LOGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_LOGIN))
#define IS_USER_LOGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_USER_LOGIN))
#define USER_LOGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_LOGIN, UserLoginClass))

typedef struct _UserLogin UserLogin;
typedef struct _UserLoginClass UserLoginClass;

#define TYPE_GUEST_LOGIN (guest_login_get_type ())
#define GUEST_LOGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GUEST_LOGIN, GuestLogin))
#define GUEST_LOGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GUEST_LOGIN, GuestLoginClass))
#define IS_GUEST_LOGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GUEST_LOGIN))
#define IS_GUEST_LOGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GUEST_LOGIN))
#define GUEST_LOGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GUEST_LOGIN, GuestLoginClass))

typedef struct _GuestLogin GuestLogin;
typedef struct _GuestLoginClass GuestLoginClass;

#define TYPE_MANUAL_LOGIN (manual_login_get_type ())
#define MANUAL_LOGIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MANUAL_LOGIN, ManualLogin))
#define MANUAL_LOGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MANUAL_LOGIN, ManualLoginClass))
#define IS_MANUAL_LOGIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MANUAL_LOGIN))
#define IS_MANUAL_LOGIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MANUAL_LOGIN))
#define MANUAL_LOGIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MANUAL_LOGIN, ManualLoginClass))

typedef struct _ManualLogin ManualLogin;
typedef struct _ManualLoginClass ManualLoginClass;

struct _AccountsServiceUserIface {
	GTypeInterface parent_iface;
	gboolean (*get_locked) (AccountsServiceUser* self);
};

struct _UserList {
	GObject parent_instance;
	UserListPrivate * priv;
};

struct _UserListClass {
	GObjectClass parent_class;
};

struct _UserListPrivate {
	gint _size;
	GeeArrayList* users;
	LoginOption* _current_user;
};

typedef enum  {
	PROMPT_TYPE_SECRET,
	PROMPT_TYPE_QUESTION,
	PROMPT_TYPE_CONFIRM_LOGIN,
	PROMPT_TYPE_FPRINT
} PromptType;

typedef enum  {
	PROMPT_TEXT_USERNAME,
	PROMPT_TEXT_PASSWORD,
	PROMPT_TEXT_OTHER
} PromptText;

typedef enum  {
	MESSAGE_TEXT_FPRINT_SWIPE,
	MESSAGE_TEXT_FPRINT_SWIPE_AGAIN,
	MESSAGE_TEXT_FPRINT_SWIPE_TOO_SHORT,
	MESSAGE_TEXT_FPRINT_NOT_CENTERED,
	MESSAGE_TEXT_FPRINT_REMOVE,
	MESSAGE_TEXT_FPRINT_PLACE,
	MESSAGE_TEXT_FPRINT_PLACE_AGAIN,
	MESSAGE_TEXT_FPRINT_NO_MATCH,
	MESSAGE_TEXT_FPRINT_TIMEOUT,
	MESSAGE_TEXT_FPRINT_ERROR,
	MESSAGE_TEXT_FAILED,
	MESSAGE_TEXT_OTHER
} MessageText;

struct _LoginMaskIface {
	GTypeInterface parent_iface;
	void (*show_prompt) (LoginMask* self, PromptType type, PromptText prompttext, const gchar* text);
	void (*show_message) (LoginMask* self, LightDMMessageType type, MessageText messagetext, const gchar* text);
	void (*not_authenticated) (LoginMask* self);
	void (*login_aborted) (LoginMask* self);
	const gchar* (*get_login_name) (LoginMask* self);
	const gchar* (*get_login_session) (LoginMask* self);
};

struct _LoginGatewayIface {
	GTypeInterface parent_iface;
	void (*login_with_mask) (LoginGateway* self, LoginMask* mask, gboolean guest);
	void (*respond) (LoginGateway* self, const gchar* message);
	void (*start_session) (LoginGateway* self);
	gboolean (*get_hide_users) (LoginGateway* self);
	gboolean (*get_has_guest_account) (LoginGateway* self);
	gboolean (*get_show_manual_login) (LoginGateway* self);
	gboolean (*get_lock) (LoginGateway* self);
	const gchar* (*get_default_session) (LoginGateway* self);
	const gchar* (*get_select_user) (LoginGateway* self);
};


static gpointer user_list_parent_class = NULL;

GType accounts_service_user_get_type (void) G_GNUC_CONST;
GType accounts_service_user_proxy_get_type (void) G_GNUC_CONST;
guint accounts_service_user_register_object (void* object, GDBusConnection* connection, const gchar* path, GError** error);
gboolean accounts_service_user_get_locked (AccountsServiceUser* self);
static void accounts_service_user_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters);
static gboolean accounts_service_user_dbus_proxy_get_locked (AccountsServiceUser* self);
static void accounts_service_user_proxy_accounts_service_user_interface_init (AccountsServiceUserIface* iface);
static void accounts_service_user_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data);
static GVariant* accounts_service_user_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data);
static GVariant* _dbus_accounts_service_user_get_locked (AccountsServiceUser* self);
static gboolean accounts_service_user_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data);
static void _accounts_service_user_unregister_object (gpointer user_data);
GType user_list_get_type (void) G_GNUC_CONST;
GType login_option_get_type (void) G_GNUC_CONST;
#define USER_LIST_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_USER_LIST, UserListPrivate))
enum  {
	USER_LIST_DUMMY_PROPERTY,
	USER_LIST_SIZE,
	USER_LIST_CURRENT_USER
};
UserList* user_list_new (LightDMUserList* ld_users);
UserList* user_list_construct (GType object_type, LightDMUserList* ld_users);
GType prompt_type_get_type (void) G_GNUC_CONST;
GType prompt_text_get_type (void) G_GNUC_CONST;
GType message_text_get_type (void) G_GNUC_CONST;
GType login_mask_get_type (void) G_GNUC_CONST;
GType login_gateway_get_type (void) G_GNUC_CONST;
LoginGateway* pantheon_greeter_get_login_gateway (void);
gboolean login_gateway_get_hide_users (LoginGateway* self);
UserLogin* user_login_new (gint index, LightDMUser* user);
UserLogin* user_login_construct (GType object_type, gint index, LightDMUser* user);
GType user_login_get_type (void) G_GNUC_CONST;
gboolean login_gateway_get_has_guest_account (LoginGateway* self);
GuestLogin* guest_login_new (gint index);
GuestLogin* guest_login_construct (GType object_type, gint index);
GType guest_login_get_type (void) G_GNUC_CONST;
gboolean login_gateway_get_show_manual_login (LoginGateway* self);
ManualLogin* manual_login_new (gint index);
ManualLogin* manual_login_construct (GType object_type, gint index);
GType manual_login_get_type (void) G_GNUC_CONST;
static void user_list_set_size (UserList* self, gint value);
LoginOption* user_list_get_user (UserList* self, gint i);
void user_list_select_next_user (UserList* self);
LoginOption* user_list_get_next (UserList* self, LoginOption* user);
LoginOption* user_list_get_current_user (UserList* self);
void user_list_set_current_user (UserList* self, LoginOption* value);
void user_list_select_prev_user (UserList* self);
LoginOption* user_list_get_prev (UserList* self, LoginOption* user);
gint login_option_get_index (LoginOption* self);
gint user_list_get_size (UserList* self);
static void user_list_finalize (GObject* obj);
static void _vala_user_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_user_list_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);

static const GDBusMethodInfo * const _accounts_service_user_dbus_method_info[] = {NULL};
static const GDBusSignalInfo * const _accounts_service_user_dbus_signal_info[] = {NULL};
static const GDBusPropertyInfo _accounts_service_user_dbus_property_info_locked = {-1, "Locked", "b", G_DBUS_PROPERTY_INFO_FLAGS_READABLE};
static const GDBusPropertyInfo * const _accounts_service_user_dbus_property_info[] = {&_accounts_service_user_dbus_property_info_locked, NULL};
static const GDBusInterfaceInfo _accounts_service_user_dbus_interface_info = {-1, "org.freedesktop.Accounts.User", (GDBusMethodInfo **) (&_accounts_service_user_dbus_method_info), (GDBusSignalInfo **) (&_accounts_service_user_dbus_signal_info), (GDBusPropertyInfo **) (&_accounts_service_user_dbus_property_info)};
static const GDBusInterfaceVTable _accounts_service_user_dbus_interface_vtable = {accounts_service_user_dbus_interface_method_call, accounts_service_user_dbus_interface_get_property, accounts_service_user_dbus_interface_set_property};

gboolean accounts_service_user_get_locked (AccountsServiceUser* self) {
	g_return_val_if_fail (self != NULL, FALSE);
	return ACCOUNTS_SERVICE_USER_GET_INTERFACE (self)->get_locked (self);
}


static void accounts_service_user_base_init (AccountsServiceUserIface * iface) {
	static gboolean initialized = FALSE;
	if (!initialized) {
		initialized = TRUE;
	}
}


/***
    BEGIN LICENSE

    Copyright (C) 2011-2013 elementary Developers

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE.  See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program.  If not, see <http://www.gnu.org/licenses/>

    END LICENSE
***/
GType accounts_service_user_get_type (void) {
	static volatile gsize accounts_service_user_type_id__volatile = 0;
	if (g_once_init_enter (&accounts_service_user_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (AccountsServiceUserIface), (GBaseInitFunc) accounts_service_user_base_init, (GBaseFinalizeFunc) NULL, (GClassInitFunc) NULL, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
		GType accounts_service_user_type_id;
		accounts_service_user_type_id = g_type_register_static (G_TYPE_INTERFACE, "AccountsServiceUser", &g_define_type_info, 0);
		g_type_interface_add_prerequisite (accounts_service_user_type_id, G_TYPE_OBJECT);
		g_type_set_qdata (accounts_service_user_type_id, g_quark_from_static_string ("vala-dbus-proxy-type"), (void*) accounts_service_user_proxy_get_type);
		g_type_set_qdata (accounts_service_user_type_id, g_quark_from_static_string ("vala-dbus-interface-name"), "org.freedesktop.Accounts.User");
		g_type_set_qdata (accounts_service_user_type_id, g_quark_from_static_string ("vala-dbus-interface-info"), (void*) (&_accounts_service_user_dbus_interface_info));
		g_type_set_qdata (accounts_service_user_type_id, g_quark_from_static_string ("vala-dbus-register-object"), (void*) accounts_service_user_register_object);
		g_once_init_leave (&accounts_service_user_type_id__volatile, accounts_service_user_type_id);
	}
	return accounts_service_user_type_id__volatile;
}


G_DEFINE_TYPE_EXTENDED (AccountsServiceUserProxy, accounts_service_user_proxy, G_TYPE_DBUS_PROXY, 0, G_IMPLEMENT_INTERFACE (TYPE_ACCOUNTS_SERVICE_USER, accounts_service_user_proxy_accounts_service_user_interface_init) )
static void accounts_service_user_proxy_class_init (AccountsServiceUserProxyClass* klass) {
	G_DBUS_PROXY_CLASS (klass)->g_signal = accounts_service_user_proxy_g_signal;
}


static void accounts_service_user_proxy_g_signal (GDBusProxy* proxy, const gchar* sender_name, const gchar* signal_name, GVariant* parameters) {
}


static void accounts_service_user_proxy_init (AccountsServiceUserProxy* self) {
}


static gboolean accounts_service_user_dbus_proxy_get_locked (AccountsServiceUser* self) {
	GVariant *_inner_reply;
	gboolean _result;
	_inner_reply = g_dbus_proxy_get_cached_property ((GDBusProxy *) self, "Locked");
	if (!_inner_reply) {
		GVariant *_arguments;
		GVariant *_reply;
		GVariantBuilder _arguments_builder;
		g_variant_builder_init (&_arguments_builder, G_VARIANT_TYPE_TUPLE);
		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("org.freedesktop.Accounts.User"));
		g_variant_builder_add_value (&_arguments_builder, g_variant_new_string ("Locked"));
		_arguments = g_variant_builder_end (&_arguments_builder);
		_reply = g_dbus_proxy_call_sync ((GDBusProxy *) self, "org.freedesktop.DBus.Properties.Get", _arguments, G_DBUS_CALL_FLAGS_NONE, -1, NULL, NULL);
		if (!_reply) {
			return FALSE;
		}
		g_variant_get (_reply, "(v)", &_inner_reply);
		g_variant_unref (_reply);
	}
	_result = g_variant_get_boolean (_inner_reply);
	g_variant_unref (_inner_reply);
	return _result;
}


static void accounts_service_user_proxy_accounts_service_user_interface_init (AccountsServiceUserIface* iface) {
	iface->get_locked = accounts_service_user_dbus_proxy_get_locked;
}


static void accounts_service_user_dbus_interface_method_call (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* method_name, GVariant* parameters, GDBusMethodInvocation* invocation, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	g_object_unref (invocation);
}


static GVariant* _dbus_accounts_service_user_get_locked (AccountsServiceUser* self) {
	gboolean result;
	GVariant* _reply;
	result = accounts_service_user_get_locked (self);
	_reply = g_variant_new_boolean (result);
	return _reply;
}


static GVariant* accounts_service_user_dbus_interface_get_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	if (strcmp (property_name, "Locked") == 0) {
		return _dbus_accounts_service_user_get_locked (object);
	}
	return NULL;
}


static gboolean accounts_service_user_dbus_interface_set_property (GDBusConnection* connection, const gchar* sender, const gchar* object_path, const gchar* interface_name, const gchar* property_name, GVariant* value, GError** error, gpointer user_data) {
	gpointer* data;
	gpointer object;
	data = user_data;
	object = data[0];
	return FALSE;
}


guint accounts_service_user_register_object (gpointer object, GDBusConnection* connection, const gchar* path, GError** error) {
	guint result;
	gpointer *data;
	data = g_new (gpointer, 3);
	data[0] = g_object_ref (object);
	data[1] = g_object_ref (connection);
	data[2] = g_strdup (path);
	result = g_dbus_connection_register_object (connection, path, (GDBusInterfaceInfo *) (&_accounts_service_user_dbus_interface_info), &_accounts_service_user_dbus_interface_vtable, data, _accounts_service_user_unregister_object, error);
	if (!result) {
		return 0;
	}
	return result;
}


static void _accounts_service_user_unregister_object (gpointer user_data) {
	gpointer* data;
	data = user_data;
	g_object_unref (data[0]);
	g_object_unref (data[1]);
	g_free (data[2]);
	g_free (data);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


UserList* user_list_construct (GType object_type, LightDMUserList* ld_users) {
	UserList * self = NULL;
	gint index = 0;
	LoginGateway* _tmp0_ = NULL;
	LoginGateway* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	LoginGateway* _tmp27_ = NULL;
	LoginGateway* _tmp28_ = NULL;
	gboolean _tmp29_ = FALSE;
	gboolean _tmp30_ = FALSE;
	LoginGateway* _tmp36_ = NULL;
	LoginGateway* _tmp37_ = NULL;
	gboolean _tmp38_ = FALSE;
	gboolean _tmp39_ = FALSE;
	gint _tmp45_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (ld_users != NULL, NULL);
	self = (UserList*) g_object_new (object_type, NULL);
	index = 0;
	_tmp0_ = pantheon_greeter_get_login_gateway ();
	_tmp1_ = _tmp0_;
	_tmp2_ = login_gateway_get_hide_users (_tmp1_);
	_tmp3_ = _tmp2_;
	if (!_tmp3_) {
		LightDMUserList* _tmp4_ = NULL;
		GList* _tmp5_ = NULL;
		GList* _tmp6_ = NULL;
		_tmp4_ = ld_users;
		_tmp5_ = lightdm_user_list_get_users (_tmp4_);
		_tmp6_ = _tmp5_;
		{
			GList* this_user_collection = NULL;
			GList* this_user_it = NULL;
			this_user_collection = _tmp6_;
			for (this_user_it = this_user_collection; this_user_it != NULL; this_user_it = this_user_it->next) {
				LightDMUser* _tmp7_ = NULL;
				LightDMUser* this_user = NULL;
				_tmp7_ = _g_object_ref0 ((LightDMUser*) this_user_it->data);
				this_user = _tmp7_;
				{
					GeeArrayList* _tmp21_ = NULL;
					gint _tmp22_ = 0;
					LightDMUser* _tmp23_ = NULL;
					UserLogin* _tmp24_ = NULL;
					UserLogin* _tmp25_ = NULL;
					gint _tmp26_ = 0;
					{
						gchar* uid = NULL;
						LightDMUser* _tmp8_ = NULL;
						uid_t _tmp9_ = {0};
						gchar* _tmp10_ = NULL;
						AccountsServiceUser* accounts_user = NULL;
						const gchar* _tmp11_ = NULL;
						gchar* _tmp12_ = NULL;
						gchar* _tmp13_ = NULL;
						AccountsServiceUser* _tmp14_ = NULL;
						AccountsServiceUser* _tmp15_ = NULL;
						AccountsServiceUser* _tmp16_ = NULL;
						gboolean _tmp17_ = FALSE;
						gboolean _tmp18_ = FALSE;
						_tmp8_ = this_user;
						_tmp9_ = lightdm_user_get_uid (_tmp8_);
						_tmp10_ = g_strdup_printf ("%d", (gint) _tmp9_);
						uid = _tmp10_;
						_tmp11_ = uid;
						_tmp12_ = g_strconcat ("/org/freedesktop/Accounts/User", _tmp11_, NULL);
						_tmp13_ = _tmp12_;
						_tmp14_ = g_initable_new (TYPE_ACCOUNTS_SERVICE_USER_PROXY, NULL, &_inner_error_, "g-flags", 0, "g-name", "org.freedesktop.Accounts", "g-bus-type", G_BUS_TYPE_SYSTEM, "g-object-path", _tmp13_, "g-interface-name", "org.freedesktop.Accounts.User", "g-interface-info", g_type_get_qdata (TYPE_ACCOUNTS_SERVICE_USER, g_quark_from_static_string ("vala-dbus-interface-info")), NULL);
						_tmp15_ = (AccountsServiceUser*) _tmp14_;
						_g_free0 (_tmp13_);
						accounts_user = _tmp15_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_g_free0 (uid);
							goto __catch10_g_error;
						}
						_tmp16_ = accounts_user;
						_tmp17_ = accounts_service_user_get_locked (_tmp16_);
						_tmp18_ = _tmp17_;
						if (_tmp18_ == TRUE) {
							_g_object_unref0 (accounts_user);
							_g_free0 (uid);
							_g_object_unref0 (this_user);
							continue;
						}
						_g_object_unref0 (accounts_user);
						_g_free0 (uid);
					}
					goto __finally10;
					__catch10_g_error:
					{
						GError* e = NULL;
						GError* _tmp19_ = NULL;
						const gchar* _tmp20_ = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_tmp19_ = e;
						_tmp20_ = _tmp19_->message;
						g_warning ("UserList.vala:62: %s", _tmp20_);
						_g_error_free0 (e);
					}
					__finally10:
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_object_unref0 (this_user);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
					_tmp21_ = self->priv->users;
					_tmp22_ = index;
					_tmp23_ = this_user;
					_tmp24_ = user_login_new (_tmp22_, _tmp23_);
					_tmp25_ = _tmp24_;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp21_, (LoginOption*) _tmp25_);
					_g_object_unref0 (_tmp25_);
					_tmp26_ = index;
					index = _tmp26_ + 1;
					_g_object_unref0 (this_user);
				}
			}
		}
	}
	_tmp27_ = pantheon_greeter_get_login_gateway ();
	_tmp28_ = _tmp27_;
	_tmp29_ = login_gateway_get_has_guest_account (_tmp28_);
	_tmp30_ = _tmp29_;
	if (_tmp30_) {
		GeeArrayList* _tmp31_ = NULL;
		gint _tmp32_ = 0;
		GuestLogin* _tmp33_ = NULL;
		GuestLogin* _tmp34_ = NULL;
		gint _tmp35_ = 0;
		_tmp31_ = self->priv->users;
		_tmp32_ = index;
		_tmp33_ = guest_login_new (_tmp32_);
		_tmp34_ = _tmp33_;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp31_, (LoginOption*) _tmp34_);
		_g_object_unref0 (_tmp34_);
		_tmp35_ = index;
		index = _tmp35_ + 1;
	}
	_tmp36_ = pantheon_greeter_get_login_gateway ();
	_tmp37_ = _tmp36_;
	_tmp38_ = login_gateway_get_show_manual_login (_tmp37_);
	_tmp39_ = _tmp38_;
	if (_tmp39_) {
		GeeArrayList* _tmp40_ = NULL;
		gint _tmp41_ = 0;
		ManualLogin* _tmp42_ = NULL;
		ManualLogin* _tmp43_ = NULL;
		gint _tmp44_ = 0;
		_tmp40_ = self->priv->users;
		_tmp41_ = index;
		_tmp42_ = manual_login_new (_tmp41_);
		_tmp43_ = _tmp42_;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp40_, (LoginOption*) _tmp43_);
		_g_object_unref0 (_tmp43_);
		_tmp44_ = index;
		index = _tmp44_ + 1;
	}
	_tmp45_ = index;
	user_list_set_size (self, _tmp45_);
	return self;
}


UserList* user_list_new (LightDMUserList* ld_users) {
	return user_list_construct (TYPE_USER_LIST, ld_users);
}


LoginOption* user_list_get_user (UserList* self, gint i) {
	LoginOption* result = NULL;
	GeeArrayList* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gpointer _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->users;
	_tmp1_ = i;
	_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) _tmp0_, _tmp1_);
	result = (LoginOption*) _tmp2_;
	return result;
}


void user_list_select_next_user (UserList* self) {
	LoginOption* _tmp0_ = NULL;
	LoginOption* _tmp1_ = NULL;
	LoginOption* _tmp2_ = NULL;
	LoginOption* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = user_list_get_current_user (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = user_list_get_next (self, _tmp1_);
	_tmp3_ = _tmp2_;
	user_list_set_current_user (self, _tmp3_);
	_g_object_unref0 (_tmp3_);
}


void user_list_select_prev_user (UserList* self) {
	LoginOption* _tmp0_ = NULL;
	LoginOption* _tmp1_ = NULL;
	LoginOption* _tmp2_ = NULL;
	LoginOption* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = user_list_get_current_user (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = user_list_get_prev (self, _tmp1_);
	_tmp3_ = _tmp2_;
	user_list_set_current_user (self, _tmp3_);
	_g_object_unref0 (_tmp3_);
}


LoginOption* user_list_get_next (UserList* self, LoginOption* user) {
	LoginOption* result = NULL;
	gint i = 0;
	LoginOption* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp7_ = 0;
	LoginOption* _tmp8_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (user != NULL, NULL);
	_tmp0_ = user;
	_tmp1_ = login_option_get_index (_tmp0_);
	_tmp2_ = _tmp1_;
	i = _tmp2_;
	_tmp3_ = i;
	_tmp4_ = self->priv->_size;
	if (_tmp3_ < (_tmp4_ - 1)) {
		gint _tmp5_ = 0;
		LoginOption* _tmp6_ = NULL;
		_tmp5_ = i;
		_tmp6_ = user_list_get_user (self, _tmp5_ + 1);
		result = _tmp6_;
		return result;
	}
	_tmp7_ = i;
	_tmp8_ = user_list_get_user (self, _tmp7_);
	result = _tmp8_;
	return result;
}


LoginOption* user_list_get_prev (UserList* self, LoginOption* user) {
	LoginOption* result = NULL;
	gint i = 0;
	LoginOption* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp6_ = 0;
	LoginOption* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (user != NULL, NULL);
	_tmp0_ = user;
	_tmp1_ = login_option_get_index (_tmp0_);
	_tmp2_ = _tmp1_;
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ > 0) {
		gint _tmp4_ = 0;
		LoginOption* _tmp5_ = NULL;
		_tmp4_ = i;
		_tmp5_ = user_list_get_user (self, _tmp4_ - 1);
		result = _tmp5_;
		return result;
	}
	_tmp6_ = i;
	_tmp7_ = user_list_get_user (self, _tmp6_);
	result = _tmp7_;
	return result;
}


gint user_list_get_size (UserList* self) {
	gint result;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->priv->_size;
	result = _tmp0_;
	return result;
}


static void user_list_set_size (UserList* self, gint value) {
	gint _tmp0_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_size = _tmp0_;
	g_object_notify ((GObject *) self, "size");
}


LoginOption* user_list_get_current_user (UserList* self) {
	LoginOption* result;
	LoginOption* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_current_user;
	result = _tmp0_;
	return result;
}


void user_list_set_current_user (UserList* self, LoginOption* value) {
	LoginOption* _tmp0_ = NULL;
	LoginOption* _tmp1_ = NULL;
	LoginOption* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = user_list_get_current_user (self);
	_tmp2_ = _tmp1_;
	if (_tmp0_ != _tmp2_) {
		LoginOption* _tmp3_ = NULL;
		LoginOption* _tmp4_ = NULL;
		LoginOption* _tmp5_ = NULL;
		_tmp3_ = value;
		_tmp4_ = _g_object_ref0 (_tmp3_);
		_g_object_unref0 (self->priv->_current_user);
		self->priv->_current_user = _tmp4_;
		_tmp5_ = value;
		g_signal_emit_by_name (self, "current-user-changed", _tmp5_);
	}
	g_object_notify ((GObject *) self, "current-user");
}


static void user_list_class_init (UserListClass * klass) {
	user_list_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (UserListPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_user_list_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_user_list_set_property;
	G_OBJECT_CLASS (klass)->finalize = user_list_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), USER_LIST_SIZE, g_param_spec_int ("size", "size", "size", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), USER_LIST_CURRENT_USER, g_param_spec_object ("current-user", "current-user", "current-user", TYPE_LOGIN_OPTION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_signal_new ("current_user_changed", TYPE_USER_LIST, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__OBJECT, G_TYPE_NONE, 1, TYPE_LOGIN_OPTION);
}


static void user_list_instance_init (UserList * self) {
	GeeArrayList* _tmp0_ = NULL;
	self->priv = USER_LIST_GET_PRIVATE (self);
	_tmp0_ = gee_array_list_new (TYPE_LOGIN_OPTION, (GBoxedCopyFunc) g_object_ref, g_object_unref, NULL, NULL, NULL);
	self->priv->users = _tmp0_;
}


static void user_list_finalize (GObject* obj) {
	UserList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_USER_LIST, UserList);
	_g_object_unref0 (self->priv->users);
	_g_object_unref0 (self->priv->_current_user);
	G_OBJECT_CLASS (user_list_parent_class)->finalize (obj);
}


GType user_list_get_type (void) {
	static volatile gsize user_list_type_id__volatile = 0;
	if (g_once_init_enter (&user_list_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (UserListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) user_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (UserList), 0, (GInstanceInitFunc) user_list_instance_init, NULL };
		GType user_list_type_id;
		user_list_type_id = g_type_register_static (G_TYPE_OBJECT, "UserList", &g_define_type_info, 0);
		g_once_init_leave (&user_list_type_id__volatile, user_list_type_id);
	}
	return user_list_type_id__volatile;
}


static void _vala_user_list_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	UserList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_USER_LIST, UserList);
	switch (property_id) {
		case USER_LIST_SIZE:
		g_value_set_int (value, user_list_get_size (self));
		break;
		case USER_LIST_CURRENT_USER:
		g_value_set_object (value, user_list_get_current_user (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_user_list_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	UserList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_USER_LIST, UserList);
	switch (property_id) {
		case USER_LIST_SIZE:
		user_list_set_size (self, g_value_get_int (value));
		break;
		case USER_LIST_CURRENT_USER:
		user_list_set_current_user (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



