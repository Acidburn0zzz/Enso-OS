/* CredentialsArea.c generated by valac 0.30.1, the Vala compiler
 * generated from CredentialsArea.vala, do not modify */

/*
* Copyright (c) 2011-2017 elementary LLC. (http://launchpad.net/pantheon-greeter)
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License as published by the Free Software Foundation; either
* version 2 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* Boston, MA 02111-1307, USA.
*
*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <lightdm.h>
#include <stdlib.h>
#include <string.h>
#include <clutter-gtk/clutter-gtk.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gdk/gdk.h>


#define TYPE_CREDENTIALS_AREA (credentials_area_get_type ())
#define CREDENTIALS_AREA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CREDENTIALS_AREA, CredentialsArea))
#define CREDENTIALS_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CREDENTIALS_AREA, CredentialsAreaClass))
#define IS_CREDENTIALS_AREA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CREDENTIALS_AREA))
#define IS_CREDENTIALS_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CREDENTIALS_AREA))
#define CREDENTIALS_AREA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CREDENTIALS_AREA, CredentialsAreaClass))

typedef struct _CredentialsArea CredentialsArea;
typedef struct _CredentialsAreaClass CredentialsAreaClass;
typedef struct _CredentialsAreaPrivate CredentialsAreaPrivate;

#define TYPE_CREDENTIALS (credentials_get_type ())
#define CREDENTIALS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CREDENTIALS, Credentials))
#define IS_CREDENTIALS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CREDENTIALS))
#define CREDENTIALS_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_CREDENTIALS, CredentialsIface))

typedef struct _Credentials Credentials;
typedef struct _CredentialsIface CredentialsIface;

#define TYPE_MESSAGE_TEXT (message_text_get_type ())

#define TYPE_LOGIN_BOX (login_box_get_type ())
#define LOGIN_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_BOX, LoginBox))
#define LOGIN_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIN_BOX, LoginBoxClass))
#define IS_LOGIN_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_BOX))
#define IS_LOGIN_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIN_BOX))
#define LOGIN_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIN_BOX, LoginBoxClass))

typedef struct _LoginBox LoginBox;
typedef struct _LoginBoxClass LoginBoxClass;

#define TYPE_LOGIN_OPTION (login_option_get_type ())
#define LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_OPTION, LoginOption))
#define LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIN_OPTION, LoginOptionClass))
#define IS_LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_OPTION))
#define IS_LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIN_OPTION))
#define LOGIN_OPTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIN_OPTION, LoginOptionClass))

typedef struct _LoginOption LoginOption;
typedef struct _LoginOptionClass LoginOptionClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_PROMPT_TYPE (prompt_type_get_type ())

#define TYPE_PASSWORD_CREDENTIALS (password_credentials_get_type ())
#define PASSWORD_CREDENTIALS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PASSWORD_CREDENTIALS, PasswordCredentials))
#define PASSWORD_CREDENTIALS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PASSWORD_CREDENTIALS, PasswordCredentialsClass))
#define IS_PASSWORD_CREDENTIALS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PASSWORD_CREDENTIALS))
#define IS_PASSWORD_CREDENTIALS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PASSWORD_CREDENTIALS))
#define PASSWORD_CREDENTIALS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PASSWORD_CREDENTIALS, PasswordCredentialsClass))

typedef struct _PasswordCredentials PasswordCredentials;
typedef struct _PasswordCredentialsClass PasswordCredentialsClass;

#define TYPE_LOGIN_BUTTON_CREDENTIALS (login_button_credentials_get_type ())
#define LOGIN_BUTTON_CREDENTIALS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_BUTTON_CREDENTIALS, LoginButtonCredentials))
#define LOGIN_BUTTON_CREDENTIALS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIN_BUTTON_CREDENTIALS, LoginButtonCredentialsClass))
#define IS_LOGIN_BUTTON_CREDENTIALS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_BUTTON_CREDENTIALS))
#define IS_LOGIN_BUTTON_CREDENTIALS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIN_BUTTON_CREDENTIALS))
#define LOGIN_BUTTON_CREDENTIALS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIN_BUTTON_CREDENTIALS, LoginButtonCredentialsClass))

typedef struct _LoginButtonCredentials LoginButtonCredentials;
typedef struct _LoginButtonCredentialsClass LoginButtonCredentialsClass;
typedef struct _Block5Data Block5Data;
typedef struct _Block6Data Block6Data;

struct _CredentialsArea {
	GtkRevealer parent_instance;
	CredentialsAreaPrivate * priv;
};

struct _CredentialsAreaClass {
	GtkRevealerClass parent_class;
};

typedef enum  {
	MESSAGE_TEXT_FPRINT_SWIPE,
	MESSAGE_TEXT_FPRINT_SWIPE_AGAIN,
	MESSAGE_TEXT_FPRINT_SWIPE_TOO_SHORT,
	MESSAGE_TEXT_FPRINT_NOT_CENTERED,
	MESSAGE_TEXT_FPRINT_REMOVE,
	MESSAGE_TEXT_FPRINT_PLACE,
	MESSAGE_TEXT_FPRINT_PLACE_AGAIN,
	MESSAGE_TEXT_FPRINT_NO_MATCH,
	MESSAGE_TEXT_FPRINT_TIMEOUT,
	MESSAGE_TEXT_FPRINT_ERROR,
	MESSAGE_TEXT_FAILED,
	MESSAGE_TEXT_OTHER
} MessageText;

struct _CredentialsIface {
	GTypeInterface parent_iface;
	void (*show_message) (Credentials* self, LightDMMessageType type, MessageText messagetext, const gchar* text);
};

struct _CredentialsAreaPrivate {
	Credentials* credentials;
	gchar* _current_session;
	GtkEntry* login_name_entry;
	GtkGrid* grid;
	GtkListBox* settings_list;
	LoginBox* _login_box;
	LoginOption* _login_option;
};

typedef enum  {
	PROMPT_TYPE_SECRET,
	PROMPT_TYPE_QUESTION,
	PROMPT_TYPE_CONFIRM_LOGIN,
	PROMPT_TYPE_FPRINT
} PromptType;

struct _Block5Data {
	int _ref_count_;
	CredentialsArea* self;
	GtkRadioButton* button;
};

struct _Block6Data {
	int _ref_count_;
	Block5Data * _data5_;
	GtkRadioButton* radio;
	gchar* identifier;
};


static gpointer credentials_area_parent_class = NULL;

GType credentials_area_get_type (void) G_GNUC_CONST;
GType message_text_get_type (void) G_GNUC_CONST;
GType credentials_get_type (void) G_GNUC_CONST;
GType login_box_get_type (void) G_GNUC_CONST;
GType login_option_get_type (void) G_GNUC_CONST;
#define CREDENTIALS_AREA_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_CREDENTIALS_AREA, CredentialsAreaPrivate))
enum  {
	CREDENTIALS_AREA_DUMMY_PROPERTY,
	CREDENTIALS_AREA_CURRENT_SESSION,
	CREDENTIALS_AREA_LOGIN_BOX,
	CREDENTIALS_AREA_LOGIN_OPTION,
	CREDENTIALS_AREA_LOGIN_NAME
};
CredentialsArea* credentials_area_new (LoginBox* login_box, LoginOption* login_option);
CredentialsArea* credentials_area_construct (GType object_type, LoginBox* login_box, LoginOption* login_option);
void credentials_area_shake (CredentialsArea* self);
static gboolean __lambda4_ (CredentialsArea* self);
static gboolean ___lambda4__gsource_func (gpointer self);
void credentials_area_remove_credentials (CredentialsArea* self);
void credentials_area_pass_focus (CredentialsArea* self);
void credentials_area_show_message (CredentialsArea* self, LightDMMessageType type, MessageText messagetext, const gchar* text);
void credentials_show_message (Credentials* self, LightDMMessageType type, MessageText messagetext, const gchar* text);
GType prompt_type_get_type (void) G_GNUC_CONST;
void credentials_area_show_prompt (CredentialsArea* self, PromptType type);
PasswordCredentials* password_credentials_new (void);
PasswordCredentials* password_credentials_construct (GType object_type);
GType password_credentials_get_type (void) G_GNUC_CONST;
LoginButtonCredentials* login_button_credentials_new (void);
LoginButtonCredentials* login_button_credentials_construct (GType object_type);
GType login_button_credentials_get_type (void) G_GNUC_CONST;
const gchar* prompt_type_to_string (PromptType self);
static void __lambda8_ (CredentialsArea* self, const gchar* answer);
static void ___lambda8__credentials_replied (Credentials* _sender, const gchar* answer, gpointer self);
LoginBox* credentials_area_get_login_box (CredentialsArea* self);
gboolean login_box_get_selected (LoginBox* self);
static void credentials_area_create_settings_items (CredentialsArea* self);
static Block5Data* block5_data_ref (Block5Data* _data5_);
static void block5_data_unref (void * _userdata_);
const gchar* credentials_area_get_current_session (CredentialsArea* self);
static void __lambda9_ (Block5Data* _data5_);
void credentials_area_set_current_session (CredentialsArea* self, const gchar* value);
static void ___lambda9__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static Block6Data* block6_data_ref (Block6Data* _data6_);
static void block6_data_unref (void * _userdata_);
static void _____lambda10_ (Block6Data* _data6_);
static void ______lambda10__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self);
static void credentials_area_set_login_box (CredentialsArea* self, LoginBox* value);
LoginOption* credentials_area_get_login_option (CredentialsArea* self);
static void credentials_area_set_login_option (CredentialsArea* self, LoginOption* value);
const gchar* credentials_area_get_login_name (CredentialsArea* self);
static GObject * credentials_area_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
const gchar* login_option_get_session (LoginOption* self);
gchar* login_option_get_markup (LoginOption* self);
gboolean login_option_get_provides_login_name (LoginOption* self);
static void _credentials_area___lambda11_ (CredentialsArea* self);
static void __credentials_area___lambda11__gtk_entry_activate (GtkEntry* _sender, gpointer self);
static gboolean _credentials_area___lambda12_ (CredentialsArea* self, GdkEventFocus* e);
static gboolean __credentials_area___lambda12__gtk_widget_focus_in_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self);
static void _credentials_area___lambda13_ (CredentialsArea* self, GtkEntryIconPosition pos, GdkEvent* event);
static void __credentials_area___lambda13__gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self);
static void _credentials_area___lambda14_ (CredentialsArea* self, const gchar* answer);
static void __credentials_area___lambda14__credentials_area_replied (CredentialsArea* _sender, const gchar* text, gpointer self);
static void credentials_area_finalize (GObject* obj);
static void _vala_credentials_area_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_credentials_area_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


CredentialsArea* credentials_area_construct (GType object_type, LoginBox* login_box, LoginOption* login_option) {
	CredentialsArea * self = NULL;
	LoginBox* _tmp0_ = NULL;
	LoginOption* _tmp1_ = NULL;
	g_return_val_if_fail (login_box != NULL, NULL);
	g_return_val_if_fail (login_option != NULL, NULL);
	_tmp0_ = login_box;
	_tmp1_ = login_option;
	self = (CredentialsArea*) g_object_new (object_type, "login-box", _tmp0_, "login-option", _tmp1_, "transition-type", GTK_REVEALER_TRANSITION_TYPE_CROSSFADE, NULL);
	return self;
}


CredentialsArea* credentials_area_new (LoginBox* login_box, LoginOption* login_option) {
	return credentials_area_construct (TYPE_CREDENTIALS_AREA, login_box, login_option);
}


static gboolean __lambda4_ (CredentialsArea* self) {
	gboolean result = FALSE;
	GtkStyleContext* _tmp0_ = NULL;
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	gtk_style_context_remove_class (_tmp0_, "shake");
	result = FALSE;
	return result;
}


static gboolean ___lambda4__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda4_ ((CredentialsArea*) self);
	return result;
}


void credentials_area_shake (CredentialsArea* self) {
	GtkStyleContext* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
	gtk_style_context_add_class (_tmp0_, "shake");
	g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 450, ___lambda4__gsource_func, g_object_ref (self), g_object_unref);
}


void credentials_area_remove_credentials (CredentialsArea* self) {
	Credentials* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->credentials;
	if (_tmp0_ != NULL) {
		GtkGrid* _tmp1_ = NULL;
		Credentials* _tmp2_ = NULL;
		_tmp1_ = self->priv->grid;
		_tmp2_ = self->priv->credentials;
		gtk_container_remove ((GtkContainer*) _tmp1_, (GtkWidget*) _tmp2_);
		_g_object_unref0 (self->priv->credentials);
		self->priv->credentials = NULL;
	}
}


void credentials_area_pass_focus (CredentialsArea* self) {
	Credentials* _tmp0_ = NULL;
	GtkEntry* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->credentials;
	if (_tmp0_ != NULL) {
		Credentials* _tmp1_ = NULL;
		_tmp1_ = self->priv->credentials;
		gtk_widget_grab_focus ((GtkWidget*) _tmp1_);
	}
	_tmp2_ = self->priv->login_name_entry;
	if (_tmp2_ != NULL) {
		GtkEntry* _tmp3_ = NULL;
		_tmp3_ = self->priv->login_name_entry;
		gtk_widget_grab_focus ((GtkWidget*) _tmp3_);
	}
}


void credentials_area_show_message (CredentialsArea* self, LightDMMessageType type, MessageText messagetext, const gchar* text) {
	Credentials* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = self->priv->credentials;
	if (_tmp0_ != NULL) {
		Credentials* _tmp1_ = NULL;
		LightDMMessageType _tmp2_ = 0;
		MessageText _tmp3_ = 0;
		const gchar* _tmp4_ = NULL;
		_tmp1_ = self->priv->credentials;
		_tmp2_ = type;
		_tmp3_ = messagetext;
		_tmp4_ = text;
		credentials_show_message (_tmp1_, _tmp2_, _tmp3_, _tmp4_);
	}
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


static void __lambda8_ (CredentialsArea* self, const gchar* answer) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (answer != NULL);
	_tmp0_ = answer;
	g_signal_emit_by_name (self, "replied", _tmp0_);
}


static void ___lambda8__credentials_replied (Credentials* _sender, const gchar* answer, gpointer self) {
	__lambda8_ ((CredentialsArea*) self, answer);
}


void credentials_area_show_prompt (CredentialsArea* self, PromptType type) {
	PromptType _tmp0_ = 0;
	GtkGrid* _tmp8_ = NULL;
	Credentials* _tmp9_ = NULL;
	Credentials* _tmp10_ = NULL;
	GtkGrid* _tmp11_ = NULL;
	LoginBox* _tmp12_ = NULL;
	gboolean _tmp13_ = FALSE;
	gboolean _tmp14_ = FALSE;
	GtkEntry* _tmp16_ = NULL;
	g_return_if_fail (self != NULL);
	credentials_area_remove_credentials (self);
	_tmp0_ = type;
	switch (_tmp0_) {
		case PROMPT_TYPE_SECRET:
		{
			PasswordCredentials* _tmp1_ = NULL;
			_tmp1_ = password_credentials_new ();
			g_object_ref_sink (_tmp1_);
			_g_object_unref0 (self->priv->credentials);
			self->priv->credentials = (Credentials*) _tmp1_;
			break;
		}
		case PROMPT_TYPE_CONFIRM_LOGIN:
		{
			LoginButtonCredentials* _tmp2_ = NULL;
			_tmp2_ = login_button_credentials_new ();
			g_object_ref_sink (_tmp2_);
			_g_object_unref0 (self->priv->credentials);
			self->priv->credentials = (Credentials*) _tmp2_;
			break;
		}
		case PROMPT_TYPE_FPRINT:
		{
			break;
		}
		default:
		{
			PromptType _tmp3_ = 0;
			GEnumValue* _tmp4_;
			const gchar* _tmp5_ = NULL;
			gchar* _tmp6_ = NULL;
			gchar* _tmp7_ = NULL;
			_tmp3_ = type;
			_tmp4_ = g_enum_get_value (g_type_class_ref (TYPE_PROMPT_TYPE), _tmp3_);
			_tmp5_ = string_to_string ((_tmp4_ != NULL) ? _tmp4_->value_name : NULL);
			_tmp6_ = g_strconcat ("Not implemented ", _tmp5_, NULL);
			_tmp7_ = _tmp6_;
			g_warning ("CredentialsArea.vala:169: %s", _tmp7_);
			_g_free0 (_tmp7_);
			return;
		}
	}
	_tmp8_ = self->priv->grid;
	_tmp9_ = self->priv->credentials;
	gtk_grid_attach (_tmp8_, (GtkWidget*) _tmp9_, 0, 1, 1, 1);
	_tmp10_ = self->priv->credentials;
	g_signal_connect_object (_tmp10_, "replied", (GCallback) ___lambda8__credentials_replied, self, 0);
	_tmp11_ = self->priv->grid;
	gtk_widget_show_all ((GtkWidget*) _tmp11_);
	_tmp12_ = self->priv->_login_box;
	_tmp13_ = login_box_get_selected (_tmp12_);
	_tmp14_ = _tmp13_;
	if (_tmp14_) {
		Credentials* _tmp15_ = NULL;
		_tmp15_ = self->priv->credentials;
		gtk_widget_grab_focus ((GtkWidget*) _tmp15_);
	}
	_tmp16_ = self->priv->login_name_entry;
	if (_tmp16_ != NULL) {
		GtkEntry* _tmp17_ = NULL;
		_tmp17_ = self->priv->login_name_entry;
		gtk_widget_set_sensitive ((GtkWidget*) _tmp17_, TRUE);
	}
}


static Block5Data* block5_data_ref (Block5Data* _data5_) {
	g_atomic_int_inc (&_data5_->_ref_count_);
	return _data5_;
}


static void block5_data_unref (void * _userdata_) {
	Block5Data* _data5_;
	_data5_ = (Block5Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data5_->_ref_count_)) {
		CredentialsArea* self;
		self = _data5_->self;
		_g_object_unref0 (_data5_->button);
		_g_object_unref0 (self);
		g_slice_free (Block5Data, _data5_);
	}
}


static void __lambda9_ (Block5Data* _data5_) {
	CredentialsArea* self;
	GtkRadioButton* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	self = _data5_->self;
	_tmp0_ = _data5_->button;
	_tmp1_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		GList* _tmp3_ = NULL;
		gconstpointer _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		_tmp3_ = lightdm_get_sessions ();
		_tmp4_ = g_list_nth_data (_tmp3_, (guint) 0);
		_tmp5_ = lightdm_session_get_key ((LightDMSession*) _tmp4_);
		_tmp6_ = _tmp5_;
		credentials_area_set_current_session (self, _tmp6_);
	}
}


static void ___lambda9__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	__lambda9_ (self);
}


static Block6Data* block6_data_ref (Block6Data* _data6_) {
	g_atomic_int_inc (&_data6_->_ref_count_);
	return _data6_;
}


static void block6_data_unref (void * _userdata_) {
	Block6Data* _data6_;
	_data6_ = (Block6Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data6_->_ref_count_)) {
		CredentialsArea* self;
		self = _data6_->_data5_->self;
		_g_free0 (_data6_->identifier);
		_g_object_unref0 (_data6_->radio);
		block5_data_unref (_data6_->_data5_);
		_data6_->_data5_ = NULL;
		g_slice_free (Block6Data, _data6_);
	}
}


static void _____lambda10_ (Block6Data* _data6_) {
	Block5Data* _data5_;
	CredentialsArea* self;
	GtkRadioButton* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	_data5_ = _data6_->_data5_;
	self = _data5_->self;
	_tmp0_ = _data6_->radio;
	_tmp1_ = gtk_toggle_button_get_active ((GtkToggleButton*) _tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		const gchar* _tmp3_ = NULL;
		_tmp3_ = _data6_->identifier;
		credentials_area_set_current_session (self, _tmp3_);
	}
}


static void ______lambda10__gtk_toggle_button_toggled (GtkToggleButton* _sender, gpointer self) {
	_____lambda10_ (self);
}


static void credentials_area_create_settings_items (CredentialsArea* self) {
	Block5Data* _data5_;
	GList* _tmp0_ = NULL;
	gconstpointer _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GtkRadioButton* _tmp4_ = NULL;
	GtkRadioButton* _tmp5_ = NULL;
	GtkRadioButton* _tmp6_ = NULL;
	GtkRadioButton* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	gconstpointer _tmp9_ = NULL;
	const gchar* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	const gchar* _tmp12_ = NULL;
	GtkRadioButton* _tmp13_ = NULL;
	GtkListBoxRow* button_row = NULL;
	GtkListBoxRow* _tmp14_ = NULL;
	GtkListBoxRow* _tmp15_ = NULL;
	GtkStyleContext* _tmp16_ = NULL;
	GtkListBoxRow* _tmp17_ = NULL;
	GtkRadioButton* _tmp18_ = NULL;
	GtkListBox* _tmp19_ = NULL;
	GtkListBoxRow* _tmp20_ = NULL;
	GtkListBox* _tmp52_ = NULL;
	g_return_if_fail (self != NULL);
	_data5_ = g_slice_new0 (Block5Data);
	_data5_->_ref_count_ = 1;
	_data5_->self = g_object_ref (self);
	_tmp0_ = lightdm_get_sessions ();
	_tmp1_ = g_list_nth_data (_tmp0_, (guint) 0);
	_tmp2_ = lightdm_session_get_name ((LightDMSession*) _tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = (GtkRadioButton*) gtk_radio_button_new_with_label (NULL, _tmp3_);
	g_object_ref_sink (_tmp4_);
	_data5_->button = _tmp4_;
	_tmp5_ = _data5_->button;
	gtk_widget_set_margin_left ((GtkWidget*) _tmp5_, 6);
	_tmp6_ = _data5_->button;
	gtk_widget_set_margin_right ((GtkWidget*) _tmp6_, 6);
	_tmp7_ = _data5_->button;
	_tmp8_ = lightdm_get_sessions ();
	_tmp9_ = g_list_nth_data (_tmp8_, (guint) 0);
	_tmp10_ = lightdm_session_get_key ((LightDMSession*) _tmp9_);
	_tmp11_ = _tmp10_;
	_tmp12_ = self->priv->_current_session;
	gtk_toggle_button_set_active ((GtkToggleButton*) _tmp7_, g_strcmp0 (_tmp11_, _tmp12_) == 0);
	_tmp13_ = _data5_->button;
	g_signal_connect_data ((GtkToggleButton*) _tmp13_, "toggled", (GCallback) ___lambda9__gtk_toggle_button_toggled, block5_data_ref (_data5_), (GClosureNotify) block5_data_unref, 0);
	_tmp14_ = (GtkListBoxRow*) gtk_list_box_row_new ();
	g_object_ref_sink (_tmp14_);
	button_row = _tmp14_;
	_tmp15_ = button_row;
	_tmp16_ = gtk_widget_get_style_context ((GtkWidget*) _tmp15_);
	gtk_style_context_add_class (_tmp16_, GTK_STYLE_CLASS_MENUITEM);
	_tmp17_ = button_row;
	_tmp18_ = _data5_->button;
	gtk_container_add ((GtkContainer*) _tmp17_, (GtkWidget*) _tmp18_);
	_tmp19_ = self->priv->settings_list;
	_tmp20_ = button_row;
	gtk_container_add ((GtkContainer*) _tmp19_, (GtkWidget*) _tmp20_);
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp21_ = FALSE;
			_tmp21_ = TRUE;
			while (TRUE) {
				Block6Data* _data6_;
				gint _tmp23_ = 0;
				GList* _tmp24_ = NULL;
				guint _tmp25_ = 0U;
				GtkRadioButton* _tmp26_ = NULL;
				GList* _tmp27_ = NULL;
				gint _tmp28_ = 0;
				gconstpointer _tmp29_ = NULL;
				const gchar* _tmp30_ = NULL;
				const gchar* _tmp31_ = NULL;
				GtkRadioButton* _tmp32_ = NULL;
				GtkRadioButton* _tmp33_ = NULL;
				GtkRadioButton* _tmp34_ = NULL;
				GtkListBoxRow* radio_row = NULL;
				GtkListBoxRow* _tmp35_ = NULL;
				GtkListBoxRow* _tmp36_ = NULL;
				GtkStyleContext* _tmp37_ = NULL;
				GtkListBoxRow* _tmp38_ = NULL;
				GtkRadioButton* _tmp39_ = NULL;
				GtkListBox* _tmp40_ = NULL;
				GtkListBoxRow* _tmp41_ = NULL;
				GList* _tmp42_ = NULL;
				gint _tmp43_ = 0;
				gconstpointer _tmp44_ = NULL;
				const gchar* _tmp45_ = NULL;
				const gchar* _tmp46_ = NULL;
				gchar* _tmp47_ = NULL;
				GtkRadioButton* _tmp48_ = NULL;
				const gchar* _tmp49_ = NULL;
				const gchar* _tmp50_ = NULL;
				GtkRadioButton* _tmp51_ = NULL;
				_data6_ = g_slice_new0 (Block6Data);
				_data6_->_ref_count_ = 1;
				_data6_->_data5_ = block5_data_ref (_data5_);
				if (!_tmp21_) {
					gint _tmp22_ = 0;
					_tmp22_ = i;
					i = _tmp22_ + 1;
				}
				_tmp21_ = FALSE;
				_tmp23_ = i;
				_tmp24_ = lightdm_get_sessions ();
				_tmp25_ = g_list_length (_tmp24_);
				if (!(((guint) _tmp23_) < _tmp25_)) {
					block6_data_unref (_data6_);
					_data6_ = NULL;
					break;
				}
				_tmp26_ = _data5_->button;
				_tmp27_ = lightdm_get_sessions ();
				_tmp28_ = i;
				_tmp29_ = g_list_nth_data (_tmp27_, (guint) _tmp28_);
				_tmp30_ = lightdm_session_get_name ((LightDMSession*) _tmp29_);
				_tmp31_ = _tmp30_;
				_tmp32_ = (GtkRadioButton*) gtk_radio_button_new_with_label_from_widget (_tmp26_, _tmp31_);
				g_object_ref_sink (_tmp32_);
				_data6_->radio = _tmp32_;
				_tmp33_ = _data6_->radio;
				gtk_widget_set_margin_left ((GtkWidget*) _tmp33_, 6);
				_tmp34_ = _data6_->radio;
				gtk_widget_set_margin_right ((GtkWidget*) _tmp34_, 6);
				_tmp35_ = (GtkListBoxRow*) gtk_list_box_row_new ();
				g_object_ref_sink (_tmp35_);
				radio_row = _tmp35_;
				_tmp36_ = radio_row;
				_tmp37_ = gtk_widget_get_style_context ((GtkWidget*) _tmp36_);
				gtk_style_context_add_class (_tmp37_, GTK_STYLE_CLASS_MENUITEM);
				_tmp38_ = radio_row;
				_tmp39_ = _data6_->radio;
				gtk_container_add ((GtkContainer*) _tmp38_, (GtkWidget*) _tmp39_);
				_tmp40_ = self->priv->settings_list;
				_tmp41_ = radio_row;
				gtk_container_add ((GtkContainer*) _tmp40_, (GtkWidget*) _tmp41_);
				_tmp42_ = lightdm_get_sessions ();
				_tmp43_ = i;
				_tmp44_ = g_list_nth_data (_tmp42_, (guint) _tmp43_);
				_tmp45_ = lightdm_session_get_key ((LightDMSession*) _tmp44_);
				_tmp46_ = _tmp45_;
				_tmp47_ = g_strdup (_tmp46_);
				_data6_->identifier = _tmp47_;
				_tmp48_ = _data6_->radio;
				_tmp49_ = _data6_->identifier;
				_tmp50_ = self->priv->_current_session;
				gtk_toggle_button_set_active ((GtkToggleButton*) _tmp48_, g_strcmp0 (_tmp49_, _tmp50_) == 0);
				_tmp51_ = _data6_->radio;
				g_signal_connect_data ((GtkToggleButton*) _tmp51_, "toggled", (GCallback) ______lambda10__gtk_toggle_button_toggled, block6_data_ref (_data6_), (GClosureNotify) block6_data_unref, 0);
				_g_object_unref0 (radio_row);
				block6_data_unref (_data6_);
				_data6_ = NULL;
			}
		}
	}
	_tmp52_ = self->priv->settings_list;
	gtk_widget_show_all ((GtkWidget*) _tmp52_);
	_g_object_unref0 (button_row);
	block5_data_unref (_data5_);
	_data5_ = NULL;
}


const gchar* credentials_area_get_current_session (CredentialsArea* self) {
	const gchar* result;
	const gchar* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_current_session;
	result = _tmp0_;
	return result;
}


void credentials_area_set_current_session (CredentialsArea* self, const gchar* value) {
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->priv->_current_session);
	self->priv->_current_session = _tmp1_;
	g_object_notify ((GObject *) self, "current-session");
}


LoginBox* credentials_area_get_login_box (CredentialsArea* self) {
	LoginBox* result;
	LoginBox* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_login_box;
	result = _tmp0_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void credentials_area_set_login_box (CredentialsArea* self, LoginBox* value) {
	LoginBox* _tmp0_ = NULL;
	LoginBox* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_login_box);
	self->priv->_login_box = _tmp1_;
	g_object_notify ((GObject *) self, "login-box");
}


LoginOption* credentials_area_get_login_option (CredentialsArea* self) {
	LoginOption* result;
	LoginOption* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_login_option;
	result = _tmp0_;
	return result;
}


static void credentials_area_set_login_option (CredentialsArea* self, LoginOption* value) {
	LoginOption* _tmp0_ = NULL;
	LoginOption* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_login_option);
	self->priv->_login_option = _tmp1_;
	g_object_notify ((GObject *) self, "login-option");
}


const gchar* credentials_area_get_login_name (CredentialsArea* self) {
	const gchar* result;
	GtkEntry* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->login_name_entry;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void _credentials_area___lambda11_ (CredentialsArea* self) {
	GtkEntry* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	_tmp0_ = self->priv->login_name_entry;
	_tmp1_ = gtk_entry_get_text (_tmp0_);
	_tmp2_ = _tmp1_;
	g_signal_emit_by_name (self, "entered-login-name", _tmp2_);
}


static void __credentials_area___lambda11__gtk_entry_activate (GtkEntry* _sender, gpointer self) {
	_credentials_area___lambda11_ ((CredentialsArea*) self);
}


static gboolean _credentials_area___lambda12_ (CredentialsArea* self, GdkEventFocus* e) {
	gboolean result = FALSE;
	g_return_val_if_fail (e != NULL, FALSE);
	credentials_area_remove_credentials (self);
	result = FALSE;
	return result;
}


static gboolean __credentials_area___lambda12__gtk_widget_focus_in_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self) {
	gboolean result;
	result = _credentials_area___lambda12_ ((CredentialsArea*) self, event);
	return result;
}


static void _credentials_area___lambda13_ (CredentialsArea* self, GtkEntryIconPosition pos, GdkEvent* event) {
	GtkEntryIconPosition _tmp0_ = 0;
	g_return_if_fail (event != NULL);
	_tmp0_ = pos;
	if (_tmp0_ == GTK_ENTRY_ICON_SECONDARY) {
		GtkEntry* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		_tmp1_ = self->priv->login_name_entry;
		_tmp2_ = gtk_entry_get_text (_tmp1_);
		_tmp3_ = _tmp2_;
		g_signal_emit_by_name (self, "entered-login-name", _tmp3_);
	}
}


static void __credentials_area___lambda13__gtk_entry_icon_press (GtkEntry* _sender, GtkEntryIconPosition p0, GdkEvent* p1, gpointer self) {
	_credentials_area___lambda13_ ((CredentialsArea*) self, p0, p1);
}


static void _credentials_area___lambda14_ (CredentialsArea* self, const gchar* answer) {
	GtkEntry* _tmp0_ = NULL;
	g_return_if_fail (answer != NULL);
	_tmp0_ = self->priv->login_name_entry;
	gtk_widget_set_sensitive ((GtkWidget*) _tmp0_, FALSE);
}


static void __credentials_area___lambda14__credentials_area_replied (CredentialsArea* _sender, const gchar* text, gpointer self) {
	_credentials_area___lambda14_ ((CredentialsArea*) self, text);
}


static GObject * credentials_area_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	CredentialsArea * self;
	LoginOption* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GtkIconTheme* icon_theme = NULL;
	GtkIconTheme* _tmp3_ = NULL;
	GtkIconTheme* _tmp4_ = NULL;
	GtkLabel* login_name_label = NULL;
	LoginOption* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	GtkLabel* _tmp8_ = NULL;
	GtkLabel* _tmp9_ = NULL;
	GtkLabel* _tmp10_ = NULL;
	GtkLabel* _tmp11_ = NULL;
	GtkLabel* _tmp12_ = NULL;
	GtkStyleContext* _tmp13_ = NULL;
	GtkEntry* _tmp14_ = NULL;
	GtkEntry* _tmp15_ = NULL;
	GdkPixbuf* _tmp16_ = NULL;
	GtkIconTheme* _tmp17_ = NULL;
	GdkPixbuf* _tmp18_ = NULL;
	GtkEntry* _tmp19_ = NULL;
	GdkPixbuf* _tmp20_ = NULL;
	GtkIconTheme* _tmp21_ = NULL;
	GdkPixbuf* _tmp22_ = NULL;
	GtkEntry* _tmp23_ = NULL;
	GtkToggleButton* settings = NULL;
	GtkToggleButton* _tmp24_ = NULL;
	GtkToggleButton* _tmp25_ = NULL;
	GtkStyleContext* _tmp26_ = NULL;
	GtkToggleButton* _tmp27_ = NULL;
	GtkImage* _tmp28_ = NULL;
	GtkImage* _tmp29_ = NULL;
	GtkToggleButton* _tmp30_ = NULL;
	GtkToggleButton* _tmp31_ = NULL;
	GtkListBox* _tmp32_ = NULL;
	GtkListBox* _tmp33_ = NULL;
	GtkListBox* _tmp34_ = NULL;
	GtkPopover* settings_popover = NULL;
	GtkToggleButton* _tmp35_ = NULL;
	GtkPopover* _tmp36_ = NULL;
	GtkPopover* _tmp37_ = NULL;
	GtkPopover* _tmp38_ = NULL;
	GtkListBox* _tmp39_ = NULL;
	GtkPopover* _tmp40_ = NULL;
	GtkToggleButton* _tmp41_ = NULL;
	GtkGrid* _tmp42_ = NULL;
	GtkGrid* _tmp43_ = NULL;
	GtkGrid* _tmp44_ = NULL;
	LoginOption* _tmp45_ = NULL;
	gboolean _tmp46_ = FALSE;
	gboolean _tmp47_ = FALSE;
	GList* _tmp52_ = NULL;
	guint _tmp53_ = 0U;
	GtkGrid* _tmp56_ = NULL;
	GtkEntry* _tmp57_ = NULL;
	GtkEntry* _tmp58_ = NULL;
	GtkEntry* _tmp59_ = NULL;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (credentials_area_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CREDENTIALS_AREA, CredentialsArea);
	_tmp0_ = self->priv->_login_option;
	_tmp1_ = login_option_get_session (_tmp0_);
	_tmp2_ = _tmp1_;
	credentials_area_set_current_session (self, _tmp2_);
	_g_object_unref0 (self->priv->credentials);
	self->priv->credentials = NULL;
	_tmp3_ = gtk_icon_theme_get_default ();
	_tmp4_ = _g_object_ref0 (_tmp3_);
	icon_theme = _tmp4_;
	_tmp5_ = self->priv->_login_option;
	_tmp6_ = login_option_get_markup (_tmp5_);
	_tmp7_ = _tmp6_;
	_tmp8_ = (GtkLabel*) gtk_label_new (_tmp7_);
	g_object_ref_sink (_tmp8_);
	_tmp9_ = _tmp8_;
	_g_free0 (_tmp7_);
	login_name_label = _tmp9_;
	_tmp10_ = login_name_label;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp10_, TRUE);
	_tmp11_ = login_name_label;
	gtk_widget_set_halign ((GtkWidget*) _tmp11_, GTK_ALIGN_CENTER);
	_tmp12_ = login_name_label;
	_tmp13_ = gtk_widget_get_style_context ((GtkWidget*) _tmp12_);
	gtk_style_context_add_class (_tmp13_, "h2");
	_tmp14_ = (GtkEntry*) gtk_entry_new ();
	g_object_ref_sink (_tmp14_);
	_g_object_unref0 (self->priv->login_name_entry);
	self->priv->login_name_entry = _tmp14_;
	_tmp15_ = self->priv->login_name_entry;
	gtk_widget_set_hexpand ((GtkWidget*) _tmp15_, TRUE);
	_tmp17_ = icon_theme;
	_tmp18_ = gtk_icon_theme_load_icon (_tmp17_, "avatar-default-symbolic", 22, 0, &_inner_error_);
	_tmp16_ = _tmp18_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (login_name_label);
		_g_object_unref0 (icon_theme);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp19_ = self->priv->login_name_entry;
	gtk_entry_set_icon_from_pixbuf (_tmp19_, GTK_ENTRY_ICON_PRIMARY, _tmp16_);
	_tmp21_ = icon_theme;
	_tmp22_ = gtk_icon_theme_load_icon (_tmp21_, "go-jump-symbolic", 22, 0, &_inner_error_);
	_tmp20_ = _tmp22_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (_tmp16_);
		_g_object_unref0 (login_name_label);
		_g_object_unref0 (icon_theme);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
	}
	_tmp23_ = self->priv->login_name_entry;
	gtk_entry_set_icon_from_pixbuf (_tmp23_, GTK_ENTRY_ICON_SECONDARY, _tmp20_);
	_tmp24_ = (GtkToggleButton*) gtk_toggle_button_new ();
	g_object_ref_sink (_tmp24_);
	settings = _tmp24_;
	_tmp25_ = settings;
	_tmp26_ = gtk_widget_get_style_context ((GtkWidget*) _tmp25_);
	gtk_style_context_add_class (_tmp26_, GTK_STYLE_CLASS_FLAT);
	_tmp27_ = settings;
	_tmp28_ = (GtkImage*) gtk_image_new_from_icon_name ("application-menu-symbolic", GTK_ICON_SIZE_MENU);
	g_object_ref_sink (_tmp28_);
	_tmp29_ = _tmp28_;
	gtk_button_set_image ((GtkButton*) _tmp27_, (GtkWidget*) _tmp29_);
	_g_object_unref0 (_tmp29_);
	_tmp30_ = settings;
	gtk_widget_set_size_request ((GtkWidget*) _tmp30_, 32, 32);
	_tmp31_ = settings;
	gtk_widget_set_valign ((GtkWidget*) _tmp31_, GTK_ALIGN_CENTER);
	_tmp32_ = (GtkListBox*) gtk_list_box_new ();
	g_object_ref_sink (_tmp32_);
	_g_object_unref0 (self->priv->settings_list);
	self->priv->settings_list = _tmp32_;
	_tmp33_ = self->priv->settings_list;
	gtk_widget_set_margin_bottom ((GtkWidget*) _tmp33_, 3);
	_tmp34_ = self->priv->settings_list;
	gtk_widget_set_margin_top ((GtkWidget*) _tmp34_, 3);
	_tmp35_ = settings;
	_tmp36_ = (GtkPopover*) gtk_popover_new ((GtkWidget*) _tmp35_);
	g_object_ref_sink (_tmp36_);
	settings_popover = _tmp36_;
	_tmp37_ = settings_popover;
	gtk_popover_set_position (_tmp37_, GTK_POS_BOTTOM);
	_tmp38_ = settings_popover;
	_tmp39_ = self->priv->settings_list;
	gtk_container_add ((GtkContainer*) _tmp38_, (GtkWidget*) _tmp39_);
	_tmp40_ = settings_popover;
	_tmp41_ = settings;
	g_object_bind_property_with_closures ((GObject*) _tmp40_, "visible", (GObject*) _tmp41_, "active", G_BINDING_BIDIRECTIONAL, (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)), (GClosure*) ((NULL == NULL) ? NULL : g_cclosure_new ((GCallback) NULL, NULL, NULL)));
	_tmp42_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp42_);
	_g_object_unref0 (self->priv->grid);
	self->priv->grid = _tmp42_;
	_tmp43_ = self->priv->grid;
	gtk_grid_set_column_spacing (_tmp43_, 6);
	_tmp44_ = self->priv->grid;
	gtk_grid_set_row_spacing (_tmp44_, 12);
	_tmp45_ = self->priv->_login_option;
	_tmp46_ = login_option_get_provides_login_name (_tmp45_);
	_tmp47_ = _tmp46_;
	if (_tmp47_) {
		GtkGrid* _tmp48_ = NULL;
		GtkLabel* _tmp49_ = NULL;
		_tmp48_ = self->priv->grid;
		_tmp49_ = login_name_label;
		gtk_grid_attach (_tmp48_, (GtkWidget*) _tmp49_, 0, 0, 1, 1);
	} else {
		GtkGrid* _tmp50_ = NULL;
		GtkEntry* _tmp51_ = NULL;
		_tmp50_ = self->priv->grid;
		_tmp51_ = self->priv->login_name_entry;
		gtk_grid_attach (_tmp50_, (GtkWidget*) _tmp51_, 0, 0, 1, 1);
	}
	_tmp52_ = lightdm_get_sessions ();
	_tmp53_ = g_list_length (_tmp52_);
	if (_tmp53_ > ((guint) 1)) {
		GtkGrid* _tmp54_ = NULL;
		GtkToggleButton* _tmp55_ = NULL;
		credentials_area_create_settings_items (self);
		_tmp54_ = self->priv->grid;
		_tmp55_ = settings;
		gtk_grid_attach (_tmp54_, (GtkWidget*) _tmp55_, 0, 2, 1, 1);
	}
	_tmp56_ = self->priv->grid;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp56_);
	_tmp57_ = self->priv->login_name_entry;
	g_signal_connect_object (_tmp57_, "activate", (GCallback) __credentials_area___lambda11__gtk_entry_activate, self, 0);
	_tmp58_ = self->priv->login_name_entry;
	g_signal_connect_object ((GtkWidget*) _tmp58_, "focus-in-event", (GCallback) __credentials_area___lambda12__gtk_widget_focus_in_event, self, 0);
	_tmp59_ = self->priv->login_name_entry;
	g_signal_connect_object (_tmp59_, "icon-press", (GCallback) __credentials_area___lambda13__gtk_entry_icon_press, self, 0);
	g_signal_connect_object (self, "replied", (GCallback) __credentials_area___lambda14__credentials_area_replied, self, 0);
	gtk_widget_show_all ((GtkWidget*) self);
	_g_object_unref0 (settings_popover);
	_g_object_unref0 (settings);
	_g_object_unref0 (_tmp20_);
	_g_object_unref0 (_tmp16_);
	_g_object_unref0 (login_name_label);
	_g_object_unref0 (icon_theme);
	return obj;
}


static void credentials_area_class_init (CredentialsAreaClass * klass) {
	credentials_area_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (CredentialsAreaPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_credentials_area_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_credentials_area_set_property;
	G_OBJECT_CLASS (klass)->constructor = credentials_area_constructor;
	G_OBJECT_CLASS (klass)->finalize = credentials_area_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), CREDENTIALS_AREA_CURRENT_SESSION, g_param_spec_string ("current-session", "current-session", "current-session", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), CREDENTIALS_AREA_LOGIN_BOX, g_param_spec_object ("login-box", "login-box", "login-box", TYPE_LOGIN_BOX, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), CREDENTIALS_AREA_LOGIN_OPTION, g_param_spec_object ("login-option", "login-option", "login-option", TYPE_LOGIN_OPTION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
	g_object_class_install_property (G_OBJECT_CLASS (klass), CREDENTIALS_AREA_LOGIN_NAME, g_param_spec_string ("login-name", "login-name", "login-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	/**
	     * Fired when the user has replied to a prompt (aka: password,
	     * login-button was pressed). Should get forwarded to the
	     * LoginGateway.
	     */
	g_signal_new ("replied", TYPE_CREDENTIALS_AREA, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
	g_signal_new ("entered_login_name", TYPE_CREDENTIALS_AREA, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void credentials_area_instance_init (CredentialsArea * self) {
	self->priv = CREDENTIALS_AREA_GET_PRIVATE (self);
	self->priv->login_name_entry = NULL;
}


static void credentials_area_finalize (GObject* obj) {
	CredentialsArea * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_CREDENTIALS_AREA, CredentialsArea);
	_g_object_unref0 (self->priv->credentials);
	_g_free0 (self->priv->_current_session);
	_g_object_unref0 (self->priv->login_name_entry);
	_g_object_unref0 (self->priv->grid);
	_g_object_unref0 (self->priv->settings_list);
	_g_object_unref0 (self->priv->_login_box);
	_g_object_unref0 (self->priv->_login_option);
	G_OBJECT_CLASS (credentials_area_parent_class)->finalize (obj);
}


GType credentials_area_get_type (void) {
	static volatile gsize credentials_area_type_id__volatile = 0;
	if (g_once_init_enter (&credentials_area_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (CredentialsAreaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) credentials_area_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (CredentialsArea), 0, (GInstanceInitFunc) credentials_area_instance_init, NULL };
		GType credentials_area_type_id;
		credentials_area_type_id = g_type_register_static (gtk_revealer_get_type (), "CredentialsArea", &g_define_type_info, 0);
		g_once_init_leave (&credentials_area_type_id__volatile, credentials_area_type_id);
	}
	return credentials_area_type_id__volatile;
}


static void _vala_credentials_area_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	CredentialsArea * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CREDENTIALS_AREA, CredentialsArea);
	switch (property_id) {
		case CREDENTIALS_AREA_CURRENT_SESSION:
		g_value_set_string (value, credentials_area_get_current_session (self));
		break;
		case CREDENTIALS_AREA_LOGIN_BOX:
		g_value_set_object (value, credentials_area_get_login_box (self));
		break;
		case CREDENTIALS_AREA_LOGIN_OPTION:
		g_value_set_object (value, credentials_area_get_login_option (self));
		break;
		case CREDENTIALS_AREA_LOGIN_NAME:
		g_value_set_string (value, credentials_area_get_login_name (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_credentials_area_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	CredentialsArea * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_CREDENTIALS_AREA, CredentialsArea);
	switch (property_id) {
		case CREDENTIALS_AREA_CURRENT_SESSION:
		credentials_area_set_current_session (self, g_value_get_string (value));
		break;
		case CREDENTIALS_AREA_LOGIN_BOX:
		credentials_area_set_login_box (self, g_value_get_object (value));
		break;
		case CREDENTIALS_AREA_LOGIN_OPTION:
		credentials_area_set_login_option (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



