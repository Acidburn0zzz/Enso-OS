/* LoginBox.c generated by valac 0.30.1, the Vala compiler
 * generated from LoginBox.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/
/*
* Copyright (c) 2011-2017 elementary LLC. (http://launchpad.net/pantheon-greeter)
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public
* License as published by the Free Software Foundation; either
* version 2 of the License, or (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public
* License along with this program; if not, write to the
* Free Software Foundation, Inc., 59 Temple Place - Suite 330,
* Boston, MA 02111-1307, USA.
*
*/

#include <glib.h>
#include <glib-object.h>
#include <clutter-gtk/clutter-gtk.h>
#include <stdlib.h>
#include <string.h>
#include <lightdm.h>
#include <gtk/gtk.h>
#include <clutter/clutter.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <float.h>
#include <math.h>


#define TYPE_LOGIN_MASK (login_mask_get_type ())
#define LOGIN_MASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_MASK, LoginMask))
#define IS_LOGIN_MASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_MASK))
#define LOGIN_MASK_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_LOGIN_MASK, LoginMaskIface))

typedef struct _LoginMask LoginMask;
typedef struct _LoginMaskIface LoginMaskIface;

#define TYPE_PROMPT_TYPE (prompt_type_get_type ())

#define TYPE_PROMPT_TEXT (prompt_text_get_type ())

#define TYPE_MESSAGE_TEXT (message_text_get_type ())

#define TYPE_LOGIN_BOX (login_box_get_type ())
#define LOGIN_BOX(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_BOX, LoginBox))
#define LOGIN_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIN_BOX, LoginBoxClass))
#define IS_LOGIN_BOX(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_BOX))
#define IS_LOGIN_BOX_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIN_BOX))
#define LOGIN_BOX_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIN_BOX, LoginBoxClass))

typedef struct _LoginBox LoginBox;
typedef struct _LoginBoxClass LoginBoxClass;
typedef struct _LoginBoxPrivate LoginBoxPrivate;

#define TYPE_CREDENTIALS_AREA (credentials_area_get_type ())
#define CREDENTIALS_AREA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_CREDENTIALS_AREA, CredentialsArea))
#define CREDENTIALS_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_CREDENTIALS_AREA, CredentialsAreaClass))
#define IS_CREDENTIALS_AREA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_CREDENTIALS_AREA))
#define IS_CREDENTIALS_AREA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_CREDENTIALS_AREA))
#define CREDENTIALS_AREA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_CREDENTIALS_AREA, CredentialsAreaClass))

typedef struct _CredentialsArea CredentialsArea;
typedef struct _CredentialsAreaClass CredentialsAreaClass;

#define TYPE_LOGIN_OPTION (login_option_get_type ())
#define LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_OPTION, LoginOption))
#define LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIN_OPTION, LoginOptionClass))
#define IS_LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_OPTION))
#define IS_LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIN_OPTION))
#define LOGIN_OPTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIN_OPTION, LoginOptionClass))

typedef struct _LoginOption LoginOption;
typedef struct _LoginOptionClass LoginOptionClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_LOGIN_GATEWAY (login_gateway_get_type ())
#define LOGIN_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_GATEWAY, LoginGateway))
#define IS_LOGIN_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_GATEWAY))
#define LOGIN_GATEWAY_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_LOGIN_GATEWAY, LoginGatewayIface))

typedef struct _LoginGateway LoginGateway;
typedef struct _LoginGatewayIface LoginGatewayIface;
#define _g_free0(var) (var = (g_free (var), NULL))

typedef enum  {
	PROMPT_TYPE_SECRET,
	PROMPT_TYPE_QUESTION,
	PROMPT_TYPE_CONFIRM_LOGIN,
	PROMPT_TYPE_FPRINT
} PromptType;

typedef enum  {
	PROMPT_TEXT_USERNAME,
	PROMPT_TEXT_PASSWORD,
	PROMPT_TEXT_OTHER
} PromptText;

typedef enum  {
	MESSAGE_TEXT_FPRINT_SWIPE,
	MESSAGE_TEXT_FPRINT_SWIPE_AGAIN,
	MESSAGE_TEXT_FPRINT_SWIPE_TOO_SHORT,
	MESSAGE_TEXT_FPRINT_NOT_CENTERED,
	MESSAGE_TEXT_FPRINT_REMOVE,
	MESSAGE_TEXT_FPRINT_PLACE,
	MESSAGE_TEXT_FPRINT_PLACE_AGAIN,
	MESSAGE_TEXT_FPRINT_NO_MATCH,
	MESSAGE_TEXT_FPRINT_TIMEOUT,
	MESSAGE_TEXT_FPRINT_ERROR,
	MESSAGE_TEXT_FAILED,
	MESSAGE_TEXT_OTHER
} MessageText;

struct _LoginMaskIface {
	GTypeInterface parent_iface;
	void (*show_prompt) (LoginMask* self, PromptType type, PromptText prompttext, const gchar* text);
	void (*show_message) (LoginMask* self, LightDMMessageType type, MessageText messagetext, const gchar* text);
	void (*not_authenticated) (LoginMask* self);
	void (*login_aborted) (LoginMask* self);
	const gchar* (*get_login_name) (LoginMask* self);
	const gchar* (*get_login_session) (LoginMask* self);
};

struct _LoginBox {
	GtkClutterActor parent_instance;
	LoginBoxPrivate * priv;
};

struct _LoginBoxClass {
	GtkClutterActorClass parent_class;
};

struct _LoginBoxPrivate {
	CredentialsArea* credentials_area;
	gboolean _selected;
	LoginOption* _user;
};

struct _LoginGatewayIface {
	GTypeInterface parent_iface;
	void (*login_with_mask) (LoginGateway* self, LoginMask* mask, gboolean guest);
	void (*respond) (LoginGateway* self, const gchar* message);
	void (*start_session) (LoginGateway* self);
	gboolean (*get_hide_users) (LoginGateway* self);
	gboolean (*get_has_guest_account) (LoginGateway* self);
	gboolean (*get_show_manual_login) (LoginGateway* self);
	gboolean (*get_lock) (LoginGateway* self);
	const gchar* (*get_default_session) (LoginGateway* self);
	const gchar* (*get_select_user) (LoginGateway* self);
};


static gpointer login_box_parent_class = NULL;
static LoginMaskIface* login_box_login_mask_parent_iface = NULL;

GType prompt_type_get_type (void) G_GNUC_CONST;
GType prompt_text_get_type (void) G_GNUC_CONST;
GType message_text_get_type (void) G_GNUC_CONST;
GType login_mask_get_type (void) G_GNUC_CONST;
GType login_box_get_type (void) G_GNUC_CONST;
GType credentials_area_get_type (void) G_GNUC_CONST;
GType login_option_get_type (void) G_GNUC_CONST;
#define LOGIN_BOX_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_LOGIN_BOX, LoginBoxPrivate))
enum  {
	LOGIN_BOX_DUMMY_PROPERTY,
	LOGIN_BOX_SELECTED,
	LOGIN_BOX_LOGIN_NAME,
	LOGIN_BOX_LOGIN_SESSION,
	LOGIN_BOX_USER
};
LoginBox* login_box_new (LoginOption* user);
LoginBox* login_box_construct (GType object_type, LoginOption* user);
static void login_box_start_login (LoginBox* self);
GType login_gateway_get_type (void) G_GNUC_CONST;
LoginGateway* pantheon_greeter_get_login_gateway (void);
void login_gateway_login_with_mask (LoginGateway* self, LoginMask* mask, gboolean guest);
LoginOption* login_box_get_user (LoginBox* self);
gboolean login_option_get_is_guest (LoginOption* self);
void login_box_pass_focus (LoginBox* self);
gboolean login_option_get_provides_login_name (LoginOption* self);
void credentials_area_pass_focus (CredentialsArea* self);
static void login_box_shake (LoginBox* self);
void credentials_area_shake (CredentialsArea* self);
static void login_box_real_show_prompt (LoginMask* base, PromptType type, PromptText prompttext, const gchar* text);
void credentials_area_show_prompt (CredentialsArea* self, PromptType type);
static void login_box_real_show_message (LoginMask* base, LightDMMessageType type, MessageText messagetext, const gchar* text);
void credentials_area_show_message (CredentialsArea* self, LightDMMessageType type, MessageText messagetext, const gchar* text);
static void login_box_real_not_authenticated (LoginMask* base);
void credentials_area_remove_credentials (CredentialsArea* self);
static void login_box_real_login_aborted (LoginMask* base);
gboolean login_box_get_selected (LoginBox* self);
void login_box_set_selected (LoginBox* self, gboolean value);
const gchar* login_option_get_name (LoginOption* self);
const gchar* credentials_area_get_login_name (CredentialsArea* self);
const gchar* credentials_area_get_current_session (CredentialsArea* self);
static void login_box_set_user (LoginBox* self, LoginOption* value);
static GObject * login_box_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
CredentialsArea* credentials_area_new (LoginBox* login_box, LoginOption* login_option);
CredentialsArea* credentials_area_construct (GType object_type, LoginBox* login_box, LoginOption* login_option);
const gchar* login_option_get_avatar_path (LoginOption* self);
gboolean login_option_get_logged_in (LoginOption* self);
#define CONSTANTS_PKGDATADIR "/usr/share/enso/greeter"
static void _login_box___lambda15_ (LoginBox* self, const gchar* answer);
void login_gateway_respond (LoginGateway* self, const gchar* message);
static void __login_box___lambda15__credentials_area_replied (CredentialsArea* _sender, const gchar* text, gpointer self);
static void _login_box___lambda16_ (LoginBox* self, const gchar* name);
static void __login_box___lambda16__credentials_area_entered_login_name (CredentialsArea* _sender, const gchar* name, gpointer self);
static void login_box_finalize (GObject* obj);
const gchar* login_mask_get_login_name (LoginMask* self);
const gchar* login_mask_get_login_session (LoginMask* self);
static void _vala_login_box_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_login_box_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


LoginBox* login_box_construct (GType object_type, LoginOption* user) {
	LoginBox * self = NULL;
	LoginOption* _tmp0_ = NULL;
	g_return_val_if_fail (user != NULL, NULL);
	_tmp0_ = user;
	self = (LoginBox*) g_object_new (object_type, "user", _tmp0_, NULL);
	return self;
}


LoginBox* login_box_new (LoginOption* user) {
	return login_box_construct (TYPE_LOGIN_BOX, user);
}


/**
     * Starts the login procedure. Necessary to call this before the user
     * can enter something so that the LoginGateway can tell
     * us what kind of prompt he wants.
     */
static void login_box_start_login (LoginBox* self) {
	LoginGateway* _tmp0_ = NULL;
	LoginGateway* _tmp1_ = NULL;
	LoginOption* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = pantheon_greeter_get_login_gateway ();
	_tmp1_ = _tmp0_;
	_tmp2_ = self->priv->_user;
	_tmp3_ = login_option_get_is_guest (_tmp2_);
	_tmp4_ = _tmp3_;
	login_gateway_login_with_mask (_tmp1_, (LoginMask*) self, _tmp4_);
}


void login_box_pass_focus (LoginBox* self) {
	LoginOption* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	CredentialsArea* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->_user;
	_tmp1_ = login_option_get_provides_login_name (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		login_box_start_login (self);
	}
	_tmp3_ = self->priv->credentials_area;
	credentials_area_pass_focus (_tmp3_);
}


static void login_box_shake (LoginBox* self) {
	CredentialsArea* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->credentials_area;
	credentials_area_shake (_tmp0_);
	login_box_start_login (self);
	return;
}


static void login_box_real_show_prompt (LoginMask* base, PromptType type, PromptText prompttext, const gchar* text) {
	LoginBox * self;
	CredentialsArea* _tmp0_ = NULL;
	PromptType _tmp1_ = 0;
	self = (LoginBox*) base;
	g_return_if_fail (text != NULL);
	_tmp0_ = self->priv->credentials_area;
	_tmp1_ = type;
	credentials_area_show_prompt (_tmp0_, _tmp1_);
}


static void login_box_real_show_message (LoginMask* base, LightDMMessageType type, MessageText messagetext, const gchar* text) {
	LoginBox * self;
	CredentialsArea* _tmp0_ = NULL;
	LightDMMessageType _tmp1_ = 0;
	MessageText _tmp2_ = 0;
	const gchar* _tmp3_ = NULL;
	self = (LoginBox*) base;
	g_return_if_fail (text != NULL);
	_tmp0_ = self->priv->credentials_area;
	_tmp1_ = type;
	_tmp2_ = messagetext;
	_tmp3_ = text;
	credentials_area_show_message (_tmp0_, _tmp1_, _tmp2_, _tmp3_);
}


static void login_box_real_not_authenticated (LoginMask* base) {
	LoginBox * self;
	CredentialsArea* _tmp0_ = NULL;
	self = (LoginBox*) base;
	_tmp0_ = self->priv->credentials_area;
	credentials_area_remove_credentials (_tmp0_);
	login_box_shake (self);
}


static void login_box_real_login_aborted (LoginMask* base) {
	LoginBox * self;
	CredentialsArea* _tmp0_ = NULL;
	self = (LoginBox*) base;
	_tmp0_ = self->priv->credentials_area;
	credentials_area_remove_credentials (_tmp0_);
}


gboolean login_box_get_selected (LoginBox* self) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->priv->_selected;
	result = _tmp0_;
	return result;
}


void login_box_set_selected (LoginBox* self, gboolean value) {
	gboolean _tmp0_ = FALSE;
	CredentialsArea* _tmp1_ = NULL;
	CredentialsArea* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_selected = _tmp0_;
	_tmp1_ = self->priv->credentials_area;
	credentials_area_remove_credentials (_tmp1_);
	_tmp2_ = self->priv->credentials_area;
	_tmp3_ = value;
	gtk_revealer_set_reveal_child ((GtkRevealer*) _tmp2_, _tmp3_);
	g_object_notify ((GObject *) self, "selected");
}


static const gchar* login_box_real_get_login_name (LoginMask* base) {
	const gchar* result;
	LoginBox* self;
	LoginOption* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	CredentialsArea* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	const gchar* _tmp8_ = NULL;
	self = (LoginBox*) base;
	_tmp0_ = self->priv->_user;
	_tmp1_ = login_option_get_provides_login_name (_tmp0_);
	_tmp2_ = _tmp1_;
	if (_tmp2_) {
		LoginOption* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		_tmp3_ = self->priv->_user;
		_tmp4_ = login_option_get_name (_tmp3_);
		_tmp5_ = _tmp4_;
		result = _tmp5_;
		return result;
	}
	_tmp6_ = self->priv->credentials_area;
	_tmp7_ = credentials_area_get_login_name (_tmp6_);
	_tmp8_ = _tmp7_;
	result = _tmp8_;
	return result;
}


static const gchar* login_box_real_get_login_session (LoginMask* base) {
	const gchar* result;
	LoginBox* self;
	CredentialsArea* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	self = (LoginBox*) base;
	_tmp0_ = self->priv->credentials_area;
	_tmp1_ = credentials_area_get_current_session (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


LoginOption* login_box_get_user (LoginBox* self) {
	LoginOption* result;
	LoginOption* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_user;
	result = _tmp0_;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void login_box_set_user (LoginBox* self, LoginOption* value) {
	LoginOption* _tmp0_ = NULL;
	LoginOption* _tmp1_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->_user);
	self->priv->_user = _tmp1_;
	g_object_notify ((GObject *) self, "user");
}


static void _login_box___lambda15_ (LoginBox* self, const gchar* answer) {
	CredentialsArea* _tmp0_ = NULL;
	LoginGateway* _tmp1_ = NULL;
	LoginGateway* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (answer != NULL);
	_tmp0_ = self->priv->credentials_area;
	credentials_area_remove_credentials (_tmp0_);
	_tmp1_ = pantheon_greeter_get_login_gateway ();
	_tmp2_ = _tmp1_;
	_tmp3_ = answer;
	login_gateway_respond (_tmp2_, _tmp3_);
}


static void __login_box___lambda15__credentials_area_replied (CredentialsArea* _sender, const gchar* text, gpointer self) {
	_login_box___lambda15_ ((LoginBox*) self, text);
}


static void _login_box___lambda16_ (LoginBox* self, const gchar* name) {
	g_return_if_fail (name != NULL);
	login_box_start_login (self);
}


static void __login_box___lambda16__credentials_area_entered_login_name (CredentialsArea* _sender, const gchar* name, gpointer self) {
	_login_box___lambda16_ ((LoginBox*) self, name);
}


static GObject * login_box_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	LoginBox * self;
	GtkIconTheme* icon_theme = NULL;
	GtkIconTheme* _tmp0_ = NULL;
	GtkIconTheme* _tmp1_ = NULL;
	LoginOption* _tmp2_ = NULL;
	CredentialsArea* _tmp3_ = NULL;
	gchar* path = NULL;
	LoginOption* _tmp4_ = NULL;
	const gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	GtkImage* avatar = NULL;
	gint size = 0;
	const gchar* _tmp8_ = NULL;
	GtkGrid* grid = NULL;
	GtkGrid* _tmp20_ = NULL;
	GtkGrid* _tmp21_ = NULL;
	GtkGrid* _tmp22_ = NULL;
	GtkGrid* _tmp23_ = NULL;
	GtkImage* _tmp24_ = NULL;
	GtkGrid* _tmp25_ = NULL;
	CredentialsArea* _tmp26_ = NULL;
	GtkGrid* _tmp27_ = NULL;
	GtkClutterActor* credentials_area_actor = NULL;
	GtkClutterActor* _tmp28_ = NULL;
	GtkClutterActor* _tmp29_ = NULL;
	GtkClutterActor* _tmp30_ = NULL;
	GtkWidget* _tmp31_ = NULL;
	GtkGrid* _tmp32_ = NULL;
	GtkClutterActor* _tmp33_ = NULL;
	LoginOption* _tmp34_ = NULL;
	gboolean _tmp35_ = FALSE;
	gboolean _tmp36_ = FALSE;
	CredentialsArea* _tmp45_ = NULL;
	CredentialsArea* _tmp46_ = NULL;
	GError * _inner_error_ = NULL;
	parent_class = G_OBJECT_CLASS (login_box_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LOGIN_BOX, LoginBox);
	clutter_actor_set_reactive ((ClutterActor*) self, TRUE);
	_tmp0_ = gtk_icon_theme_get_default ();
	_tmp1_ = _g_object_ref0 (_tmp0_);
	icon_theme = _tmp1_;
	_tmp2_ = self->priv->_user;
	_tmp3_ = credentials_area_new (self, _tmp2_);
	g_object_ref_sink (_tmp3_);
	_g_object_unref0 (self->priv->credentials_area);
	self->priv->credentials_area = _tmp3_;
	_tmp4_ = self->priv->_user;
	_tmp5_ = login_option_get_avatar_path (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = g_strdup (_tmp6_);
	path = _tmp7_;
	size = 130;
	_tmp8_ = path;
	if (_tmp8_ != NULL) {
		GdkPixbuf* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		GdkPixbuf* _tmp13_ = NULL;
		GtkImage* _tmp14_ = NULL;
		_tmp10_ = path;
		_tmp11_ = size;
		_tmp12_ = size;
		_tmp13_ = gdk_pixbuf_new_from_file_at_size (_tmp10_, _tmp11_, _tmp12_, &_inner_error_);
		_tmp9_ = _tmp13_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (avatar);
			_g_free0 (path);
			_g_object_unref0 (icon_theme);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
		}
		_tmp14_ = (GtkImage*) gtk_image_new_from_pixbuf (_tmp9_);
		g_object_ref_sink (_tmp14_);
		_g_object_unref0 (avatar);
		avatar = _tmp14_;
		_g_object_unref0 (_tmp9_);
	} else {
		GdkPixbuf* _tmp15_ = NULL;
		GtkIconTheme* _tmp16_ = NULL;
		gint _tmp17_ = 0;
		GdkPixbuf* _tmp18_ = NULL;
		GtkImage* _tmp19_ = NULL;
		_tmp16_ = icon_theme;
		_tmp17_ = size;
		_tmp18_ = gtk_icon_theme_load_icon (_tmp16_, "avatar-default", _tmp17_, 0, &_inner_error_);
		_tmp15_ = _tmp18_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (avatar);
			_g_free0 (path);
			_g_object_unref0 (icon_theme);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
		}
		_tmp19_ = (GtkImage*) gtk_image_new_from_pixbuf (_tmp15_);
		g_object_ref_sink (_tmp19_);
		_g_object_unref0 (avatar);
		avatar = _tmp19_;
		_g_object_unref0 (_tmp15_);
	}
	_tmp20_ = (GtkGrid*) gtk_grid_new ();
	g_object_ref_sink (_tmp20_);
	grid = _tmp20_;
	_tmp21_ = grid;
	gtk_grid_set_row_spacing (_tmp21_, 20);
	_tmp22_ = grid;
	gtk_orientable_set_orientation ((GtkOrientable*) _tmp22_, GTK_ORIENTATION_VERTICAL);
	_tmp23_ = grid;
	_tmp24_ = avatar;
	gtk_container_add ((GtkContainer*) _tmp23_, (GtkWidget*) _tmp24_);
	_tmp25_ = grid;
	_tmp26_ = self->priv->credentials_area;
	gtk_container_add ((GtkContainer*) _tmp25_, (GtkWidget*) _tmp26_);
	_tmp27_ = grid;
	gtk_widget_show_all ((GtkWidget*) _tmp27_);
	_tmp28_ = (GtkClutterActor*) gtk_clutter_actor_new ();
	g_object_ref_sink (_tmp28_);
	credentials_area_actor = _tmp28_;
	_tmp29_ = credentials_area_actor;
	clutter_actor_set_width ((ClutterActor*) _tmp29_, (gfloat) 288);
	_tmp30_ = credentials_area_actor;
	_tmp31_ = gtk_clutter_actor_get_widget (_tmp30_);
	_tmp32_ = grid;
	gtk_container_add (G_TYPE_CHECK_INSTANCE_CAST (_tmp31_, gtk_container_get_type (), GtkContainer), (GtkWidget*) _tmp32_);
	_tmp33_ = credentials_area_actor;
	clutter_actor_add_child ((ClutterActor*) self, (ClutterActor*) _tmp33_);
	_tmp34_ = self->priv->_user;
	_tmp35_ = login_option_get_logged_in (_tmp34_);
	_tmp36_ = _tmp35_;
	if (_tmp36_) {
		GtkImage* logged_in = NULL;
		GtkImage* _tmp37_ = NULL;
		GtkClutterActor* logged_in_actor = NULL;
		GtkClutterActor* _tmp38_ = NULL;
		GtkClutterActor* _tmp39_ = NULL;
		GtkClutterActor* _tmp40_ = NULL;
		GtkClutterActor* _tmp41_ = NULL;
		GtkWidget* _tmp42_ = NULL;
		GtkImage* _tmp43_ = NULL;
		GtkClutterActor* _tmp44_ = NULL;
		_tmp37_ = (GtkImage*) gtk_image_new_from_file (CONSTANTS_PKGDATADIR "/checked.svg");
		g_object_ref_sink (_tmp37_);
		logged_in = _tmp37_;
		_tmp38_ = (GtkClutterActor*) gtk_clutter_actor_new ();
		g_object_ref_sink (_tmp38_);
		logged_in_actor = _tmp38_;
		_tmp39_ = logged_in_actor;
		_tmp40_ = logged_in_actor;
		clutter_actor_set_y ((ClutterActor*) _tmp40_, (gfloat) 75);
		clutter_actor_set_x ((ClutterActor*) _tmp39_, (gfloat) 75);
		_tmp41_ = logged_in_actor;
		_tmp42_ = gtk_clutter_actor_get_widget (_tmp41_);
		_tmp43_ = logged_in;
		gtk_container_add (G_TYPE_CHECK_INSTANCE_CAST (_tmp42_, gtk_container_get_type (), GtkContainer), (GtkWidget*) _tmp43_);
		_tmp44_ = logged_in_actor;
		clutter_actor_add_child ((ClutterActor*) self, (ClutterActor*) _tmp44_);
		_g_object_unref0 (logged_in_actor);
		_g_object_unref0 (logged_in);
	}
	_tmp45_ = self->priv->credentials_area;
	g_signal_connect_object (_tmp45_, "replied", (GCallback) __login_box___lambda15__credentials_area_replied, self, 0);
	_tmp46_ = self->priv->credentials_area;
	g_signal_connect_object (_tmp46_, "entered-login-name", (GCallback) __login_box___lambda16__credentials_area_entered_login_name, self, 0);
	_g_object_unref0 (credentials_area_actor);
	_g_object_unref0 (grid);
	_g_object_unref0 (avatar);
	_g_free0 (path);
	_g_object_unref0 (icon_theme);
	return obj;
}


static void login_box_class_init (LoginBoxClass * klass) {
	login_box_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LoginBoxPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_login_box_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_login_box_set_property;
	G_OBJECT_CLASS (klass)->constructor = login_box_constructor;
	G_OBJECT_CLASS (klass)->finalize = login_box_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), LOGIN_BOX_SELECTED, g_param_spec_boolean ("selected", "selected", "selected", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), LOGIN_BOX_LOGIN_NAME, g_param_spec_string ("login-name", "login-name", "login-name", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), LOGIN_BOX_LOGIN_SESSION, g_param_spec_string ("login-session", "login-session", "login-session", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), LOGIN_BOX_USER, g_param_spec_object ("user", "user", "user", TYPE_LOGIN_OPTION, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
}


static void login_box_login_mask_interface_init (LoginMaskIface * iface) {
	login_box_login_mask_parent_iface = g_type_interface_peek_parent (iface);
	iface->show_prompt = (void (*)(LoginMask*, PromptType, PromptText, const gchar*)) login_box_real_show_prompt;
	iface->show_message = (void (*)(LoginMask*, LightDMMessageType, MessageText, const gchar*)) login_box_real_show_message;
	iface->not_authenticated = (void (*)(LoginMask*)) login_box_real_not_authenticated;
	iface->login_aborted = (void (*)(LoginMask*)) login_box_real_login_aborted;
	iface->get_login_name = login_box_real_get_login_name;
	iface->get_login_session = login_box_real_get_login_session;
}


static void login_box_instance_init (LoginBox * self) {
	self->priv = LOGIN_BOX_GET_PRIVATE (self);
	self->priv->_selected = FALSE;
}


static void login_box_finalize (GObject* obj) {
	LoginBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_LOGIN_BOX, LoginBox);
	_g_object_unref0 (self->priv->credentials_area);
	_g_object_unref0 (self->priv->_user);
	G_OBJECT_CLASS (login_box_parent_class)->finalize (obj);
}


GType login_box_get_type (void) {
	static volatile gsize login_box_type_id__volatile = 0;
	if (g_once_init_enter (&login_box_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LoginBoxClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) login_box_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LoginBox), 0, (GInstanceInitFunc) login_box_instance_init, NULL };
		static const GInterfaceInfo login_mask_info = { (GInterfaceInitFunc) login_box_login_mask_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType login_box_type_id;
		login_box_type_id = g_type_register_static (gtk_clutter_actor_get_type (), "LoginBox", &g_define_type_info, 0);
		g_type_add_interface_static (login_box_type_id, TYPE_LOGIN_MASK, &login_mask_info);
		g_once_init_leave (&login_box_type_id__volatile, login_box_type_id);
	}
	return login_box_type_id__volatile;
}


static void _vala_login_box_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	LoginBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_LOGIN_BOX, LoginBox);
	switch (property_id) {
		case LOGIN_BOX_SELECTED:
		g_value_set_boolean (value, login_box_get_selected (self));
		break;
		case LOGIN_BOX_LOGIN_NAME:
		g_value_set_string (value, login_mask_get_login_name ((LoginMask*) self));
		break;
		case LOGIN_BOX_LOGIN_SESSION:
		g_value_set_string (value, login_mask_get_login_session ((LoginMask*) self));
		break;
		case LOGIN_BOX_USER:
		g_value_set_object (value, login_box_get_user (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_login_box_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	LoginBox * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_LOGIN_BOX, LoginBox);
	switch (property_id) {
		case LOGIN_BOX_SELECTED:
		login_box_set_selected (self, g_value_get_boolean (value));
		break;
		case LOGIN_BOX_USER:
		login_box_set_user (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



