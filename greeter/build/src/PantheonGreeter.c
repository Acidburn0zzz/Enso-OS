/* PantheonGreeter.c generated by valac 0.30.1, the Vala compiler
 * generated from PantheonGreeter.vala, do not modify */

/* -*- Mode: vala; indent-tabs-mode: nil; tab-width: 4 -*-*/

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <clutter-gtk/clutter-gtk.h>
#include <clutter/clutter.h>
#include <stdlib.h>
#include <string.h>
#include <lightdm.h>
#include <gdk/gdk.h>
#include <glib/gstdio.h>
#include <float.h>
#include <math.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <gdk/gdkx.h>
#include <gio/gio.h>
#include <cairo.h>
#include <cairo-xlib.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <sys/mman.h>
#include <glib-unix.h>
#include <signal.h>
#include <locale.h>
#include <glib/gi18n-lib.h>


#define TYPE_PANTHEON_GREETER (pantheon_greeter_get_type ())
#define PANTHEON_GREETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PANTHEON_GREETER, PantheonGreeter))
#define PANTHEON_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PANTHEON_GREETER, PantheonGreeterClass))
#define IS_PANTHEON_GREETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PANTHEON_GREETER))
#define IS_PANTHEON_GREETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PANTHEON_GREETER))
#define PANTHEON_GREETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PANTHEON_GREETER, PantheonGreeterClass))

typedef struct _PantheonGreeter PantheonGreeter;
typedef struct _PantheonGreeterClass PantheonGreeterClass;
typedef struct _PantheonGreeterPrivate PantheonGreeterPrivate;

#define TYPE_USER_LIST_ACTOR (user_list_actor_get_type ())
#define USER_LIST_ACTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_LIST_ACTOR, UserListActor))
#define USER_LIST_ACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_USER_LIST_ACTOR, UserListActorClass))
#define IS_USER_LIST_ACTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_LIST_ACTOR))
#define IS_USER_LIST_ACTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_USER_LIST_ACTOR))
#define USER_LIST_ACTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_LIST_ACTOR, UserListActorClass))

typedef struct _UserListActor UserListActor;
typedef struct _UserListActorClass UserListActorClass;

#define TYPE_USER_LIST (user_list_get_type ())
#define USER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_USER_LIST, UserList))
#define USER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_USER_LIST, UserListClass))
#define IS_USER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_USER_LIST))
#define IS_USER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_USER_LIST))
#define USER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_USER_LIST, UserListClass))

typedef struct _UserList UserList;
typedef struct _UserListClass UserListClass;

#define TYPE_WALLPAPER (wallpaper_get_type ())
#define WALLPAPER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WALLPAPER, Wallpaper))
#define WALLPAPER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WALLPAPER, WallpaperClass))
#define IS_WALLPAPER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WALLPAPER))
#define IS_WALLPAPER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WALLPAPER))
#define WALLPAPER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WALLPAPER, WallpaperClass))

typedef struct _Wallpaper Wallpaper;
typedef struct _WallpaperClass WallpaperClass;

#define TYPE_DEEPIN_BLUR_EFFECT (deepin_blur_effect_get_type ())
#define DEEPIN_BLUR_EFFECT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DEEPIN_BLUR_EFFECT, DeepinBlurEffect))
#define DEEPIN_BLUR_EFFECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DEEPIN_BLUR_EFFECT, DeepinBlurEffectClass))
#define IS_DEEPIN_BLUR_EFFECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DEEPIN_BLUR_EFFECT))
#define IS_DEEPIN_BLUR_EFFECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DEEPIN_BLUR_EFFECT))
#define DEEPIN_BLUR_EFFECT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DEEPIN_BLUR_EFFECT, DeepinBlurEffectClass))

typedef struct _DeepinBlurEffect DeepinBlurEffect;
typedef struct _DeepinBlurEffectClass DeepinBlurEffectClass;

#define PANTHEON_GREETER_TYPE_BLANKING (pantheon_greeter_blanking_get_type ())

#define PANTHEON_GREETER_TYPE_EXPOSURES (pantheon_greeter_exposures_get_type ())

#define PANTHEON_GREETER_TYPE_SCREENSAVER (pantheon_greeter_screensaver_get_type ())

#define TYPE_LOGIN_GATEWAY (login_gateway_get_type ())
#define LOGIN_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_GATEWAY, LoginGateway))
#define IS_LOGIN_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_GATEWAY))
#define LOGIN_GATEWAY_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_LOGIN_GATEWAY, LoginGatewayIface))

typedef struct _LoginGateway LoginGateway;
typedef struct _LoginGatewayIface LoginGatewayIface;

#define TYPE_LOGIN_MASK (login_mask_get_type ())
#define LOGIN_MASK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_MASK, LoginMask))
#define IS_LOGIN_MASK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_MASK))
#define LOGIN_MASK_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_LOGIN_MASK, LoginMaskIface))

typedef struct _LoginMask LoginMask;
typedef struct _LoginMaskIface LoginMaskIface;

#define TYPE_PROMPT_TYPE (prompt_type_get_type ())

#define TYPE_PROMPT_TEXT (prompt_text_get_type ())

#define TYPE_MESSAGE_TEXT (message_text_get_type ())
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_SETTINGS_DAEMON (settings_daemon_get_type ())
#define SETTINGS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_DAEMON, SettingsDaemon))
#define SETTINGS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_DAEMON, SettingsDaemonClass))
#define IS_SETTINGS_DAEMON(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_DAEMON))
#define IS_SETTINGS_DAEMON_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_DAEMON))
#define SETTINGS_DAEMON_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_DAEMON, SettingsDaemonClass))

typedef struct _SettingsDaemon SettingsDaemon;
typedef struct _SettingsDaemonClass SettingsDaemonClass;

#define TYPE_DUMMY_GATEWAY (dummy_gateway_get_type ())
#define DUMMY_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DUMMY_GATEWAY, DummyGateway))
#define DUMMY_GATEWAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DUMMY_GATEWAY, DummyGatewayClass))
#define IS_DUMMY_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DUMMY_GATEWAY))
#define IS_DUMMY_GATEWAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DUMMY_GATEWAY))
#define DUMMY_GATEWAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DUMMY_GATEWAY, DummyGatewayClass))

typedef struct _DummyGateway DummyGateway;
typedef struct _DummyGatewayClass DummyGatewayClass;

#define TYPE_LIGHT_DM_GATEWAY (light_dm_gateway_get_type ())
#define LIGHT_DM_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LIGHT_DM_GATEWAY, LightDMGateway))
#define LIGHT_DM_GATEWAY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LIGHT_DM_GATEWAY, LightDMGatewayClass))
#define IS_LIGHT_DM_GATEWAY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LIGHT_DM_GATEWAY))
#define IS_LIGHT_DM_GATEWAY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LIGHT_DM_GATEWAY))
#define LIGHT_DM_GATEWAY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LIGHT_DM_GATEWAY, LightDMGatewayClass))

typedef struct _LightDMGateway LightDMGateway;
typedef struct _LightDMGatewayClass LightDMGatewayClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_TIME_LABEL (time_label_get_type ())
#define TIME_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TIME_LABEL, TimeLabel))
#define TIME_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TIME_LABEL, TimeLabelClass))
#define IS_TIME_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TIME_LABEL))
#define IS_TIME_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TIME_LABEL))
#define TIME_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TIME_LABEL, TimeLabelClass))

typedef struct _TimeLabel TimeLabel;
typedef struct _TimeLabelClass TimeLabelClass;

#define TYPE_POWER_LABEL (power_label_get_type ())
#define POWER_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_POWER_LABEL, PowerLabel))
#define POWER_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_POWER_LABEL, PowerLabelClass))
#define IS_POWER_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_POWER_LABEL))
#define IS_POWER_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_POWER_LABEL))
#define POWER_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_POWER_LABEL, PowerLabelClass))

typedef struct _PowerLabel PowerLabel;
typedef struct _PowerLabelClass PowerLabelClass;

#define TYPE_LOGIN_OPTION (login_option_get_type ())
#define LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LOGIN_OPTION, LoginOption))
#define LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LOGIN_OPTION, LoginOptionClass))
#define IS_LOGIN_OPTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LOGIN_OPTION))
#define IS_LOGIN_OPTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LOGIN_OPTION))
#define LOGIN_OPTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LOGIN_OPTION, LoginOptionClass))

typedef struct _LoginOption LoginOption;
typedef struct _LoginOptionClass LoginOptionClass;
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
typedef struct _WallpaperPrivate WallpaperPrivate;
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _PantheonGreeter {
	GtkWindow parent_instance;
	PantheonGreeterPrivate * priv;
	GKeyFile* settings;
	GKeyFile* state;
};

struct _PantheonGreeterClass {
	GtkWindowClass parent_class;
};

struct _PantheonGreeterPrivate {
	GtkClutterEmbed* clutter;
	GtkClutterActor* wallpaper_actor;
	GtkClutterActor* time_actor;
	GtkClutterActor* power_actor;
	ClutterActor* greeterbox;
	UserListActor* userlist_actor;
	UserList* userlist;
	GtkClutterActor* indicator_bar_actor;
	Wallpaper* wallpaper;
	DeepinBlurEffect* blur_effect_actor;
	gint timeout;
	gint interval;
	gint prefer_blanking;
	gint allow_exposures;
	gchar* state_file;
	gint g_width;
	gint g_height;
};

typedef enum  {
	PANTHEON_GREETER_BLANKING_DONT_PREFER_BLANKING,
	PANTHEON_GREETER_BLANKING_PREFER_BLANKING,
	PANTHEON_GREETER_BLANKING_DEFAULT_BLANKING
} PantheonGreeterBlanking;

typedef enum  {
	PANTHEON_GREETER_EXPOSURES_DONT_PREFER_EXPOSURES,
	PANTHEON_GREETER_EXPOSURES_PREFER_EXPOSURES,
	PANTHEON_GREETER_EXPOSURES_DEFAULT_EXPOSURES
} PantheonGreeterExposures;

typedef enum  {
	PANTHEON_GREETER_SCREENSAVER_RESET,
	PANTHEON_GREETER_SCREENSAVER_ACTIVE
} PantheonGreeterScreensaver;

typedef enum  {
	PROMPT_TYPE_SECRET,
	PROMPT_TYPE_QUESTION,
	PROMPT_TYPE_CONFIRM_LOGIN,
	PROMPT_TYPE_FPRINT
} PromptType;

typedef enum  {
	PROMPT_TEXT_USERNAME,
	PROMPT_TEXT_PASSWORD,
	PROMPT_TEXT_OTHER
} PromptText;

typedef enum  {
	MESSAGE_TEXT_FPRINT_SWIPE,
	MESSAGE_TEXT_FPRINT_SWIPE_AGAIN,
	MESSAGE_TEXT_FPRINT_SWIPE_TOO_SHORT,
	MESSAGE_TEXT_FPRINT_NOT_CENTERED,
	MESSAGE_TEXT_FPRINT_REMOVE,
	MESSAGE_TEXT_FPRINT_PLACE,
	MESSAGE_TEXT_FPRINT_PLACE_AGAIN,
	MESSAGE_TEXT_FPRINT_NO_MATCH,
	MESSAGE_TEXT_FPRINT_TIMEOUT,
	MESSAGE_TEXT_FPRINT_ERROR,
	MESSAGE_TEXT_FAILED,
	MESSAGE_TEXT_OTHER
} MessageText;

struct _LoginMaskIface {
	GTypeInterface parent_iface;
	void (*show_prompt) (LoginMask* self, PromptType type, PromptText prompttext, const gchar* text);
	void (*show_message) (LoginMask* self, LightDMMessageType type, MessageText messagetext, const gchar* text);
	void (*not_authenticated) (LoginMask* self);
	void (*login_aborted) (LoginMask* self);
	const gchar* (*get_login_name) (LoginMask* self);
	const gchar* (*get_login_session) (LoginMask* self);
};

struct _LoginGatewayIface {
	GTypeInterface parent_iface;
	void (*login_with_mask) (LoginGateway* self, LoginMask* mask, gboolean guest);
	void (*respond) (LoginGateway* self, const gchar* message);
	void (*start_session) (LoginGateway* self);
	gboolean (*get_hide_users) (LoginGateway* self);
	gboolean (*get_has_guest_account) (LoginGateway* self);
	gboolean (*get_show_manual_login) (LoginGateway* self);
	gboolean (*get_lock) (LoginGateway* self);
	const gchar* (*get_default_session) (LoginGateway* self);
	const gchar* (*get_select_user) (LoginGateway* self);
};

struct _Wallpaper {
	GtkStack parent_instance;
	WallpaperPrivate * priv;
	GdkPixbuf* background_pixbuf;
};

struct _WallpaperClass {
	GtkStackClass parent_class;
};


static gpointer pantheon_greeter_parent_class = NULL;
static LoginGateway* pantheon_greeter__login_gateway;
static LoginGateway* pantheon_greeter__login_gateway = NULL;
static PantheonGreeter* pantheon_greeter__instance;
static PantheonGreeter* pantheon_greeter__instance = NULL;
static SettingsDaemon* pantheon_greeter_settings_daemon;
static SettingsDaemon* pantheon_greeter_settings_daemon = NULL;
static gboolean pantheon_greeter__TEST_MODE;
static gboolean pantheon_greeter__TEST_MODE = FALSE;

GType pantheon_greeter_get_type (void) G_GNUC_CONST;
GType user_list_actor_get_type (void) G_GNUC_CONST;
GType user_list_get_type (void) G_GNUC_CONST;
GType wallpaper_get_type (void) G_GNUC_CONST;
GType deepin_blur_effect_get_type (void) G_GNUC_CONST;
#define PANTHEON_GREETER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_PANTHEON_GREETER, PantheonGreeterPrivate))
enum  {
	PANTHEON_GREETER_DUMMY_PROPERTY
};
static GType pantheon_greeter_blanking_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GType pantheon_greeter_exposures_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static GType pantheon_greeter_screensaver_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
GType prompt_type_get_type (void) G_GNUC_CONST;
GType prompt_text_get_type (void) G_GNUC_CONST;
GType message_text_get_type (void) G_GNUC_CONST;
GType login_mask_get_type (void) G_GNUC_CONST;
GType login_gateway_get_type (void) G_GNUC_CONST;
GType settings_daemon_get_type (void) G_GNUC_CONST;
#define PANTHEON_GREETER_NORMAL_HEIGHT 600
#define PANTHEON_GREETER_NO_CLOCK_WIDTH 1500
#define PANTHEON_GREETER_DEFAULT_CLOCK_HEIGHT 296
#define PANTHEON_GREETER_DEFAULT_CLOCK_WIDTH 617
PantheonGreeter* pantheon_greeter_new (void);
PantheonGreeter* pantheon_greeter_construct (GType object_type);
PantheonGreeter* pantheon_greeter_get_instance (void);
static void pantheon_greeter_set_instance (PantheonGreeter* value);
gboolean pantheon_greeter_get_TEST_MODE (void);
static void pantheon_greeter_set_TEST_MODE (gboolean value);
LoginGateway* pantheon_greeter_get_login_gateway (void);
DummyGateway* dummy_gateway_new (void);
DummyGateway* dummy_gateway_construct (GType object_type);
GType dummy_gateway_get_type (void) G_GNUC_CONST;
static void pantheon_greeter_set_login_gateway (LoginGateway* value);
LightDMGateway* light_dm_gateway_new (void);
LightDMGateway* light_dm_gateway_construct (GType object_type);
GType light_dm_gateway_get_type (void) G_GNUC_CONST;
SettingsDaemon* settings_daemon_new (void);
SettingsDaemon* settings_daemon_construct (GType object_type);
void settings_daemon_start (SettingsDaemon* self);
#define CONSTANTS_CONF_DIR "/etc/lightdm"
UserList* user_list_new (LightDMUserList* ld_users);
UserList* user_list_construct (GType object_type, LightDMUserList* ld_users);
UserListActor* user_list_actor_new (UserList* userlist);
UserListActor* user_list_actor_construct (GType object_type, UserList* userlist);
GType time_label_get_type (void) G_GNUC_CONST;
TimeLabel* time_label_new (void);
TimeLabel* time_label_construct (GType object_type);
GType power_label_get_type (void) G_GNUC_CONST;
PowerLabel* power_label_new (void);
PowerLabel* power_label_construct (GType object_type);
Wallpaper* wallpaper_new (void);
Wallpaper* wallpaper_construct (GType object_type);
void deepin_blur_effect_setup (ClutterActor* actor, gint width, gint height, gfloat radius, gint repeat);
static void pantheon_greeter_monitors_changed (PantheonGreeter* self);
gboolean login_gateway_get_lock (LoginGateway* self);
static void pantheon_greeter_connect_signals (PantheonGreeter* self);
const gchar* login_gateway_get_select_user (LoginGateway* self);
gchar* pantheon_greeter_get_greeter_state (PantheonGreeter* self, const gchar* key);
gint user_list_get_size (UserList* self);
GType login_option_get_type (void) G_GNUC_CONST;
LoginOption* user_list_get_user (UserList* self, gint i);
const gchar* login_option_get_name (LoginOption* self);
void user_list_set_current_user (UserList* self, LoginOption* value);
LoginOption* user_list_get_current_user (UserList* self);
static ClutterPropertyTransition* pantheon_greeter_fade_in_actor (PantheonGreeter* self, ClutterActor* actor);
gchar* pantheon_greeter_load_from_resource (PantheonGreeter* self, const gchar* uri, GError** error);
static void _pantheon_greeter_monitors_changed_gdk_screen_monitors_changed (GdkScreen* _sender, gpointer self);
static void __lambda27_ (PantheonGreeter* self);
static void pantheon_greeter_fade_out_ui (PantheonGreeter* self);
static void ___lambda27__login_gateway_login_successful (LoginGateway* _sender, gpointer self);
static gboolean __lambda29_ (PantheonGreeter* self);
static void pantheon_greeter_reposition (PantheonGreeter* self);
static gboolean ___lambda29__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self);
static gboolean __lambda30_ (PantheonGreeter* self);
static gboolean ___lambda30__gtk_widget_delete_event (GtkWidget* _sender, GdkEventAny* event, gpointer self);
static void __lambda31_ (PantheonGreeter* self, LoginOption* user);
void wallpaper_set_wallpaper (Wallpaper* self, const gchar* path);
const gchar* login_option_get_background (LoginOption* self);
static void ___lambda31__user_list_current_user_changed (UserList* _sender, LoginOption* user, gpointer self);
static gboolean pantheon_greeter_keyboard_navigation (PantheonGreeter* self, GdkEventKey* e);
static gboolean _pantheon_greeter_keyboard_navigation_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self);
static gboolean pantheon_greeter_scroll_navigation (PantheonGreeter* self, GdkEventScroll* e);
static gboolean _pantheon_greeter_scroll_navigation_gtk_widget_scroll_event (GtkWidget* _sender, GdkEventScroll* event, gpointer self);
static ClutterPropertyTransition* pantheon_greeter_fade_out_actor (PantheonGreeter* self, ClutterActor* actor);
static void pantheon_greeter_refresh_background (PantheonGreeter* self);
static void __lambda28_ (PantheonGreeter* self);
void login_gateway_start_session (LoginGateway* self);
static void ___lambda28__clutter_timeline_completed (ClutterTimeline* _sender, gpointer self);
void wallpaper_set_screen_width (Wallpaper* self, gint value);
void wallpaper_set_screen_height (Wallpaper* self, gint value);
void wallpaper_reposition (Wallpaper* self);
void user_list_select_prev_user (UserList* self);
void user_list_select_next_user (UserList* self);
void pantheon_greeter_set_greeter_state (PantheonGreeter* self, const gchar* key, const gchar* value);
static cairo_surface_t* pantheon_greeter_create_root_surface (PantheonGreeter* self, GdkScreen* screen);
static void pantheon_greeter_draw_wallpaper_on_surface (PantheonGreeter* self, cairo_surface_t* surface);
GdkPixbuf* wallpaper_scale_to_rect (GdkPixbuf* pixbuf, gint rect_width, gint rect_height);
static void pantheon_greeter_finalize (GObject* obj);
static void _vala_pantheon_greeter_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_pantheon_greeter_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
gint _vala_main (gchar** args, int args_length1);
static gboolean __lambda32_ (void);
static gboolean ___lambda32__gsource_func (gpointer self);
gchar* get_defaults (const gchar* _default_);


static GType pantheon_greeter_blanking_get_type (void) {
	static volatile gsize pantheon_greeter_blanking_type_id__volatile = 0;
	if (g_once_init_enter (&pantheon_greeter_blanking_type_id__volatile)) {
		static const GEnumValue values[] = {{PANTHEON_GREETER_BLANKING_DONT_PREFER_BLANKING, "PANTHEON_GREETER_BLANKING_DONT_PREFER_BLANKING", "dont-prefer-blanking"}, {PANTHEON_GREETER_BLANKING_PREFER_BLANKING, "PANTHEON_GREETER_BLANKING_PREFER_BLANKING", "prefer-blanking"}, {PANTHEON_GREETER_BLANKING_DEFAULT_BLANKING, "PANTHEON_GREETER_BLANKING_DEFAULT_BLANKING", "default-blanking"}, {0, NULL, NULL}};
		GType pantheon_greeter_blanking_type_id;
		pantheon_greeter_blanking_type_id = g_enum_register_static ("PantheonGreeterBlanking", values);
		g_once_init_leave (&pantheon_greeter_blanking_type_id__volatile, pantheon_greeter_blanking_type_id);
	}
	return pantheon_greeter_blanking_type_id__volatile;
}


static GType pantheon_greeter_exposures_get_type (void) {
	static volatile gsize pantheon_greeter_exposures_type_id__volatile = 0;
	if (g_once_init_enter (&pantheon_greeter_exposures_type_id__volatile)) {
		static const GEnumValue values[] = {{PANTHEON_GREETER_EXPOSURES_DONT_PREFER_EXPOSURES, "PANTHEON_GREETER_EXPOSURES_DONT_PREFER_EXPOSURES", "dont-prefer-exposures"}, {PANTHEON_GREETER_EXPOSURES_PREFER_EXPOSURES, "PANTHEON_GREETER_EXPOSURES_PREFER_EXPOSURES", "prefer-exposures"}, {PANTHEON_GREETER_EXPOSURES_DEFAULT_EXPOSURES, "PANTHEON_GREETER_EXPOSURES_DEFAULT_EXPOSURES", "default-exposures"}, {0, NULL, NULL}};
		GType pantheon_greeter_exposures_type_id;
		pantheon_greeter_exposures_type_id = g_enum_register_static ("PantheonGreeterExposures", values);
		g_once_init_leave (&pantheon_greeter_exposures_type_id__volatile, pantheon_greeter_exposures_type_id);
	}
	return pantheon_greeter_exposures_type_id__volatile;
}


static GType pantheon_greeter_screensaver_get_type (void) {
	static volatile gsize pantheon_greeter_screensaver_type_id__volatile = 0;
	if (g_once_init_enter (&pantheon_greeter_screensaver_type_id__volatile)) {
		static const GEnumValue values[] = {{PANTHEON_GREETER_SCREENSAVER_RESET, "PANTHEON_GREETER_SCREENSAVER_RESET", "reset"}, {PANTHEON_GREETER_SCREENSAVER_ACTIVE, "PANTHEON_GREETER_SCREENSAVER_ACTIVE", "active"}, {0, NULL, NULL}};
		GType pantheon_greeter_screensaver_type_id;
		pantheon_greeter_screensaver_type_id = g_enum_register_static ("PantheonGreeterScreensaver", values);
		g_once_init_leave (&pantheon_greeter_screensaver_type_id__volatile, pantheon_greeter_screensaver_type_id);
	}
	return pantheon_greeter_screensaver_type_id__volatile;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


PantheonGreeter* pantheon_greeter_construct (GType object_type) {
	PantheonGreeter * self = NULL;
	PantheonGreeter* _tmp0_ = NULL;
	PantheonGreeter* _tmp1_ = NULL;
	PantheonGreeter* _tmp2_ = NULL;
	PantheonGreeter* _tmp3_ = NULL;
	gint scale_factor = 0;
	GdkScreen* _tmp4_ = NULL;
	GdkWindow* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	GdkScreen* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	GdkScreen* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	gint _tmp12_ = 0;
	gboolean _tmp13_ = FALSE;
	gboolean _tmp14_ = FALSE;
	const gchar* _tmp15_ = NULL;
	gboolean _tmp16_ = FALSE;
	gboolean _tmp17_ = FALSE;
	gchar* state_dir = NULL;
	const gchar* _tmp28_ = NULL;
	gchar* _tmp29_ = NULL;
	const gchar* _tmp30_ = NULL;
	gchar* xdg_seat = NULL;
	const gchar* _tmp31_ = NULL;
	gchar* _tmp32_ = NULL;
	gchar* _tmp33_ = NULL;
	gboolean _tmp34_ = FALSE;
	const gchar* _tmp35_ = NULL;
	gchar* state_file_name = NULL;
	gchar* _tmp40_ = NULL;
	const gchar* _tmp41_ = NULL;
	const gchar* _tmp42_ = NULL;
	gchar* _tmp43_ = NULL;
	GKeyFile* _tmp44_ = NULL;
	GKeyFile* _tmp51_ = NULL;
	GtkClutterEmbed* _tmp57_ = NULL;
	GtkClutterEmbed* _tmp58_ = NULL;
	ClutterStage* stage = NULL;
	GtkClutterEmbed* _tmp59_ = NULL;
	ClutterActor* _tmp60_ = NULL;
	ClutterStage* _tmp61_ = NULL;
	ClutterStage* _tmp62_ = NULL;
	ClutterColor _tmp63_ = {0};
	LightDMUserList* _tmp64_ = NULL;
	UserList* _tmp65_ = NULL;
	UserList* _tmp66_ = NULL;
	UserListActor* _tmp67_ = NULL;
	UserListActor* _tmp68_ = NULL;
	TimeLabel* time_label = NULL;
	TimeLabel* _tmp69_ = NULL;
	GtkClutterActor* _tmp70_ = NULL;
	GtkClutterActor* _tmp71_ = NULL;
	GtkWidget* _tmp72_ = NULL;
	TimeLabel* _tmp73_ = NULL;
	PowerLabel* power_label = NULL;
	PowerLabel* _tmp74_ = NULL;
	GtkClutterActor* _tmp75_ = NULL;
	GtkClutterActor* _tmp76_ = NULL;
	GtkWidget* _tmp77_ = NULL;
	PowerLabel* _tmp78_ = NULL;
	Wallpaper* _tmp79_ = NULL;
	GtkClutterActor* _tmp80_ = NULL;
	GtkClutterActor* _tmp81_ = NULL;
	GtkWidget* _tmp82_ = NULL;
	Wallpaper* _tmp83_ = NULL;
	gboolean blur_effect = FALSE;
	gfloat setting_brightness = 0.0F;
	gboolean _tmp92_ = FALSE;
	ClutterActor* _tmp98_ = NULL;
	ClutterActor* _tmp99_ = NULL;
	ClutterStage* _tmp100_ = NULL;
	ClutterBindConstraint* _tmp101_ = NULL;
	ClutterBindConstraint* _tmp102_ = NULL;
	ClutterActor* _tmp103_ = NULL;
	ClutterStage* _tmp104_ = NULL;
	ClutterBindConstraint* _tmp105_ = NULL;
	ClutterBindConstraint* _tmp106_ = NULL;
	ClutterActor* _tmp107_ = NULL;
	ClutterActor* _tmp108_ = NULL;
	ClutterActor* _tmp109_ = NULL;
	ClutterActor* _tmp110_ = NULL;
	ClutterActor* _tmp111_ = NULL;
	ClutterActor* _tmp112_ = NULL;
	ClutterActor* _tmp113_ = NULL;
	GtkClutterActor* _tmp114_ = NULL;
	ClutterActor* _tmp115_ = NULL;
	GtkClutterActor* _tmp116_ = NULL;
	ClutterActor* _tmp117_ = NULL;
	GtkClutterActor* _tmp118_ = NULL;
	ClutterActor* _tmp119_ = NULL;
	UserListActor* _tmp120_ = NULL;
	ClutterStage* _tmp121_ = NULL;
	ClutterActor* _tmp122_ = NULL;
	GtkClutterEmbed* _tmp123_ = NULL;
	gboolean activate_numlock = FALSE;
	gboolean _tmp129_ = FALSE;
	gint screensaver_timeout = 0;
	Display* display = NULL;
	GdkDisplay* _tmp135_ = NULL;
	Display* _tmp136_ = NULL;
	Display* _tmp137_ = NULL;
	gint _tmp138_ = 0;
	gint _tmp139_ = 0;
	gint _tmp140_ = 0;
	gint _tmp141_ = 0;
	Display* _tmp142_ = NULL;
	gint _tmp143_ = 0;
	LoginGateway* _tmp144_ = NULL;
	LoginGateway* _tmp145_ = NULL;
	gboolean _tmp146_ = FALSE;
	gboolean _tmp147_ = FALSE;
	gchar* select_user = NULL;
	LoginGateway* _tmp149_ = NULL;
	LoginGateway* _tmp150_ = NULL;
	const gchar* _tmp151_ = NULL;
	const gchar* _tmp152_ = NULL;
	gchar* _tmp153_ = NULL;
	gchar* _tmp154_ = NULL;
	const gchar* _tmp155_ = NULL;
	gchar* switch_to_user = NULL;
	gchar* _tmp159_ = NULL;
	const gchar* _tmp160_ = NULL;
	UserList* _tmp180_ = NULL;
	LoginOption* _tmp181_ = NULL;
	LoginOption* _tmp182_ = NULL;
	GtkStyleContext* _tmp187_ = NULL;
	GtkCssProvider* provider = NULL;
	GtkCssProvider* _tmp188_ = NULL;
	GdkScreen* _tmp189_ = NULL;
	UserListActor* _tmp190_ = NULL;
	ClutterPropertyTransition* _tmp191_ = NULL;
	ClutterPropertyTransition* _tmp192_ = NULL;
	GtkClutterActor* _tmp193_ = NULL;
	ClutterPropertyTransition* _tmp194_ = NULL;
	ClutterPropertyTransition* _tmp195_ = NULL;
	GtkClutterActor* _tmp196_ = NULL;
	ClutterPropertyTransition* _tmp197_ = NULL;
	ClutterPropertyTransition* _tmp198_ = NULL;
	GdkWindow* _tmp199_ = NULL;
	GError * _inner_error_ = NULL;
	self = (PantheonGreeter*) g_object_new (object_type, NULL);
	_tmp0_ = pantheon_greeter_get_instance ();
	_tmp1_ = _tmp0_;
	_vala_assert (_tmp1_ == NULL, "instance == null");
	_tmp2_ = pantheon_greeter_get_instance ();
	_tmp3_ = _tmp2_;
	pantheon_greeter_set_instance (self);
	_tmp4_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp5_ = gdk_screen_get_root_window (_tmp4_);
	_tmp6_ = gdk_window_get_scale_factor (_tmp5_);
	scale_factor = _tmp6_;
	_tmp7_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp8_ = gdk_screen_get_width (_tmp7_);
	_tmp9_ = scale_factor;
	self->priv->g_width = _tmp8_ * _tmp9_;
	_tmp10_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp11_ = gdk_screen_get_height (_tmp10_);
	_tmp12_ = scale_factor;
	self->priv->g_height = _tmp11_ * _tmp12_;
	_tmp13_ = pantheon_greeter_get_TEST_MODE ();
	_tmp14_ = _tmp13_;
	_tmp15_ = g_getenv ("LIGHTDM_TO_SERVER_FD");
	pantheon_greeter_set_TEST_MODE (_tmp15_ == NULL);
	_tmp16_ = pantheon_greeter_get_TEST_MODE ();
	_tmp17_ = _tmp16_;
	if (_tmp17_) {
		LoginGateway* _tmp18_ = NULL;
		LoginGateway* _tmp19_ = NULL;
		DummyGateway* _tmp20_ = NULL;
		DummyGateway* _tmp21_ = NULL;
		g_message ("PantheonGreeter.vala:93: Using dummy LightDM because LIGHTDM_TO_SERVER" \
"_FD was not found.");
		_tmp18_ = pantheon_greeter_get_login_gateway ();
		_tmp19_ = _tmp18_;
		_tmp20_ = dummy_gateway_new ();
		_tmp21_ = _tmp20_;
		pantheon_greeter_set_login_gateway ((LoginGateway*) _tmp21_);
		_g_object_unref0 (_tmp21_);
	} else {
		LoginGateway* _tmp22_ = NULL;
		LoginGateway* _tmp23_ = NULL;
		LightDMGateway* _tmp24_ = NULL;
		LightDMGateway* _tmp25_ = NULL;
		SettingsDaemon* _tmp26_ = NULL;
		SettingsDaemon* _tmp27_ = NULL;
		_tmp22_ = pantheon_greeter_get_login_gateway ();
		_tmp23_ = _tmp22_;
		_tmp24_ = light_dm_gateway_new ();
		_tmp25_ = _tmp24_;
		pantheon_greeter_set_login_gateway ((LoginGateway*) _tmp25_);
		_g_object_unref0 (_tmp25_);
		_tmp26_ = settings_daemon_new ();
		_g_object_unref0 (pantheon_greeter_settings_daemon);
		pantheon_greeter_settings_daemon = _tmp26_;
		_tmp27_ = pantheon_greeter_settings_daemon;
		settings_daemon_start (_tmp27_);
	}
	_tmp28_ = g_get_user_cache_dir ();
	_tmp29_ = g_build_filename (_tmp28_, "unity-greeter", NULL);
	state_dir = _tmp29_;
	_tmp30_ = state_dir;
	g_mkdir_with_parents (_tmp30_, 0775);
	_tmp31_ = g_getenv ("XDG_SEAT");
	_tmp32_ = g_strdup (_tmp31_);
	xdg_seat = _tmp32_;
	_tmp35_ = xdg_seat;
	if (_tmp35_ != NULL) {
		const gchar* _tmp36_ = NULL;
		_tmp36_ = xdg_seat;
		_tmp34_ = g_strcmp0 (_tmp36_, "seat0") != 0;
	} else {
		_tmp34_ = FALSE;
	}
	if (_tmp34_) {
		const gchar* _tmp37_ = NULL;
		gchar* _tmp38_ = NULL;
		_tmp37_ = xdg_seat;
		_tmp38_ = g_strconcat (_tmp37_, "-state", NULL);
		_g_free0 (_tmp33_);
		_tmp33_ = _tmp38_;
	} else {
		gchar* _tmp39_ = NULL;
		_tmp39_ = g_strdup ("state");
		_g_free0 (_tmp33_);
		_tmp33_ = _tmp39_;
	}
	_tmp40_ = g_strdup (_tmp33_);
	state_file_name = _tmp40_;
	_tmp41_ = state_dir;
	_tmp42_ = state_file_name;
	_tmp43_ = g_build_filename (_tmp41_, _tmp42_, NULL);
	_g_free0 (self->priv->state_file);
	self->priv->state_file = _tmp43_;
	_tmp44_ = g_key_file_new ();
	_g_key_file_free0 (self->state);
	self->state = _tmp44_;
	{
		GKeyFile* _tmp45_ = NULL;
		const gchar* _tmp46_ = NULL;
		_tmp45_ = self->state;
		_tmp46_ = self->priv->state_file;
		g_key_file_load_from_file (_tmp45_, _tmp46_, G_KEY_FILE_NONE, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp47_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp47_ = e;
		if (!g_error_matches (_tmp47_, G_FILE_ERROR, G_FILE_ERROR_NOENT)) {
			const gchar* _tmp48_ = NULL;
			GError* _tmp49_ = NULL;
			const gchar* _tmp50_ = NULL;
			_tmp48_ = self->priv->state_file;
			_tmp49_ = e;
			_tmp50_ = _tmp49_->message;
			g_warning ("PantheonGreeter.vala:113: Failed to load state from %s: %s\n", _tmp48_, _tmp50_);
		}
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (state_file_name);
		_g_free0 (_tmp33_);
		_g_free0 (xdg_seat);
		_g_free0 (state_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp51_ = g_key_file_new ();
	_g_key_file_free0 (self->settings);
	self->settings = _tmp51_;
	{
		GKeyFile* _tmp52_ = NULL;
		gchar* _tmp53_ = NULL;
		gchar* _tmp54_ = NULL;
		_tmp52_ = self->settings;
		_tmp53_ = g_build_filename (CONSTANTS_CONF_DIR, "greeter.conf", NULL);
		_tmp54_ = _tmp53_;
		g_key_file_load_from_file (_tmp52_, _tmp54_, G_KEY_FILE_KEEP_COMMENTS, &_inner_error_);
		_g_free0 (_tmp54_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch1_g_error;
		}
	}
	goto __finally1;
	__catch1_g_error:
	{
		GError* e = NULL;
		GError* _tmp55_ = NULL;
		const gchar* _tmp56_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp55_ = e;
		_tmp56_ = _tmp55_->message;
		g_warning ("PantheonGreeter.vala:121: %s", _tmp56_);
		_g_error_free0 (e);
	}
	__finally1:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (state_file_name);
		_g_free0 (_tmp33_);
		_g_free0 (xdg_seat);
		_g_free0 (state_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp57_ = (GtkClutterEmbed*) gtk_clutter_embed_new ();
	g_object_ref_sink (_tmp57_);
	_g_object_unref0 (self->priv->clutter);
	self->priv->clutter = _tmp57_;
	_tmp58_ = self->priv->clutter;
	gtk_widget_add_events ((GtkWidget*) _tmp58_, (gint) (GDK_BUTTON_RELEASE_MASK | GDK_BUTTON_PRESS_MASK));
	_tmp59_ = self->priv->clutter;
	_tmp60_ = gtk_clutter_embed_get_stage (_tmp59_);
	_tmp61_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp60_, clutter_stage_get_type ()) ? ((ClutterStage*) _tmp60_) : NULL);
	stage = _tmp61_;
	_tmp62_ = stage;
	_tmp63_.red = (guint8) 0;
	_tmp63_.green = (guint8) 0;
	_tmp63_.blue = (guint8) 0;
	_tmp63_.alpha = (guint8) 255;
	clutter_actor_set_background_color ((ClutterActor*) _tmp62_, &_tmp63_);
	_tmp64_ = lightdm_user_list_get_instance ();
	_tmp65_ = user_list_new (_tmp64_);
	_g_object_unref0 (self->priv->userlist);
	self->priv->userlist = _tmp65_;
	_tmp66_ = self->priv->userlist;
	_tmp67_ = user_list_actor_new (_tmp66_);
	g_object_ref_sink (_tmp67_);
	_g_object_unref0 (self->priv->userlist_actor);
	self->priv->userlist_actor = _tmp67_;
	_tmp68_ = self->priv->userlist_actor;
	clutter_actor_set_opacity ((ClutterActor*) _tmp68_, (guint8) 0);
	_tmp69_ = time_label_new ();
	g_object_ref_sink (_tmp69_);
	time_label = _tmp69_;
	_tmp70_ = (GtkClutterActor*) gtk_clutter_actor_new ();
	g_object_ref_sink (_tmp70_);
	_g_object_unref0 (self->priv->time_actor);
	self->priv->time_actor = _tmp70_;
	_tmp71_ = self->priv->time_actor;
	_tmp72_ = gtk_clutter_actor_get_widget (_tmp71_);
	_tmp73_ = time_label;
	gtk_container_add (G_TYPE_CHECK_INSTANCE_CAST (_tmp72_, gtk_container_get_type (), GtkContainer), (GtkWidget*) _tmp73_);
	_tmp74_ = power_label_new ();
	g_object_ref_sink (_tmp74_);
	power_label = _tmp74_;
	_tmp75_ = (GtkClutterActor*) gtk_clutter_actor_new ();
	g_object_ref_sink (_tmp75_);
	_g_object_unref0 (self->priv->power_actor);
	self->priv->power_actor = _tmp75_;
	_tmp76_ = self->priv->power_actor;
	_tmp77_ = gtk_clutter_actor_get_widget (_tmp76_);
	_tmp78_ = power_label;
	gtk_container_add (G_TYPE_CHECK_INSTANCE_CAST (_tmp77_, gtk_container_get_type (), GtkContainer), (GtkWidget*) _tmp78_);
	_tmp79_ = wallpaper_new ();
	g_object_ref_sink (_tmp79_);
	_g_object_unref0 (self->priv->wallpaper);
	self->priv->wallpaper = _tmp79_;
	_tmp80_ = (GtkClutterActor*) gtk_clutter_actor_new ();
	g_object_ref_sink (_tmp80_);
	_g_object_unref0 (self->priv->wallpaper_actor);
	self->priv->wallpaper_actor = _tmp80_;
	_tmp81_ = self->priv->wallpaper_actor;
	_tmp82_ = gtk_clutter_actor_get_widget (_tmp81_);
	_tmp83_ = self->priv->wallpaper;
	gtk_container_add (G_TYPE_CHECK_INSTANCE_CAST (_tmp82_, gtk_container_get_type (), GtkContainer), (GtkWidget*) _tmp83_);
	blur_effect = FALSE;
	setting_brightness = (gfloat) 7;
	{
		gboolean _tmp84_ = FALSE;
		GKeyFile* _tmp85_ = NULL;
		gboolean _tmp86_ = FALSE;
		gdouble _tmp87_ = 0.0;
		GKeyFile* _tmp88_ = NULL;
		gdouble _tmp89_ = 0.0;
		_tmp85_ = self->settings;
		_tmp86_ = g_key_file_get_boolean (_tmp85_, "greeter", "blur", &_inner_error_);
		_tmp84_ = _tmp86_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch2_g_error;
		}
		blur_effect = _tmp84_;
		_tmp88_ = self->settings;
		_tmp89_ = g_key_file_get_double (_tmp88_, "greeter", "brightness", &_inner_error_);
		_tmp87_ = _tmp89_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch2_g_error;
		}
		setting_brightness = (gfloat) _tmp87_;
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		GError* _tmp90_ = NULL;
		const gchar* _tmp91_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp90_ = e;
		_tmp91_ = _tmp90_->message;
		g_warning ("PantheonGreeter.vala:158: %s", _tmp91_);
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (power_label);
		_g_object_unref0 (time_label);
		_g_object_unref0 (stage);
		_g_free0 (state_file_name);
		_g_free0 (_tmp33_);
		_g_free0 (xdg_seat);
		_g_free0 (state_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp92_ = blur_effect;
	if (_tmp92_) {
		DeepinBlurEffect* _tmp93_ = NULL;
		GtkClutterActor* _tmp94_ = NULL;
		gint _tmp95_ = 0;
		gint _tmp96_ = 0;
		gfloat _tmp97_ = 0.0F;
		_tmp93_ = self->priv->blur_effect_actor;
		_tmp94_ = self->priv->wallpaper_actor;
		_tmp95_ = self->priv->g_width;
		_tmp96_ = self->priv->g_height;
		_tmp97_ = setting_brightness;
		deepin_blur_effect_setup ((ClutterActor*) _tmp94_, _tmp95_, _tmp96_, _tmp97_, 10);
	}
	pantheon_greeter_monitors_changed (self);
	_tmp98_ = clutter_actor_new ();
	g_object_ref_sink (_tmp98_);
	_g_object_unref0 (self->priv->greeterbox);
	self->priv->greeterbox = _tmp98_;
	_tmp99_ = self->priv->greeterbox;
	_tmp100_ = stage;
	_tmp101_ = (ClutterBindConstraint*) clutter_bind_constraint_new ((ClutterActor*) _tmp100_, CLUTTER_BIND_WIDTH, (gfloat) 0);
	g_object_ref_sink (_tmp101_);
	_tmp102_ = _tmp101_;
	clutter_actor_add_constraint (_tmp99_, (ClutterConstraint*) _tmp102_);
	_g_object_unref0 (_tmp102_);
	_tmp103_ = self->priv->greeterbox;
	_tmp104_ = stage;
	_tmp105_ = (ClutterBindConstraint*) clutter_bind_constraint_new ((ClutterActor*) _tmp104_, CLUTTER_BIND_HEIGHT, (gfloat) 0);
	g_object_ref_sink (_tmp105_);
	_tmp106_ = _tmp105_;
	clutter_actor_add_constraint (_tmp103_, (ClutterConstraint*) _tmp106_);
	_g_object_unref0 (_tmp106_);
	_tmp107_ = self->priv->greeterbox;
	clutter_actor_set_opacity (_tmp107_, (guint) 0);
	_tmp108_ = self->priv->greeterbox;
	clutter_actor_save_easing_state (_tmp108_);
	_tmp109_ = self->priv->greeterbox;
	clutter_actor_set_easing_mode (_tmp109_, CLUTTER_EASE_OUT_QUART);
	_tmp110_ = self->priv->greeterbox;
	clutter_actor_set_easing_duration (_tmp110_, (guint) 250);
	_tmp111_ = self->priv->greeterbox;
	clutter_actor_set_opacity (_tmp111_, (guint8) 255);
	_tmp112_ = self->priv->greeterbox;
	clutter_actor_restore_easing_state (_tmp112_);
	_tmp113_ = self->priv->greeterbox;
	_tmp114_ = self->priv->wallpaper_actor;
	clutter_actor_add_child (_tmp113_, (ClutterActor*) _tmp114_);
	_tmp115_ = self->priv->greeterbox;
	_tmp116_ = self->priv->power_actor;
	clutter_actor_add_child (_tmp115_, (ClutterActor*) _tmp116_);
	_tmp117_ = self->priv->greeterbox;
	_tmp118_ = self->priv->time_actor;
	clutter_actor_add_child (_tmp117_, (ClutterActor*) _tmp118_);
	_tmp119_ = self->priv->greeterbox;
	_tmp120_ = self->priv->userlist_actor;
	clutter_actor_add_child (_tmp119_, (ClutterActor*) _tmp120_);
	_tmp121_ = stage;
	_tmp122_ = self->priv->greeterbox;
	clutter_actor_add_child ((ClutterActor*) _tmp121_, _tmp122_);
	_tmp123_ = self->priv->clutter;
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp123_);
	activate_numlock = FALSE;
	{
		gboolean _tmp124_ = FALSE;
		GKeyFile* _tmp125_ = NULL;
		gboolean _tmp126_ = FALSE;
		_tmp125_ = self->settings;
		_tmp126_ = g_key_file_get_boolean (_tmp125_, "greeter", "activate-numlock", &_inner_error_);
		_tmp124_ = _tmp126_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch3_g_error;
		}
		activate_numlock = _tmp124_;
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		GError* _tmp127_ = NULL;
		const gchar* _tmp128_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp127_ = e;
		_tmp128_ = _tmp127_->message;
		g_warning ("PantheonGreeter.vala:207: %s", _tmp128_);
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (power_label);
		_g_object_unref0 (time_label);
		_g_object_unref0 (stage);
		_g_free0 (state_file_name);
		_g_free0 (_tmp33_);
		_g_free0 (xdg_seat);
		_g_free0 (state_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp129_ = activate_numlock;
	if (_tmp129_) {
	}
	screensaver_timeout = 60;
	{
		gint _tmp130_ = 0;
		GKeyFile* _tmp131_ = NULL;
		gint _tmp132_ = 0;
		_tmp131_ = self->settings;
		_tmp132_ = g_key_file_get_integer (_tmp131_, "greeter", "screensaver-timeout", &_inner_error_);
		_tmp130_ = _tmp132_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch4_g_error;
		}
		screensaver_timeout = _tmp130_;
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		GError* _tmp133_ = NULL;
		const gchar* _tmp134_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp133_ = e;
		_tmp134_ = _tmp133_->message;
		g_warning ("PantheonGreeter.vala:217: %s", _tmp134_);
		_g_error_free0 (e);
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_object_unref0 (power_label);
		_g_object_unref0 (time_label);
		_g_object_unref0 (stage);
		_g_free0 (state_file_name);
		_g_free0 (_tmp33_);
		_g_free0 (xdg_seat);
		_g_free0 (state_dir);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp135_ = gdk_display_get_default ();
	_tmp136_ = gdk_x11_display_get_xdisplay (G_TYPE_CHECK_INSTANCE_TYPE (_tmp135_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp135_) : NULL);
	display = _tmp136_;
	_tmp137_ = display;
	XGetScreenSaver (_tmp137_, &_tmp138_, &_tmp139_, &_tmp140_, &_tmp141_);
	self->priv->timeout = _tmp138_;
	self->priv->interval = _tmp139_;
	self->priv->prefer_blanking = _tmp140_;
	self->priv->allow_exposures = _tmp141_;
	_tmp142_ = display;
	_tmp143_ = screensaver_timeout;
	XSetScreenSaver (_tmp142_, _tmp143_, 0, (gint) PANTHEON_GREETER_SCREENSAVER_ACTIVE, (gint) PANTHEON_GREETER_EXPOSURES_DEFAULT_EXPOSURES);
	_tmp144_ = pantheon_greeter_get_login_gateway ();
	_tmp145_ = _tmp144_;
	_tmp146_ = login_gateway_get_lock (_tmp145_);
	_tmp147_ = _tmp146_;
	if (_tmp147_) {
		Display* _tmp148_ = NULL;
		_tmp148_ = display;
		XForceScreenSaver (_tmp148_, (gint) PANTHEON_GREETER_SCREENSAVER_ACTIVE);
	}
	pantheon_greeter_connect_signals (self);
	_tmp149_ = pantheon_greeter_get_login_gateway ();
	_tmp150_ = _tmp149_;
	_tmp151_ = login_gateway_get_select_user (_tmp150_);
	_tmp152_ = _tmp151_;
	_tmp153_ = g_strdup (_tmp152_);
	select_user = _tmp153_;
	_tmp155_ = select_user;
	if (_tmp155_ != NULL) {
		const gchar* _tmp156_ = NULL;
		gchar* _tmp157_ = NULL;
		_tmp156_ = select_user;
		_tmp157_ = g_strdup (_tmp156_);
		_g_free0 (_tmp154_);
		_tmp154_ = _tmp157_;
	} else {
		gchar* _tmp158_ = NULL;
		_tmp158_ = pantheon_greeter_get_greeter_state (self, "last-user");
		_g_free0 (_tmp154_);
		_tmp154_ = _tmp158_;
	}
	_tmp159_ = g_strdup (_tmp154_);
	switch_to_user = _tmp159_;
	_tmp160_ = switch_to_user;
	if (_tmp160_ != NULL) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp161_ = FALSE;
				_tmp161_ = TRUE;
				while (TRUE) {
					gint _tmp163_ = 0;
					UserList* _tmp164_ = NULL;
					gint _tmp165_ = 0;
					gint _tmp166_ = 0;
					UserList* _tmp167_ = NULL;
					gint _tmp168_ = 0;
					LoginOption* _tmp169_ = NULL;
					LoginOption* _tmp170_ = NULL;
					const gchar* _tmp171_ = NULL;
					const gchar* _tmp172_ = NULL;
					const gchar* _tmp173_ = NULL;
					gboolean _tmp174_ = FALSE;
					if (!_tmp161_) {
						gint _tmp162_ = 0;
						_tmp162_ = i;
						i = _tmp162_ + 1;
					}
					_tmp161_ = FALSE;
					_tmp163_ = i;
					_tmp164_ = self->priv->userlist;
					_tmp165_ = user_list_get_size (_tmp164_);
					_tmp166_ = _tmp165_;
					if (!(_tmp163_ < _tmp166_)) {
						break;
					}
					_tmp167_ = self->priv->userlist;
					_tmp168_ = i;
					_tmp169_ = user_list_get_user (_tmp167_, _tmp168_);
					_tmp170_ = _tmp169_;
					_tmp171_ = login_option_get_name (_tmp170_);
					_tmp172_ = _tmp171_;
					_tmp173_ = switch_to_user;
					_tmp174_ = g_strcmp0 (_tmp172_, _tmp173_) == 0;
					_g_object_unref0 (_tmp170_);
					if (_tmp174_) {
						UserList* _tmp175_ = NULL;
						UserList* _tmp176_ = NULL;
						gint _tmp177_ = 0;
						LoginOption* _tmp178_ = NULL;
						LoginOption* _tmp179_ = NULL;
						_tmp175_ = self->priv->userlist;
						_tmp176_ = self->priv->userlist;
						_tmp177_ = i;
						_tmp178_ = user_list_get_user (_tmp176_, _tmp177_);
						_tmp179_ = _tmp178_;
						user_list_set_current_user (_tmp175_, _tmp179_);
						_g_object_unref0 (_tmp179_);
						break;
					}
				}
			}
		}
	}
	_tmp180_ = self->priv->userlist;
	_tmp181_ = user_list_get_current_user (_tmp180_);
	_tmp182_ = _tmp181_;
	if (_tmp182_ == NULL) {
		UserList* _tmp183_ = NULL;
		UserList* _tmp184_ = NULL;
		LoginOption* _tmp185_ = NULL;
		LoginOption* _tmp186_ = NULL;
		_tmp183_ = self->priv->userlist;
		_tmp184_ = self->priv->userlist;
		_tmp185_ = user_list_get_user (_tmp184_, 0);
		_tmp186_ = _tmp185_;
		user_list_set_current_user (_tmp183_, _tmp186_);
		_g_object_unref0 (_tmp186_);
	}
	_tmp187_ = gtk_widget_get_style_context ((GtkWidget*) self);
	gtk_style_context_add_class (_tmp187_, "greeter");
	_tmp188_ = gtk_css_provider_new ();
	provider = _tmp188_;
	gtk_css_provider_load_from_resource (provider, "io/elementary/greeter/Greeter.css");
	_tmp189_ = gdk_screen_get_default ();
	gtk_style_context_add_provider_for_screen (_tmp189_, (GtkStyleProvider*) provider, (guint) GTK_STYLE_PROVIDER_PRIORITY_APPLICATION);
	gtk_widget_show_all ((GtkWidget*) self);
	_tmp190_ = self->priv->userlist_actor;
	_tmp191_ = pantheon_greeter_fade_in_actor (self, (ClutterActor*) _tmp190_);
	_tmp192_ = _tmp191_;
	_g_object_unref0 (_tmp192_);
	_tmp193_ = self->priv->time_actor;
	_tmp194_ = pantheon_greeter_fade_in_actor (self, (ClutterActor*) _tmp193_);
	_tmp195_ = _tmp194_;
	_g_object_unref0 (_tmp195_);
	_tmp196_ = self->priv->wallpaper_actor;
	_tmp197_ = pantheon_greeter_fade_in_actor (self, (ClutterActor*) _tmp196_);
	_tmp198_ = _tmp197_;
	_g_object_unref0 (_tmp198_);
	_tmp199_ = gtk_widget_get_window ((GtkWidget*) self);
	gdk_window_focus (_tmp199_, (guint32) GDK_CURRENT_TIME);
	_g_object_unref0 (provider);
	_g_free0 (switch_to_user);
	_g_free0 (_tmp154_);
	_g_free0 (select_user);
	_g_object_unref0 (power_label);
	_g_object_unref0 (time_label);
	_g_object_unref0 (stage);
	_g_free0 (state_file_name);
	_g_free0 (_tmp33_);
	_g_free0 (xdg_seat);
	_g_free0 (state_dir);
	return self;
}


PantheonGreeter* pantheon_greeter_new (void) {
	return pantheon_greeter_construct (TYPE_PANTHEON_GREETER);
}


gchar* pantheon_greeter_load_from_resource (PantheonGreeter* self, const gchar* uri, GError** error) {
	gchar* result = NULL;
	GFile* file = NULL;
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFileInputStream* stream = NULL;
	GFile* _tmp2_ = NULL;
	GFileInputStream* _tmp3_ = NULL;
	GDataInputStream* dis = NULL;
	GFileInputStream* _tmp4_ = NULL;
	GDataInputStream* _tmp5_ = NULL;
	GString* builder = NULL;
	GString* _tmp6_ = NULL;
	gchar* line = NULL;
	GString* _tmp14_ = NULL;
	const gchar* _tmp15_ = NULL;
	gchar* _tmp16_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (uri != NULL, NULL);
	_tmp0_ = uri;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	file = _tmp1_;
	_tmp2_ = file;
	_tmp3_ = g_file_read (_tmp2_, NULL, &_inner_error_);
	stream = _tmp3_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (file);
		return NULL;
	}
	_tmp4_ = stream;
	_tmp5_ = g_data_input_stream_new ((GInputStream*) _tmp4_);
	dis = _tmp5_;
	_tmp6_ = g_string_new ("");
	builder = _tmp6_;
	while (TRUE) {
		gchar* _tmp7_ = NULL;
		GDataInputStream* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		const gchar* _tmp11_ = NULL;
		GString* _tmp12_ = NULL;
		const gchar* _tmp13_ = NULL;
		_tmp8_ = dis;
		_tmp9_ = g_data_input_stream_read_line (_tmp8_, NULL, NULL, &_inner_error_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (line);
			_g_string_free0 (builder);
			_g_object_unref0 (dis);
			_g_object_unref0 (stream);
			_g_object_unref0 (file);
			return NULL;
		}
		_tmp10_ = _tmp7_;
		_tmp7_ = NULL;
		_g_free0 (line);
		line = _tmp10_;
		_tmp11_ = line;
		if (!(_tmp11_ != NULL)) {
			_g_free0 (_tmp7_);
			break;
		}
		_tmp12_ = builder;
		_tmp13_ = line;
		g_string_append (_tmp12_, _tmp13_);
		_g_free0 (_tmp7_);
	}
	_tmp14_ = builder;
	_tmp15_ = _tmp14_->str;
	_tmp16_ = g_strdup (_tmp15_);
	result = _tmp16_;
	_g_free0 (line);
	_g_string_free0 (builder);
	_g_object_unref0 (dis);
	_g_object_unref0 (stream);
	_g_object_unref0 (file);
	return result;
}


static void _pantheon_greeter_monitors_changed_gdk_screen_monitors_changed (GdkScreen* _sender, gpointer self) {
	pantheon_greeter_monitors_changed ((PantheonGreeter*) self);
}


static void __lambda27_ (PantheonGreeter* self) {
	Display* display = NULL;
	GdkDisplay* _tmp0_ = NULL;
	Display* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	pantheon_greeter_fade_out_ui (self);
	_tmp0_ = gdk_display_get_default ();
	_tmp1_ = gdk_x11_display_get_xdisplay (G_TYPE_CHECK_INSTANCE_TYPE (_tmp0_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp0_) : NULL);
	display = _tmp1_;
	_tmp2_ = self->priv->timeout;
	g_message ("PantheonGreeter.vala:281: restore user timeout: %d", _tmp2_);
	_tmp3_ = self->priv->timeout;
	_tmp4_ = self->priv->interval;
	_tmp5_ = self->priv->prefer_blanking;
	_tmp6_ = self->priv->allow_exposures;
	XSetScreenSaver (display, _tmp3_, _tmp4_, _tmp5_, _tmp6_);
}


static void ___lambda27__login_gateway_login_successful (LoginGateway* _sender, gpointer self) {
	__lambda27_ ((PantheonGreeter*) self);
}


static gboolean __lambda29_ (PantheonGreeter* self) {
	gboolean result = FALSE;
	pantheon_greeter_reposition (self);
	result = FALSE;
	return result;
}


static gboolean ___lambda29__gtk_widget_configure_event (GtkWidget* _sender, GdkEventConfigure* event, gpointer self) {
	gboolean result;
	result = __lambda29_ ((PantheonGreeter*) self);
	return result;
}


static gboolean __lambda30_ (PantheonGreeter* self) {
	gboolean result = FALSE;
	exit (EXIT_SUCCESS);
	result = FALSE;
	return result;
}


static gboolean ___lambda30__gtk_widget_delete_event (GtkWidget* _sender, GdkEventAny* event, gpointer self) {
	gboolean result;
	result = __lambda30_ ((PantheonGreeter*) self);
	return result;
}


static void __lambda31_ (PantheonGreeter* self, LoginOption* user) {
	Wallpaper* _tmp0_ = NULL;
	LoginOption* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	g_return_if_fail (user != NULL);
	_tmp0_ = self->priv->wallpaper;
	_tmp1_ = user;
	_tmp2_ = login_option_get_background (_tmp1_);
	_tmp3_ = _tmp2_;
	wallpaper_set_wallpaper (_tmp0_, _tmp3_);
}


static void ___lambda31__user_list_current_user_changed (UserList* _sender, LoginOption* user, gpointer self) {
	__lambda31_ ((PantheonGreeter*) self, user);
}


static gboolean _pantheon_greeter_keyboard_navigation_gtk_widget_key_press_event (GtkWidget* _sender, GdkEventKey* event, gpointer self) {
	gboolean result;
	result = pantheon_greeter_keyboard_navigation ((PantheonGreeter*) self, event);
	return result;
}


static gboolean _pantheon_greeter_scroll_navigation_gtk_widget_scroll_event (GtkWidget* _sender, GdkEventScroll* event, gpointer self) {
	gboolean result;
	result = pantheon_greeter_scroll_navigation ((PantheonGreeter*) self, event);
	return result;
}


static void pantheon_greeter_connect_signals (PantheonGreeter* self) {
	GdkScreen* _tmp0_ = NULL;
	LoginGateway* _tmp1_ = NULL;
	LoginGateway* _tmp2_ = NULL;
	UserList* _tmp3_ = NULL;
	GtkClutterEmbed* _tmp4_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_window_get_screen ((GtkWindow*) self);
	g_signal_connect_object (_tmp0_, "monitors-changed", (GCallback) _pantheon_greeter_monitors_changed_gdk_screen_monitors_changed, self, 0);
	_tmp1_ = pantheon_greeter_get_login_gateway ();
	_tmp2_ = _tmp1_;
	g_signal_connect_object (_tmp2_, "login-successful", (GCallback) ___lambda27__login_gateway_login_successful, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "configure-event", (GCallback) ___lambda29__gtk_widget_configure_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "delete-event", (GCallback) ___lambda30__gtk_widget_delete_event, self, 0);
	_tmp3_ = self->priv->userlist;
	g_signal_connect_object (_tmp3_, "current-user-changed", (GCallback) ___lambda31__user_list_current_user_changed, self, 0);
	_tmp4_ = self->priv->clutter;
	g_signal_connect_object ((GtkWidget*) _tmp4_, "key-press-event", (GCallback) _pantheon_greeter_keyboard_navigation_gtk_widget_key_press_event, self, 0);
	g_signal_connect_object ((GtkWidget*) self, "scroll-event", (GCallback) _pantheon_greeter_scroll_navigation_gtk_widget_scroll_event, self, 0);
}


/**
     * Fades out an actor and returns the used transition that we can
     * connect us to its completed-signal.
     */
static ClutterPropertyTransition* pantheon_greeter_fade_out_actor (PantheonGreeter* self, ClutterActor* actor) {
	ClutterPropertyTransition* result = NULL;
	ClutterPropertyTransition* transition = NULL;
	ClutterPropertyTransition* _tmp0_ = NULL;
	ClutterActor* _tmp1_ = NULL;
	ClutterActor* _tmp2_ = NULL;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	GValue _tmp5_ = {0};
	GValue _tmp6_ = {0};
	ClutterActor* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (actor != NULL, NULL);
	_tmp0_ = (ClutterPropertyTransition*) clutter_property_transition_new ("opacity");
	transition = _tmp0_;
	_tmp1_ = actor;
	clutter_transition_set_animatable ((ClutterTransition*) transition, (ClutterAnimatable*) _tmp1_);
	clutter_timeline_set_duration ((ClutterTimeline*) transition, (guint) 600);
	clutter_timeline_set_progress_mode ((ClutterTimeline*) transition, CLUTTER_EASE_OUT_CIRC);
	_tmp2_ = actor;
	_tmp3_ = clutter_actor_get_opacity (_tmp2_);
	_tmp4_ = _tmp3_;
	g_value_init (&_tmp5_, G_TYPE_UINT);
	g_value_set_uint (&_tmp5_, _tmp4_);
	clutter_transition_set_from_value ((ClutterTransition*) transition, &_tmp5_);
	G_IS_VALUE (&_tmp5_) ? (g_value_unset (&_tmp5_), NULL) : NULL;
	g_value_init (&_tmp6_, G_TYPE_INT);
	g_value_set_int (&_tmp6_, 0);
	clutter_transition_set_to_value ((ClutterTransition*) transition, &_tmp6_);
	G_IS_VALUE (&_tmp6_) ? (g_value_unset (&_tmp6_), NULL) : NULL;
	_tmp7_ = actor;
	clutter_actor_add_transition (_tmp7_, "fadeout", (ClutterTransition*) transition);
	result = transition;
	return result;
}


/**
     * Fades out an actor and returns the used transition that we can
     * connect us to its completed-signal.
     */
static ClutterPropertyTransition* pantheon_greeter_fade_in_actor (PantheonGreeter* self, ClutterActor* actor) {
	ClutterPropertyTransition* result = NULL;
	ClutterPropertyTransition* transition = NULL;
	ClutterPropertyTransition* _tmp0_ = NULL;
	ClutterActor* _tmp1_ = NULL;
	ClutterActor* _tmp2_ = NULL;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	GValue _tmp5_ = {0};
	GValue _tmp6_ = {0};
	ClutterActor* _tmp7_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (actor != NULL, NULL);
	_tmp0_ = (ClutterPropertyTransition*) clutter_property_transition_new ("opacity");
	transition = _tmp0_;
	_tmp1_ = actor;
	clutter_transition_set_animatable ((ClutterTransition*) transition, (ClutterAnimatable*) _tmp1_);
	clutter_timeline_set_duration ((ClutterTimeline*) transition, (guint) 400);
	clutter_timeline_set_progress_mode ((ClutterTimeline*) transition, CLUTTER_EASE_IN_CIRC);
	_tmp2_ = actor;
	_tmp3_ = clutter_actor_get_opacity (_tmp2_);
	_tmp4_ = _tmp3_;
	g_value_init (&_tmp5_, G_TYPE_UINT);
	g_value_set_uint (&_tmp5_, _tmp4_);
	clutter_transition_set_from_value ((ClutterTransition*) transition, &_tmp5_);
	G_IS_VALUE (&_tmp5_) ? (g_value_unset (&_tmp5_), NULL) : NULL;
	g_value_init (&_tmp6_, G_TYPE_INT);
	g_value_set_int (&_tmp6_, 255);
	clutter_transition_set_to_value ((ClutterTransition*) transition, &_tmp6_);
	G_IS_VALUE (&_tmp6_) ? (g_value_unset (&_tmp6_), NULL) : NULL;
	_tmp7_ = actor;
	clutter_actor_add_transition (_tmp7_, "fadein", (ClutterTransition*) transition);
	result = transition;
	return result;
}


/**
     * Fades out the ui and then starts the session.
     * Only call this if the LoginGateway has signaled it is awaiting
     * start_session by firing login_successful!.
     */
static void __lambda28_ (PantheonGreeter* self) {
	LoginGateway* _tmp0_ = NULL;
	LoginGateway* _tmp1_ = NULL;
	_tmp0_ = pantheon_greeter_get_login_gateway ();
	_tmp1_ = _tmp0_;
	login_gateway_start_session (_tmp1_);
}


static void ___lambda28__clutter_timeline_completed (ClutterTimeline* _sender, gpointer self) {
	__lambda28_ ((PantheonGreeter*) self);
}


static void pantheon_greeter_fade_out_ui (PantheonGreeter* self) {
	ClutterPropertyTransition* anim = NULL;
	GtkClutterActor* _tmp0_ = NULL;
	ClutterPropertyTransition* _tmp1_ = NULL;
	UserListActor* _tmp2_ = NULL;
	ClutterPropertyTransition* _tmp3_ = NULL;
	ClutterPropertyTransition* _tmp4_ = NULL;
	GtkClutterActor* _tmp5_ = NULL;
	ClutterPropertyTransition* _tmp6_ = NULL;
	ClutterPropertyTransition* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	pantheon_greeter_refresh_background (self);
	_tmp0_ = self->priv->time_actor;
	_tmp1_ = pantheon_greeter_fade_out_actor (self, (ClutterActor*) _tmp0_);
	anim = _tmp1_;
	_tmp2_ = self->priv->userlist_actor;
	_tmp3_ = pantheon_greeter_fade_out_actor (self, (ClutterActor*) _tmp2_);
	_tmp4_ = _tmp3_;
	_g_object_unref0 (_tmp4_);
	_tmp5_ = self->priv->power_actor;
	_tmp6_ = pantheon_greeter_fade_out_actor (self, (ClutterActor*) _tmp5_);
	_tmp7_ = _tmp6_;
	_g_object_unref0 (_tmp7_);
	g_signal_connect_object ((ClutterTimeline*) anim, "completed", (GCallback) ___lambda28__clutter_timeline_completed, self, 0);
	_g_object_unref0 (anim);
}


static void pantheon_greeter_monitors_changed (PantheonGreeter* self) {
	GdkRectangle geometry = {0};
	GdkScreen* _tmp0_ = NULL;
	GdkScreen* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	GdkRectangle _tmp3_ = {0};
	GdkRectangle _tmp4_ = {0};
	gint _tmp5_ = 0;
	GdkRectangle _tmp6_ = {0};
	gint _tmp7_ = 0;
	GdkRectangle _tmp8_ = {0};
	gint _tmp9_ = 0;
	GdkRectangle _tmp10_ = {0};
	gint _tmp11_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp1_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp2_ = gdk_screen_get_primary_monitor (_tmp1_);
	gdk_screen_get_monitor_geometry (_tmp0_, _tmp2_, &_tmp3_);
	geometry = _tmp3_;
	_tmp4_ = geometry;
	_tmp5_ = _tmp4_.width;
	_tmp6_ = geometry;
	_tmp7_ = _tmp6_.height;
	gtk_window_resize ((GtkWindow*) self, _tmp5_, _tmp7_);
	_tmp8_ = geometry;
	_tmp9_ = _tmp8_.x;
	_tmp10_ = geometry;
	_tmp11_ = _tmp10_.y;
	gtk_window_move ((GtkWindow*) self, _tmp9_, _tmp11_);
	pantheon_greeter_reposition (self);
}


static void pantheon_greeter_reposition (PantheonGreeter* self) {
	gint width = 0;
	gint height = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	UserListActor* _tmp10_ = NULL;
	gint _tmp11_ = 0;
	GtkClutterActor* _tmp12_ = NULL;
	gint _tmp13_ = 0;
	GtkClutterActor* _tmp14_ = NULL;
	gfloat _tmp15_ = 0.0F;
	gfloat _tmp16_ = 0.0F;
	GtkClutterActor* _tmp17_ = NULL;
	gint _tmp18_ = 0;
	GtkClutterActor* _tmp19_ = NULL;
	gfloat _tmp20_ = 0.0F;
	gfloat _tmp21_ = 0.0F;
	GtkClutterActor* _tmp22_ = NULL;
	gint _tmp23_ = 0;
	GtkClutterActor* _tmp24_ = NULL;
	gint _tmp25_ = 0;
	GtkClutterActor* _tmp26_ = NULL;
	gfloat _tmp27_ = 0.0F;
	gfloat _tmp28_ = 0.0F;
	GtkClutterActor* _tmp29_ = NULL;
	GtkClutterActor* _tmp30_ = NULL;
	gint _tmp31_ = 0;
	GtkClutterActor* _tmp32_ = NULL;
	gint _tmp33_ = 0;
	Wallpaper* _tmp34_ = NULL;
	gint _tmp35_ = 0;
	Wallpaper* _tmp36_ = NULL;
	gint _tmp37_ = 0;
	Wallpaper* _tmp38_ = NULL;
	g_return_if_fail (self != NULL);
	width = 0;
	height = 0;
	gtk_window_get_size ((GtkWindow*) self, &_tmp0_, &_tmp1_);
	width = _tmp0_;
	height = _tmp1_;
	_tmp2_ = height;
	if (_tmp2_ > PANTHEON_GREETER_NORMAL_HEIGHT) {
		UserListActor* _tmp3_ = NULL;
		gint _tmp4_ = 0;
		UserListActor* _tmp5_ = NULL;
		gfloat _tmp6_ = 0.0F;
		gfloat _tmp7_ = 0.0F;
		_tmp3_ = self->priv->userlist_actor;
		_tmp4_ = height;
		_tmp5_ = self->priv->userlist_actor;
		_tmp6_ = clutter_actor_get_height ((ClutterActor*) _tmp5_);
		_tmp7_ = _tmp6_;
		clutter_actor_set_y ((ClutterActor*) _tmp3_, (_tmp4_ / 2) - (_tmp7_ / 2));
	} else {
		UserListActor* _tmp8_ = NULL;
		gint _tmp9_ = 0;
		_tmp8_ = self->priv->userlist_actor;
		_tmp9_ = height;
		clutter_actor_set_y ((ClutterActor*) _tmp8_, (gfloat) (_tmp9_ / 2));
	}
	_tmp10_ = self->priv->userlist_actor;
	_tmp11_ = width;
	clutter_actor_set_x ((ClutterActor*) _tmp10_, (gfloat) ((_tmp11_ / 2) - 50));
	_tmp12_ = self->priv->time_actor;
	_tmp13_ = width;
	_tmp14_ = self->priv->time_actor;
	_tmp15_ = clutter_actor_get_width ((ClutterActor*) _tmp14_);
	_tmp16_ = _tmp15_;
	clutter_actor_set_x ((ClutterActor*) _tmp12_, (_tmp13_ - _tmp16_) - 150);
	_tmp17_ = self->priv->time_actor;
	_tmp18_ = height;
	_tmp19_ = self->priv->time_actor;
	_tmp20_ = clutter_actor_get_height ((ClutterActor*) _tmp19_);
	_tmp21_ = _tmp20_;
	clutter_actor_set_y ((ClutterActor*) _tmp17_, (_tmp18_ - _tmp21_) - 100);
	_tmp22_ = self->priv->time_actor;
	_tmp23_ = width;
	g_object_set ((ClutterActor*) _tmp22_, "visible", _tmp23_ > PANTHEON_GREETER_NO_CLOCK_WIDTH, NULL);
	_tmp24_ = self->priv->power_actor;
	_tmp25_ = width;
	_tmp26_ = self->priv->power_actor;
	_tmp27_ = clutter_actor_get_width ((ClutterActor*) _tmp26_);
	_tmp28_ = _tmp27_;
	clutter_actor_set_x ((ClutterActor*) _tmp24_, (_tmp25_ - _tmp28_) - 10);
	_tmp29_ = self->priv->power_actor;
	clutter_actor_set_y ((ClutterActor*) _tmp29_, (gfloat) 10);
	_tmp30_ = self->priv->wallpaper_actor;
	_tmp31_ = width;
	clutter_actor_set_width ((ClutterActor*) _tmp30_, (gfloat) _tmp31_);
	_tmp32_ = self->priv->wallpaper_actor;
	_tmp33_ = height;
	clutter_actor_set_height ((ClutterActor*) _tmp32_, (gfloat) _tmp33_);
	_tmp34_ = self->priv->wallpaper;
	_tmp35_ = width;
	wallpaper_set_screen_width (_tmp34_, _tmp35_);
	_tmp36_ = self->priv->wallpaper;
	_tmp37_ = height;
	wallpaper_set_screen_height (_tmp36_, _tmp37_);
	_tmp38_ = self->priv->wallpaper;
	wallpaper_reposition (_tmp38_);
}


static gboolean pantheon_greeter_keyboard_navigation (PantheonGreeter* self, GdkEventKey* e) {
	gboolean result = FALSE;
	GdkEventKey* _tmp0_ = NULL;
	guint _tmp1_ = 0U;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = e;
	_tmp1_ = _tmp0_->keyval;
	switch (_tmp1_) {
		case GDK_KEY_Num_Lock:
		{
			gboolean activate_numlock = FALSE;
			GKeyFile* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			activate_numlock = FALSE;
			{
				gboolean _tmp2_ = FALSE;
				GKeyFile* _tmp3_ = NULL;
				gboolean _tmp4_ = FALSE;
				_tmp3_ = self->settings;
				_tmp4_ = g_key_file_get_boolean (_tmp3_, "greeter", "activate-numlock", &_inner_error_);
				_tmp2_ = _tmp4_;
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					goto __catch5_g_error;
				}
				activate_numlock = _tmp2_;
			}
			goto __finally5;
			__catch5_g_error:
			{
				GError* e = NULL;
				GError* _tmp5_ = NULL;
				const gchar* _tmp6_ = NULL;
				e = _inner_error_;
				_inner_error_ = NULL;
				_tmp5_ = e;
				_tmp6_ = _tmp5_->message;
				g_warning ("PantheonGreeter.vala:402: %s", _tmp6_);
				_g_error_free0 (e);
			}
			__finally5:
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return FALSE;
			}
			_tmp7_ = self->settings;
			_tmp8_ = activate_numlock;
			g_key_file_set_boolean (_tmp7_, "greeter", "activate-numlock", !_tmp8_);
			break;
		}
		case GDK_KEY_Up:
		{
			UserList* _tmp9_ = NULL;
			_tmp9_ = self->priv->userlist;
			user_list_select_prev_user (_tmp9_);
			break;
		}
		case GDK_KEY_Down:
		{
			UserList* _tmp10_ = NULL;
			_tmp10_ = self->priv->userlist;
			user_list_select_next_user (_tmp10_);
			break;
		}
		default:
		{
			result = FALSE;
			return result;
		}
	}
	result = TRUE;
	return result;
}


static gboolean pantheon_greeter_scroll_navigation (PantheonGreeter* self, GdkEventScroll* e) {
	gboolean result = FALSE;
	GdkEventScroll* _tmp0_ = NULL;
	GdkScrollDirection _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (e != NULL, FALSE);
	_tmp0_ = e;
	_tmp1_ = _tmp0_->direction;
	switch (_tmp1_) {
		case GDK_SCROLL_UP:
		{
			UserList* _tmp2_ = NULL;
			_tmp2_ = self->priv->userlist;
			user_list_select_prev_user (_tmp2_);
			break;
		}
		case GDK_SCROLL_DOWN:
		{
			UserList* _tmp3_ = NULL;
			_tmp3_ = self->priv->userlist;
			user_list_select_next_user (_tmp3_);
			break;
		}
		default:
		break;
	}
	result = FALSE;
	return result;
}


gchar* pantheon_greeter_get_greeter_state (PantheonGreeter* self, const gchar* key) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	{
		gchar* _tmp0_ = NULL;
		GKeyFile* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_ = NULL;
		_tmp1_ = self->state;
		_tmp2_ = key;
		_tmp3_ = g_key_file_get_value (_tmp1_, "greeter", _tmp2_, &_inner_error_);
		_tmp0_ = _tmp3_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch6_g_error;
		}
		_tmp4_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp4_;
		_g_free0 (_tmp0_);
		return result;
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		result = NULL;
		_g_error_free0 (e);
		return result;
	}
	__finally6:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return NULL;
}


void pantheon_greeter_set_greeter_state (PantheonGreeter* self, const gchar* key, const gchar* value) {
	GKeyFile* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* data = NULL;
	GKeyFile* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	g_return_if_fail (value != NULL);
	_tmp0_ = self->state;
	_tmp1_ = key;
	_tmp2_ = value;
	g_key_file_set_value (_tmp0_, "greeter", _tmp1_, _tmp2_);
	_tmp3_ = self->state;
	_tmp4_ = g_key_file_to_data (_tmp3_, NULL, NULL);
	data = _tmp4_;
	{
		const gchar* _tmp5_ = NULL;
		_tmp5_ = self->priv->state_file;
		g_file_set_contents (_tmp5_, data, (gssize) -1, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch7_g_error;
		}
	}
	goto __finally7;
	__catch7_g_error:
	{
		GError* e = NULL;
		GError* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = e;
		_tmp7_ = _tmp6_->message;
		g_warning ("PantheonGreeter.vala:448: Failed to write state: %s", _tmp7_);
		_g_error_free0 (e);
	}
	__finally7:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (data);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_free0 (data);
}


static cairo_surface_t* pantheon_greeter_create_root_surface (PantheonGreeter* self, GdkScreen* screen) {
	cairo_surface_t* result = NULL;
	GdkVisual* visual = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkVisual* _tmp1_ = NULL;
	GdkVisual* _tmp2_ = NULL;
	Visual* xvisual = NULL;
	Visual* _tmp3_ = NULL;
	GdkX11Display* gdk_display = NULL;
	GdkScreen* _tmp4_ = NULL;
	GdkDisplay* _tmp5_ = NULL;
	GdkX11Display* _tmp6_ = NULL;
	Display* display = NULL;
	Display* _tmp7_ = NULL;
	GdkX11Window* root_window = NULL;
	GdkScreen* _tmp8_ = NULL;
	GdkWindow* _tmp9_ = NULL;
	GdkX11Window* _tmp10_ = NULL;
	Pixmap pixmap = 0;
	Window _tmp11_ = 0;
	GdkScreen* _tmp12_ = NULL;
	gint _tmp13_ = 0;
	gint _tmp14_ = 0;
	GdkScreen* _tmp15_ = NULL;
	gint _tmp16_ = 0;
	gint _tmp17_ = 0;
	gint _tmp18_ = 0;
	Pixmap _tmp19_ = 0;
	cairo_surface_t* surface = NULL;
	GdkScreen* _tmp20_ = NULL;
	gint _tmp21_ = 0;
	gint _tmp22_ = 0;
	GdkScreen* _tmp23_ = NULL;
	gint _tmp24_ = 0;
	gint _tmp25_ = 0;
	cairo_surface_t* _tmp26_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (screen != NULL, NULL);
	_tmp0_ = screen;
	_tmp1_ = gdk_screen_get_system_visual (_tmp0_);
	_tmp2_ = _g_object_ref0 (_tmp1_);
	visual = _tmp2_;
	_tmp3_ = gdk_x11_visual_get_xvisual (G_TYPE_CHECK_INSTANCE_TYPE (visual, gdk_x11_visual_get_type ()) ? ((GdkX11Visual*) visual) : NULL);
	xvisual = _tmp3_;
	_tmp4_ = screen;
	_tmp5_ = gdk_screen_get_display (_tmp4_);
	_tmp6_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp5_) : NULL);
	gdk_display = _tmp6_;
	_tmp7_ = gdk_x11_display_get_xdisplay (gdk_display);
	display = _tmp7_;
	_tmp8_ = screen;
	_tmp9_ = gdk_screen_get_root_window (_tmp8_);
	_tmp10_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp9_, gdk_x11_window_get_type ()) ? ((GdkX11Window*) _tmp9_) : NULL);
	root_window = _tmp10_;
	_tmp11_ = gdk_x11_window_get_xid (root_window);
	_tmp12_ = screen;
	_tmp13_ = gdk_screen_get_width (_tmp12_);
	_tmp14_ = gdk_window_get_scale_factor ((GdkWindow*) root_window);
	_tmp15_ = screen;
	_tmp16_ = gdk_screen_get_height (_tmp15_);
	_tmp17_ = gdk_window_get_scale_factor ((GdkWindow*) root_window);
	_tmp18_ = gdk_visual_get_depth (visual);
	_tmp19_ = XCreatePixmap (display, (Drawable) _tmp11_, (guint) (_tmp13_ * _tmp14_), (guint) (_tmp16_ * _tmp17_), (guint) _tmp18_);
	pixmap = _tmp19_;
	_tmp20_ = screen;
	_tmp21_ = gdk_screen_get_width (_tmp20_);
	_tmp22_ = gdk_window_get_scale_factor ((GdkWindow*) root_window);
	_tmp23_ = screen;
	_tmp24_ = gdk_screen_get_height (_tmp23_);
	_tmp25_ = gdk_window_get_scale_factor ((GdkWindow*) root_window);
	_tmp26_ = cairo_xlib_surface_create (display, (gint) pixmap, xvisual, _tmp21_ * _tmp22_, _tmp24_ * _tmp25_);
	surface = _tmp26_;
	result = surface;
	_g_object_unref0 (root_window);
	_g_object_unref0 (gdk_display);
	_g_object_unref0 (visual);
	return result;
}


static void pantheon_greeter_draw_wallpaper_on_surface (PantheonGreeter* self, cairo_surface_t* surface) {
	cairo_t* ctx = NULL;
	cairo_surface_t* _tmp0_ = NULL;
	cairo_t* _tmp1_ = NULL;
	gint scale_factor = 0;
	GdkScreen* _tmp2_ = NULL;
	GdkWindow* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint width = 0;
	GdkScreen* _tmp5_ = NULL;
	gint _tmp6_ = 0;
	gint height = 0;
	GdkScreen* _tmp7_ = NULL;
	gint _tmp8_ = 0;
	GdkPixbuf* current_pixbuf = NULL;
	Wallpaper* _tmp9_ = NULL;
	GdkPixbuf* _tmp10_ = NULL;
	GdkPixbuf* _tmp11_ = NULL;
	cairo_surface_t* img_surface = NULL;
	cairo_surface_t* _tmp12_ = NULL;
	gint _tmp13_ = 0;
	gint _tmp14_ = 0;
	gint _tmp15_ = 0;
	gint _tmp16_ = 0;
	cairo_surface_t* _tmp17_ = NULL;
	cairo_t* img_ctx = NULL;
	cairo_t* _tmp18_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (surface != NULL);
	_tmp0_ = surface;
	_tmp1_ = cairo_create (_tmp0_);
	ctx = _tmp1_;
	cairo_save (ctx);
	cairo_set_source_rgba (ctx, 0.0, 0.0, 0.0, 0.0);
	_tmp2_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp3_ = gdk_screen_get_root_window (_tmp2_);
	_tmp4_ = gdk_window_get_scale_factor (_tmp3_);
	scale_factor = _tmp4_;
	_tmp5_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp6_ = gdk_screen_get_width (_tmp5_);
	width = _tmp6_ * scale_factor;
	_tmp7_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp8_ = gdk_screen_get_height (_tmp7_);
	height = _tmp8_ * scale_factor;
	_tmp9_ = self->priv->wallpaper;
	_tmp10_ = _tmp9_->background_pixbuf;
	_tmp11_ = wallpaper_scale_to_rect (_tmp10_, width, height);
	current_pixbuf = _tmp11_;
	_tmp12_ = surface;
	_tmp13_ = gdk_pixbuf_get_width (current_pixbuf);
	_tmp14_ = _tmp13_;
	_tmp15_ = gdk_pixbuf_get_height (current_pixbuf);
	_tmp16_ = _tmp15_;
	_tmp17_ = cairo_surface_create_similar (_tmp12_, CAIRO_CONTENT_COLOR_ALPHA, _tmp14_, _tmp16_);
	img_surface = _tmp17_;
	_tmp18_ = cairo_create (img_surface);
	img_ctx = _tmp18_;
	gdk_cairo_set_source_pixbuf (img_ctx, current_pixbuf, (gdouble) 0, (gdouble) 0);
	cairo_paint (img_ctx);
	cairo_set_source_surface (ctx, img_surface, (gdouble) 0, (gdouble) 0);
	cairo_paint (ctx);
	cairo_restore (ctx);
	_cairo_destroy0 (img_ctx);
	_cairo_surface_destroy0 (img_surface);
	_g_object_unref0 (current_pixbuf);
	_cairo_destroy0 (ctx);
}


static void pantheon_greeter_refresh_background (PantheonGreeter* self) {
	GdkScreen* screen = NULL;
	GdkScreen* _tmp0_ = NULL;
	GdkScreen* _tmp1_ = NULL;
	GdkX11Window* root_window = NULL;
	GdkWindow* _tmp2_ = NULL;
	GdkX11Window* _tmp3_ = NULL;
	cairo_surface_t* background_surface = NULL;
	cairo_surface_t* _tmp4_ = NULL;
	GdkX11Display* x_display = NULL;
	GdkDisplay* _tmp5_ = NULL;
	GdkX11Display* _tmp6_ = NULL;
	Display* display = NULL;
	Display* _tmp7_ = NULL;
	Window _tmp8_ = 0;
	gint _tmp9_ = 0;
	Window _tmp10_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_window_get_screen ((GtkWindow*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	screen = _tmp1_;
	_tmp2_ = gdk_screen_get_root_window (screen);
	_tmp3_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp2_, gdk_x11_window_get_type ()) ? ((GdkX11Window*) _tmp2_) : NULL);
	root_window = _tmp3_;
	_tmp4_ = pantheon_greeter_create_root_surface (self, screen);
	background_surface = _tmp4_;
	pantheon_greeter_draw_wallpaper_on_surface (self, background_surface);
	gdk_flush ();
	_tmp5_ = gdk_screen_get_display (screen);
	_tmp6_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_TYPE (_tmp5_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp5_) : NULL);
	x_display = _tmp6_;
	_tmp7_ = gdk_x11_display_get_xdisplay (x_display);
	display = _tmp7_;
	cairo_surface_flush (background_surface);
	_tmp8_ = gdk_x11_window_get_xid (root_window);
	_tmp9_ = cairo_xlib_surface_get_drawable (background_surface);
	XSetWindowBackgroundPixmap (display, _tmp8_, (Pixmap) _tmp9_);
	_tmp10_ = gdk_x11_window_get_xid (root_window);
	XClearWindow (display, _tmp10_);
	_g_object_unref0 (x_display);
	_cairo_surface_destroy0 (background_surface);
	_g_object_unref0 (root_window);
	_g_object_unref0 (screen);
}


LoginGateway* pantheon_greeter_get_login_gateway (void) {
	LoginGateway* result;
	LoginGateway* _tmp0_ = NULL;
	_tmp0_ = pantheon_greeter__login_gateway;
	result = _tmp0_;
	return result;
}


static void pantheon_greeter_set_login_gateway (LoginGateway* value) {
	LoginGateway* _tmp0_ = NULL;
	LoginGateway* _tmp1_ = NULL;
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (pantheon_greeter__login_gateway);
	pantheon_greeter__login_gateway = _tmp1_;
}


PantheonGreeter* pantheon_greeter_get_instance (void) {
	PantheonGreeter* result;
	PantheonGreeter* _tmp0_ = NULL;
	_tmp0_ = pantheon_greeter__instance;
	result = _tmp0_;
	return result;
}


static void pantheon_greeter_set_instance (PantheonGreeter* value) {
	PantheonGreeter* _tmp0_ = NULL;
	PantheonGreeter* _tmp1_ = NULL;
	_tmp0_ = value;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (pantheon_greeter__instance);
	pantheon_greeter__instance = _tmp1_;
}


gboolean pantheon_greeter_get_TEST_MODE (void) {
	gboolean result;
	gboolean _tmp0_ = FALSE;
	_tmp0_ = pantheon_greeter__TEST_MODE;
	result = _tmp0_;
	return result;
}


static void pantheon_greeter_set_TEST_MODE (gboolean value) {
	gboolean _tmp0_ = FALSE;
	_tmp0_ = value;
	pantheon_greeter__TEST_MODE = _tmp0_;
}


static void pantheon_greeter_class_init (PantheonGreeterClass * klass) {
	pantheon_greeter_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (PantheonGreeterPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_pantheon_greeter_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_pantheon_greeter_set_property;
	G_OBJECT_CLASS (klass)->finalize = pantheon_greeter_finalize;
}


static void pantheon_greeter_instance_init (PantheonGreeter * self) {
	self->priv = PANTHEON_GREETER_GET_PRIVATE (self);
}


static void pantheon_greeter_finalize (GObject* obj) {
	PantheonGreeter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PANTHEON_GREETER, PantheonGreeter);
	_g_object_unref0 (self->priv->clutter);
	_g_object_unref0 (self->priv->wallpaper_actor);
	_g_object_unref0 (self->priv->time_actor);
	_g_object_unref0 (self->priv->power_actor);
	_g_object_unref0 (self->priv->greeterbox);
	_g_object_unref0 (self->priv->userlist_actor);
	_g_object_unref0 (self->priv->userlist);
	_g_object_unref0 (self->priv->indicator_bar_actor);
	_g_object_unref0 (self->priv->wallpaper);
	_g_object_unref0 (self->priv->blur_effect_actor);
	_g_key_file_free0 (self->settings);
	_g_key_file_free0 (self->state);
	_g_free0 (self->priv->state_file);
	G_OBJECT_CLASS (pantheon_greeter_parent_class)->finalize (obj);
}


/***
    BEGIN LICENSE

    Copyright (C) 2011-2014 elementary Developers

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License version 3, as published
    by the Free Software Foundation.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranties of
    MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR
    PURPOSE.  See the GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program.  If not, see <http://www.gnu.org/licenses/>

    END LICENSE
***/
GType pantheon_greeter_get_type (void) {
	static volatile gsize pantheon_greeter_type_id__volatile = 0;
	if (g_once_init_enter (&pantheon_greeter_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (PantheonGreeterClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) pantheon_greeter_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PantheonGreeter), 0, (GInstanceInitFunc) pantheon_greeter_instance_init, NULL };
		GType pantheon_greeter_type_id;
		pantheon_greeter_type_id = g_type_register_static (gtk_window_get_type (), "PantheonGreeter", &g_define_type_info, 0);
		g_once_init_leave (&pantheon_greeter_type_id__volatile, pantheon_greeter_type_id);
	}
	return pantheon_greeter_type_id__volatile;
}


static void _vala_pantheon_greeter_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	PantheonGreeter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_PANTHEON_GREETER, PantheonGreeter);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_pantheon_greeter_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	PantheonGreeter * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_PANTHEON_GREETER, PantheonGreeter);
	switch (property_id) {
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static gboolean __lambda32_ (void) {
	gboolean result = FALSE;
	gtk_main_quit ();
	result = TRUE;
	return result;
}


static gboolean ___lambda32__gsource_func (gpointer self) {
	gboolean result;
	result = __lambda32_ ();
	return result;
}


gint _vala_main (gchar** args, int args_length1) {
	gint result = 0;
	ClutterInitError init = 0;
	ClutterInitError _tmp0_ = 0;
	GdkCursor* cursor = NULL;
	GdkDisplay* _tmp1_ = NULL;
	GdkCursor* _tmp2_ = NULL;
	GdkWindow* _tmp3_ = NULL;
	GtkSettings* settings = NULL;
	GtkSettings* _tmp4_ = NULL;
	GtkSettings* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	PantheonGreeter* _tmp12_ = NULL;
	PantheonGreeter* _tmp13_ = NULL;
	mlockall (MCL_CURRENT | MCL_FUTURE);
	_tmp0_ = gtk_clutter_init (&args_length1, &args);
	init = _tmp0_;
	if (init != CLUTTER_INIT_SUCCESS) {
		g_error ("PantheonGreeter.vala:533: Clutter could not be intiailized");
	}
	g_unix_signal_add_full (G_PRIORITY_DEFAULT, (gint) SIGTERM, ___lambda32__gsource_func, NULL, NULL);
	setlocale (LC_ALL, "");
	bind_textdomain_codeset ("greeter", "UTF-8");
	textdomain ("greeter");
	_tmp1_ = gdk_display_get_default ();
	_tmp2_ = gdk_cursor_new_for_display (_tmp1_, GDK_LEFT_PTR);
	cursor = _tmp2_;
	_tmp3_ = gdk_get_default_root_window ();
	gdk_window_set_cursor (_tmp3_, cursor);
	_tmp4_ = gtk_settings_get_default ();
	_tmp5_ = _g_object_ref0 (_tmp4_);
	settings = _tmp5_;
	_tmp6_ = get_defaults ("gtk-theme");
	_tmp7_ = _tmp6_;
	g_object_set (settings, "gtk-theme-name", _tmp7_, NULL);
	_g_free0 (_tmp7_);
	_tmp8_ = get_defaults ("icon-theme");
	_tmp9_ = _tmp8_;
	g_object_set (settings, "gtk-icon-theme-name", _tmp9_, NULL);
	_g_free0 (_tmp9_);
	_tmp10_ = get_defaults ("cursor-theme");
	_tmp11_ = _tmp10_;
	g_object_set (settings, "gtk-cursor-theme-name", _tmp11_, NULL);
	_g_free0 (_tmp11_);
	_tmp12_ = pantheon_greeter_new ();
	g_object_ref_sink (_tmp12_);
	_tmp13_ = _tmp12_;
	_g_object_unref0 (_tmp13_);
	gtk_main ();
	result = EXIT_SUCCESS;
	_g_object_unref0 (settings);
	_g_object_unref0 (cursor);
	return result;
}


int main (int argc, char ** argv) {
#if !GLIB_CHECK_VERSION (2,35,0)
	g_type_init ();
#endif
	return _vala_main (argv, argc);
}


gchar* get_defaults (const gchar* _default_) {
	gchar* result = NULL;
	GKeyFile* settings = NULL;
	GKeyFile* _tmp0_ = NULL;
	gchar* ret = NULL;
	gchar* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (_default_ != NULL, NULL);
	_tmp0_ = g_key_file_new ();
	settings = _tmp0_;
	_tmp1_ = g_strdup ("");
	ret = _tmp1_;
	{
		GKeyFile* _tmp2_ = NULL;
		const gchar* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		GQuark _tmp6_ = 0U;
		static GQuark _tmp5_label0 = 0;
		static GQuark _tmp5_label1 = 0;
		static GQuark _tmp5_label2 = 0;
		static GQuark _tmp5_label3 = 0;
		_tmp2_ = settings;
		g_key_file_load_from_file (_tmp2_, CONSTANTS_CONF_DIR "/greeter.conf", G_KEY_FILE_KEEP_COMMENTS, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch8_g_error;
		}
		_tmp3_ = _default_;
		_tmp4_ = _tmp3_;
		_tmp6_ = (NULL == _tmp4_) ? 0 : g_quark_from_string (_tmp4_);
		if (_tmp6_ == ((0 != _tmp5_label0) ? _tmp5_label0 : (_tmp5_label0 = g_quark_from_static_string ("gtk-theme")))) {
			switch (0) {
				default:
				{
					gchar* _tmp7_ = NULL;
					GKeyFile* _tmp8_ = NULL;
					gchar* _tmp9_ = NULL;
					gchar* _tmp10_ = NULL;
					_tmp8_ = settings;
					_tmp9_ = g_key_file_get_string (_tmp8_, "greeter", "gtk-theme", &_inner_error_);
					_tmp7_ = _tmp9_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch8_g_error;
					}
					_tmp10_ = _tmp7_;
					_tmp7_ = NULL;
					_g_free0 (ret);
					ret = _tmp10_;
					_g_free0 (_tmp7_);
					break;
				}
			}
		} else if (_tmp6_ == ((0 != _tmp5_label1) ? _tmp5_label1 : (_tmp5_label1 = g_quark_from_static_string ("icon-theme")))) {
			switch (0) {
				default:
				{
					gchar* _tmp11_ = NULL;
					GKeyFile* _tmp12_ = NULL;
					gchar* _tmp13_ = NULL;
					gchar* _tmp14_ = NULL;
					_tmp12_ = settings;
					_tmp13_ = g_key_file_get_string (_tmp12_, "greeter", "icon-theme", &_inner_error_);
					_tmp11_ = _tmp13_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch8_g_error;
					}
					_tmp14_ = _tmp11_;
					_tmp11_ = NULL;
					_g_free0 (ret);
					ret = _tmp14_;
					_g_free0 (_tmp11_);
					break;
				}
			}
		} else if (_tmp6_ == ((0 != _tmp5_label2) ? _tmp5_label2 : (_tmp5_label2 = g_quark_from_static_string ("cursor-theme")))) {
			switch (0) {
				default:
				{
					gchar* _tmp15_ = NULL;
					GKeyFile* _tmp16_ = NULL;
					gchar* _tmp17_ = NULL;
					gchar* _tmp18_ = NULL;
					_tmp16_ = settings;
					_tmp17_ = g_key_file_get_string (_tmp16_, "greeter", "cursor-theme", &_inner_error_);
					_tmp15_ = _tmp17_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch8_g_error;
					}
					_tmp18_ = _tmp15_;
					_tmp15_ = NULL;
					_g_free0 (ret);
					ret = _tmp18_;
					_g_free0 (_tmp15_);
					break;
				}
			}
		} else if (_tmp6_ == ((0 != _tmp5_label3) ? _tmp5_label3 : (_tmp5_label3 = g_quark_from_static_string ("blur")))) {
			switch (0) {
				default:
				{
					gchar* _tmp19_ = NULL;
					GKeyFile* _tmp20_ = NULL;
					gchar* _tmp21_ = NULL;
					gchar* _tmp22_ = NULL;
					_tmp20_ = settings;
					_tmp21_ = g_key_file_get_string (_tmp20_, "greeter", "blur", &_inner_error_);
					_tmp19_ = _tmp21_;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch8_g_error;
					}
					_tmp22_ = _tmp19_;
					_tmp19_ = NULL;
					_g_free0 (ret);
					ret = _tmp22_;
					_g_free0 (_tmp19_);
					break;
				}
			}
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		GError* _tmp23_ = NULL;
		const gchar* _tmp24_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp23_ = e;
		_tmp24_ = _tmp23_->message;
		g_warning ("PantheonGreeter.vala:580: %s", _tmp24_);
		_g_error_free0 (e);
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_free0 (ret);
		_g_key_file_free0 (settings);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = ret;
	_g_key_file_free0 (settings);
	return result;
}



